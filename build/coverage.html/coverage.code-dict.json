{"/home/travis/build/npmtest/node-npmtest-browser-sync/test.js":"/* istanbul instrument in package npmtest_browser_sync */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-browser-sync/lib.npmtest_browser_sync.js":"/* istanbul instrument in package npmtest_browser_sync */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_browser_sync = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_browser_sync = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-browser-sync/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-browser-sync && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_browser_sync */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_browser_sync\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_browser_sync.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_browser_sync.rollup.js'] =\n            local.assetsDict['/assets.npmtest_browser_sync.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_browser_sync.__dirname + '/lib.npmtest_browser_sync.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/index.js":"#! /usr/bin/env node\n\"use strict\";\n\n/**\n * @module BrowserSync\n */\nvar pjson         = require(\"./package.json\");\nvar BrowserSync   = require(\"./lib/browser-sync\");\nvar publicUtils   = require(\"./lib/public/public-utils\");\nvar events        = require(\"events\");\nvar PassThrough   = require(\"stream\").PassThrough;\nvar logger        = require(\"eazy-logger\").Logger({\n    useLevelPrefixes: true\n});\n\nvar singleton        = false;\nvar singletonPlugins = [];\nvar instances        = [];\n\n/**\n * @type {boolean|EventEmitter}\n */\nvar singletonEmitter = false;\n\nmodule.exports         = initSingleton;\n\n/**\n * Create a Browsersync instance\n * @method create\n * @param {String} name an identifier that can used for retrieval later\n */\nmodule.exports.create    = create;\n\n/**\n * Get a single instance by name. This is useful if you have your\n * build scripts in separate files\n * @method get\n * @param {String} name\n * @returns {Object|Boolean}\n */\nmodule.exports.get = function (name) {\n    var instance = getSingle(name);\n    if (instance) {\n        return instance;\n    }\n    throw new Error(\"An instance with the name `%s` was not found.\".replace(\"%s\", name));\n};\n\n/**\n * Check if an instance has been created.\n * @method has\n * @param {String} name\n * @returns {Boolean}\n */\nmodule.exports.has = function (name) {\n    var instance = getSingle(name);\n    if (instance) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Start the Browsersync service. This will launch a server, proxy or start the snippet\n * mode depending on your use-case.\n * @method init\n * @param {Object} [config] This is the main configuration for your Browsersync instance and can contain any of the [available options]({{site.links.options}})\n *  If you do not pass a config an argument for configuration, Browsersync will still run; but it will be in the `snippet` mode\n * @param {Function} [cb] If you pass a callback function, it will be called when Browsersync has completed all setup tasks and is ready to use. This\n * is useful when you need to wait for information (for example: urls, port etc) or perform other tasks synchronously.\n * @returns {BrowserSync}\n */\nmodule.exports.init    = initSingleton;\n\n/**\n * Register a plugin. Must implement at least a 'plugin' method that returns a\n * callable function.\n *\n * @method use\n * @param {String} name The name of the plugin\n * @param {Object} module The object to be `required`.\n * @param {Function} [cb] A callback function that will return any errors.\n */\nmodule.exports.use     = function () {\n    var args = Array.prototype.slice.call(arguments);\n    singletonPlugins.push({\n        args: args\n    });\n};\n\n/**\n * The `reload` method will inform all browsers about changed files and will either cause the browser to refresh, or inject the files where possible.\n *\n * @method reload\n * @param {String|Array|Object} [arg] The file or files to be reloaded.\n * @returns {*}\n */\nmodule.exports.reload  = noop(\"reload\");\n\n/**\n * The `stream` method returns a transform stream and can act once or on many files.\n *\n * @method stream\n * @param {Object} [opts] Configuration for the stream method\n * @since 2.6.0\n * @returns {*}\n */\nmodule.exports.stream  = noop(\"stream\");\n\n/**\n * Helper method for browser notifications\n *\n * @method notify\n * @param {String|HTML} msg Can be a simple message such as 'Connected' or HTML\n * @param {Number} [timeout] How long the message will remain in the browser. @since 1.3.0\n */\nmodule.exports.notify  = noop(\"notify\");\n\n/**\n * This method will close any running server, stop file watching & exit the current process.\n *\n * @method exit\n */\nmodule.exports.exit    = noop(\"exit\");\n\n/**\n * Stand alone file-watcher. Use this along with Browsersync to create your own, minimal build system\n * @method watch\n * @param {string} patterns Glob patterns for files to watch\n * @param {object} [opts] Options to be passed to Chokidar - check what's available in [their docs](https://github.com/paulmillr/chokidar#getting-started)\n * @param {function} [fn] Callback function for each event.\n * @since 2.6.0\n */\nmodule.exports.watch   = noop(\"watch\");\n\n/**\n * Method to pause file change events\n *\n * @method pause\n */\nmodule.exports.pause   = noop(\"pause\");\n\n/**\n * Method to resume paused watchers\n *\n * @method resume\n */\nmodule.exports.resume  = noop(\"resume\");\n\n/**\n * Add properties fo\n */\nObject.defineProperties(module.exports, {\n    /**\n     * The internal Event Emitter used by the running Browsersync instance (if there is one).\n     * You can use this to emit your own events, such as changed files, logging etc.\n     *\n     * @property emitter\n     */\n    \"emitter\": {\n        get: function () {\n            if (!singletonEmitter) {\n                singletonEmitter = newEmitter();\n                return singletonEmitter;\n            }\n            return singletonEmitter;\n        }\n    },\n    /**\n     * A simple true/false flag that you can use to determine if there's a currently-running Browsersync instance.\n     *\n     * @property active\n     */\n    \"active\": {\n        get: getSingletonValue.bind(null, \"active\")\n    },\n    /**\n     * A simple true/false flag to determine if the current instance is paused\n     *\n     * @property paused\n     */\n    \"paused\": {\n        get: getSingletonValue.bind(null, \"paused\")\n    }\n});\n\n/**\n * Event emitter factory\n * @returns {EventEmitter}\n */\nfunction newEmitter() {\n    var emitter = new events.EventEmitter();\n    emitter.setMaxListeners(20);\n    return emitter;\n}\n\n/**\n * Get the singleton's emitter, or a new one.\n * @returns {EventEmitter}\n */\nfunction getSingletonEmitter() {\n    if (singletonEmitter) {\n        return singletonEmitter;\n    }\n    singletonEmitter = newEmitter();\n    return singletonEmitter;\n}\n\n/**\n * Helper to allow methods to be called on the module export\n * before there's a running instance\n * @param {String} name\n * @returns {Function}\n */\nfunction noop(name) {\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n        if (singleton) {\n            return singleton[name].apply(singleton, args);\n        } else {\n            if (publicUtils.isStreamArg(name, args)) {\n                return new PassThrough({objectMode: true});\n            }\n        }\n    };\n}\n\n/**\n * Create a single instance when module export is used directly via browserSync({});\n * This is mostly for back-compatibility, for also for the nicer api.\n * This will never be removed to ensure we never break user-land, but\n * we should discourage it's use.\n * @returns {*}\n */\nfunction initSingleton() {\n    var instance;\n    if (instances.length) {\n        instance = instances.filter(function (item) {\n            return item.name === \"singleton\";\n        });\n        if (instance.length) {\n            logger.error(\"{yellow:You tried to start Browsersync twice!} To create multiple instances, use {cyan:browserSync.create().init()\");\n            return instance;\n        }\n    }\n    var args = Array.prototype.slice.call(arguments);\n    singleton = create(\"singleton\", getSingletonEmitter());\n\n    if (singletonPlugins.length) {\n        singletonPlugins.forEach(function (obj) {\n            singleton.instance.registerPlugin.apply(singleton.instance, obj.args);\n        });\n    }\n\n    singleton.init.apply(null, args);\n    return singleton;\n}\n\n/**\n * @param {String} prop\n * @returns {Object|Boolean}\n */\nfunction getSingletonValue(prop) {\n    var single = getSingle(\"singleton\");\n    if (single) {\n        return single[prop];\n    }\n    return false;\n}\n\n/**\n * Get a single instance by name\n * @param {String} name\n * @returns {Object|Boolean}\n */\nfunction getSingle(name) {\n    if (instances.length) {\n        var match = instances.filter(function (item) {\n            return item.name === name;\n        });\n        if (match.length) {\n            return match[0];\n        }\n    }\n    return false;\n}\n\n/**\n * Create an instance of Browsersync\n * @param {String} [name]\n * @param {EventEmitter} [emitter]\n * @returns {{init: *, exit: (exit|exports), notify: *, reload: *, cleanup: *, emitter: (Browsersync.events|*), use: *}}\n */\nfunction create(name, emitter) {\n\n    name    = name    || new Date().getTime();\n    emitter = emitter || newEmitter();\n\n    var browserSync = new BrowserSync(emitter);\n\n    var instance = {\n        name:      name,\n        instance:  browserSync,\n        exit:      require(\"./lib/public/exit\")(browserSync),\n        notify:    require(\"./lib/public/notify\")(browserSync),\n        pause:     require(\"./lib/public/pause\")(browserSync),\n        resume:    require(\"./lib/public/resume\")(browserSync),\n        reload:    require(\"./lib/public/reload\")(emitter),\n        stream:    require(\"./lib/public/stream\")(emitter),\n        cleanup:   browserSync.cleanup.bind(browserSync),\n        use:       browserSync.registerPlugin.bind(browserSync),\n        getOption: browserSync.getOption.bind(browserSync),\n        emitter:   browserSync.events,\n        watch:     require(\"./lib/file-watcher\").watch\n    };\n\n    browserSync.publicInstance = instance;\n    instance.init = require(\"./lib/public/init\")(browserSync, name, pjson);\n\n    Object.defineProperty(instance, \"active\", {\n        get: function () {\n            return browserSync.active;\n        }\n    });\n\n    Object.defineProperty(instance, \"paused\", {\n        get: function () {\n            return browserSync.paused;\n        }\n    });\n\n    /**\n     * Access to client-side socket for emitting events\n     *\n     * @property sockets\n     */\n    Object.defineProperty(instance, \"sockets\", {\n        get: function () {\n            if (!browserSync.active) {\n                return {\n                    emit: function () {},\n                    on: function () {}\n                };\n            } else {\n                return browserSync.io.sockets;\n            }\n        }\n    });\n\n    instances.push(instance);\n\n    return instance;\n}\n\n/**\n * Reset the state of the module.\n * (should only be needed for test environments)\n */\nmodule.exports.reset = function () {\n    instances.forEach(function (item) {\n        item.cleanup();\n    });\n    instances        = [];\n    singletonPlugins = [];\n    singletonEmitter = false;\n    singleton        = false;\n};\n\n/**\n * @type {Array}\n */\nmodule.exports.instances = instances;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/browser-sync.js":"\"use strict\";\n\nvar hooks           = require(\"./hooks\");\nvar asyncTasks      = require(\"./async-tasks\");\nvar config          = require(\"./config\");\nvar connectUtils    = require(\"./connect-utils\");\nvar utils           = require(\"./utils\");\nvar logger          = require(\"./logger\");\n\nvar eachSeries      = utils.eachSeries;\nvar _               = require(\"../lodash.custom\");\nvar EE              = require(\"easy-extender\");\n\n/**\n * Required internal plugins.\n * Any of these can be overridden by deliberately\n * causing a name-clash.\n */\nvar defaultPlugins = {\n    \"logger\":        logger,\n    \"socket\":        require(\"./sockets\"),\n    \"file:watcher\":  require(\"./file-watcher\"),\n    \"server\":        require(\"./server\"),\n    \"tunnel\":        require(\"./tunnel\"),\n    \"client:script\": require(\"browser-sync-client\"),\n    \"UI\":            require(\"browser-sync-ui\")\n};\n\n/**\n * @constructor\n */\nvar BrowserSync = function (emitter) {\n\n    var bs      = this;\n\n    bs.cwd      = process.cwd();\n    bs.active   = false;\n    bs.paused   = false;\n    bs.config   = config;\n    bs.utils    = utils;\n    bs.events   = bs.emitter = emitter;\n\n    bs._userPlugins   = [];\n    bs._reloadQueue   = [];\n    bs._cleanupTasks  = [];\n    bs._browserReload = false;\n\n    // Plugin management\n    bs.pluginManager = new EE(defaultPlugins, hooks);\n};\n\n/**\n * Call a user-options provided callback\n * @param name\n */\nBrowserSync.prototype.callback = function (name) {\n\n    var bs  = this;\n    var cb  = bs.options.getIn([\"callbacks\", name]);\n\n    if (_.isFunction(cb)) {\n        cb.apply(bs.publicInstance, _.toArray(arguments).slice(1));\n    }\n};\n\n/**\n * @param {Map} options\n * @param {Function} cb\n * @returns {BrowserSync}\n */\nBrowserSync.prototype.init = function (options, cb) {\n\n    /**\n     * Safer access to `this`\n     * @type {BrowserSync}\n     */\n    var bs = this;\n\n    /**\n     * Set user-provided callback, or assign a noop\n     * @type {Function}\n     */\n    bs.cb  = cb || utils.defaultCallback;\n\n    /**\n     * Verify provided config.\n     * Some options are not compatible and will cause us to\n     * end the process.\n     */\n    if (!utils.verifyConfig(options, bs.cb)) {\n        return;\n    }\n\n    /**\n     * Save a reference to the original options\n     * @type {Map}\n     * @private\n     */\n    bs._options = options;\n\n    /**\n     * Set additional options that depend on what the\n     * user may of provided\n     * @type {Map}\n     */\n    bs.options  = require(\"./options\").update(options);\n\n    /**\n     * Kick off default plugins.\n     */\n    bs.pluginManager.init();\n\n    /**\n     * Create a base logger & debugger.\n     */\n    bs.logger   = bs.pluginManager.get(\"logger\")(bs.events, bs);\n    bs.debugger = bs.logger.clone({useLevelPrefixes: true});\n    bs.debug    = bs.debugger.debug;\n\n    /**\n     * Run each setup task in sequence\n     */\n    eachSeries(\n        asyncTasks,\n        taskRunner(bs),\n        tasksComplete(bs)\n    );\n\n    return this;\n};\n\n/**\n * Run 1 setup task.\n * Each task is a pure function.\n * They can return options or instance properties to set,\n * but they cannot set them directly.\n * @param {BrowserSync} bs\n * @returns {Function}\n */\nfunction taskRunner (bs) {\n\n    return function (item, cb) {\n\n        bs.debug(\"-> {yellow:Starting Step: \" + item.step);\n\n        /**\n         * Execute the current task.\n         */\n        item.fn(bs, executeTask);\n\n        function executeTask(err, out) {\n\n            /**\n             * Exit early if any task returned an error.\n             */\n            if (err) {\n                return cb(err);\n            }\n\n            /**\n             * Act on return values (such as options to be set,\n             * or instance properties to be set\n             */\n            if (out) {\n                handleOut(bs, out);\n            }\n\n            bs.debug(\"+  {green:Step Complete: \" + item.step);\n\n            cb();\n        }\n    };\n}\n\n/**\n * @param bs\n * @param out\n */\nfunction handleOut (bs, out) {\n    /**\n     * Set a single/many option.\n     */\n    if (out.options) {\n        setOptions(bs, out.options);\n    }\n\n    /**\n     * Any options returned that require path access?\n     */\n    if (out.optionsIn) {\n        out.optionsIn.forEach(function (item) {\n            bs.setOptionIn(item.path, item.value);\n        });\n    }\n\n    /**\n     * Any instance properties returned?\n     */\n    if (out.instance) {\n        Object.keys(out.instance).forEach(function (key) {\n            bs[key] = out.instance[key];\n        });\n    }\n}\n\n/**\n * Update the options Map\n * @param bs\n * @param options\n */\nfunction setOptions (bs, options) {\n\n    /**\n     * If multiple options were set, act on the immutable map\n     * in an efficient way\n     */\n    if (Object.keys(options).length > 1) {\n        bs.setMany(function (item) {\n            Object.keys(options).forEach(function (key) {\n                item.set(key, options[key]);\n                return item;\n            });\n        });\n    } else {\n        Object.keys(options).forEach(function (key) {\n            bs.setOption(key, options[key]);\n        });\n    }\n}\n\n/**\n * At this point, ALL async tasks have completed\n * @param {BrowserSync} bs\n * @returns {Function}\n */\nfunction tasksComplete (bs) {\n\n    return function (err) {\n\n        if (err) {\n            bs.logger.setOnce(\"useLevelPrefixes\", true).error(err.message);\n        }\n\n        /**\n         * Set active flag\n         */\n        bs.active = true;\n\n        /**\n         * @deprecated\n         */\n        bs.events.emit(\"init\", bs);\n\n        /**\n         * This is no-longer needed as the Callback now only resolves\n         * when everything (including slow things, like the tunnel) is ready.\n         * It's here purely for backwards compatibility.\n         * @deprecated\n         */\n        bs.events.emit(\"service:running\", {\n            options: bs.options,\n            baseDir: bs.options.getIn([\"server\", \"baseDir\"]),\n            type:    bs.options.get(\"mode\"),\n            port:    bs.options.get(\"port\"),\n            url:     bs.options.getIn([\"urls\", \"local\"]),\n            urls:    bs.options.get(\"urls\").toJS(),\n            tunnel:  bs.options.getIn([\"urls\", \"tunnel\"])\n        });\n\n        /**\n         * Call any option-provided callbacks\n         */\n        bs.callback(\"ready\", null, bs);\n\n        /**\n         * Finally, call the user-provided callback given as last arg\n         */\n        bs.cb(null, bs);\n    };\n}\n\n/**\n * @param module\n * @param opts\n * @param cb\n */\nBrowserSync.prototype.registerPlugin = function (module, opts, cb) {\n\n    var bs = this;\n\n    bs.pluginManager.registerPlugin(module, opts, cb);\n\n    if (module[\"plugin:name\"]) {\n        bs._userPlugins.push(module);\n    }\n};\n\n/**\n * Get a plugin by name\n * @param name\n */\nBrowserSync.prototype.getUserPlugin = function (name) {\n\n    var bs = this;\n\n    var items = bs.getUserPlugins(function (item) {\n        return item[\"plugin:name\"] === name;\n    });\n\n    if (items && items.length) {\n        return items[0];\n    }\n\n    return false;\n};\n\n/**\n * @param {Function} [filter]\n */\nBrowserSync.prototype.getUserPlugins = function (filter) {\n\n    var bs = this;\n\n    filter = filter || function () {\n        return true;\n    };\n\n    /**\n     * Transform Plugins option\n     */\n    bs.userPlugins = bs._userPlugins.filter(filter).map(function (plugin) {\n        return {\n            name: plugin[\"plugin:name\"],\n            active: plugin._enabled,\n            opts: bs.pluginManager.pluginOptions[plugin[\"plugin:name\"]]\n        };\n    });\n\n    return bs.userPlugins;\n};\n\n/**\n * Get middleware\n * @returns {*}\n */\nBrowserSync.prototype.getMiddleware = function (type) {\n\n    var types = {\n        \"connector\": connectUtils.socketConnector(this.options),\n        \"socket-js\": require(\"./snippet\").utils.getSocketScript()\n    };\n\n    if (type in types) {\n        return function (req, res) {\n            res.setHeader(\"Content-Type\", \"text/javascript\");\n            res.end(types[type]);\n        };\n    }\n};\n\n/**\n * Shortcut for pushing a file-serving middleware\n * onto the stack\n * @param {String} path\n * @param {{type: string, content: string}} props\n */\nvar _serveFileCount = 0;\nBrowserSync.prototype.serveFile = function (path, props) {\n\n    var bs = this;\n    var mode = bs.options.get(\"mode\");\n    var entry = {\n        handle: function (req, res) {\n            res.setHeader(\"Content-Type\", props.type);\n            res.end(props.content);\n        },\n        id: \"Browsersync - \" + _serveFileCount++,\n        route: path\n    };\n\n    bs._addMiddlewareToStack(entry);\n};\n\n/**\n * Add middlewares on the fly\n * @param {{route: string, handle: function, id?: string}}\n */\nBrowserSync.prototype._addMiddlewareToStack = function (entry) {\n    var bs = this;\n    if (bs.options.get(\"mode\") === \"proxy\") {\n        bs.app.stack.splice(bs.app.stack.length-1, 0, entry);\n    } else {\n        bs.app.stack.push(entry);\n    }\n};\n\nvar _addMiddlewareCount = 0;\nBrowserSync.prototype.addMiddleware = function (route, handle, opts) {\n\n    var bs   = this;\n\n    if (!bs.app) {\n        return;\n    }\n\n    opts = opts || {};\n\n    if (!opts.id) {\n        opts.id = \"bs-mw-\" + _addMiddlewareCount++;\n    }\n\n    if (route === \"*\") {\n        route = \"\";\n    }\n\n    var entry = {\n        id: opts.id,\n        route: route,\n        handle: handle\n    };\n\n    if (opts.override) {\n        entry.override = true;\n    }\n\n    bs.options = bs.options.update(\"middleware\", function (mw) {\n        if (bs.options.get(\"mode\") === \"proxy\") {\n            return mw.insert(mw.size-1, entry);\n        }\n        return mw.concat(entry);\n    });\n\n    bs.resetMiddlewareStack();\n};\n\n/**\n * Remove middlewares on the fly\n * @param {String} id\n * @returns {Server}\n */\nBrowserSync.prototype.removeMiddleware = function (id) {\n\n    var bs = this;\n\n    if (!bs.app) {\n        return;\n    }\n\n    bs.options = bs.options.update(\"middleware\", function (mw) {\n        return mw.filter(function (mw) {\n            return mw.id !== id;\n        });\n    });\n\n    bs.resetMiddlewareStack();\n};\n\n/**\n * Middleware for socket connection (external usage)\n * @param opts\n * @returns {*}\n */\nBrowserSync.prototype.getSocketConnector = function (opts) {\n\n    var bs = this;\n\n    return function (req, res) {\n        res.setHeader(\"Content-Type\", \"text/javascript\");\n        res.end(bs.getExternalSocketConnector(opts));\n    };\n};\n\n/**\n * Socket connector as a string\n * @param {Object} opts\n * @returns {*}\n */\nBrowserSync.prototype.getExternalSocketConnector = function (opts) {\n\n    var bs = this;\n\n    return connectUtils.socketConnector(\n        bs.options.withMutations(function (item) {\n            item.set(\"socket\", item.get(\"socket\").merge(opts));\n            if (!bs.options.getIn([\"proxy\", \"ws\"])) {\n                item.set(\"mode\", \"snippet\");\n            }\n        })\n    );\n};\n\n/**\n * Socket io as string (for embedding)\n * @returns {*}\n */\nBrowserSync.prototype.getSocketIoScript = function () {\n\n    return require(\"./snippet\").utils.getSocketScript();\n};\n\n/**\n * Callback helper\n * @param name\n */\nBrowserSync.prototype.getOption = function (name) {\n\n    this.debug(\"Getting option: {magenta:%s\", name);\n    return this.options.get(name);\n};\n\n/**\n * Callback helper\n * @param path\n */\nBrowserSync.prototype.getOptionIn = function (path) {\n\n    this.debug(\"Getting option via path: {magenta:%s\", path);\n    return this.options.getIn(path);\n};\n\n/**\n * @returns {BrowserSync.options}\n */\nBrowserSync.prototype.getOptions = function () {\n    return this.options;\n};\n\n/**\n * @returns {BrowserSync.options}\n */\nBrowserSync.prototype.getLogger = logger.getLogger;\n\n/**\n * @param {String} name\n * @param {*} value\n * @returns {BrowserSync.options|*}\n */\nBrowserSync.prototype.setOption = function (name, value, opts) {\n\n    var bs = this;\n\n    opts = opts || {};\n\n    bs.debug(\"Setting Option: {cyan:%s} - {magenta:%s\", name, value.toString());\n\n    bs.options = bs.options.set(name, value);\n\n    if (!opts.silent) {\n        bs.events.emit(\"options:set\", {path: name, value: value, options: bs.options});\n    }\n    return this.options;\n};\n\n/**\n * @param path\n * @param value\n * @param opts\n * @returns {Map|*|BrowserSync.options}\n */\nBrowserSync.prototype.setOptionIn = function (path, value, opts) {\n\n    var bs = this;\n\n    opts = opts || {};\n\n    bs.debug(\"Setting Option: {cyan:%s} - {magenta:%s\", path.join(\".\"), value.toString());\n    bs.options = bs.options.setIn(path, value);\n    if (!opts.silent) {\n        bs.events.emit(\"options:set\", {path: path, value: value, options: bs.options});\n    }\n    return bs.options;\n};\n\n/**\n * Set multiple options with mutations\n * @param fn\n * @param opts\n * @returns {Map|*}\n */\nBrowserSync.prototype.setMany = function (fn, opts) {\n\n    var bs = this;\n\n    opts = opts || {};\n\n    bs.debug(\"Setting multiple Options\");\n    bs.options = bs.options.withMutations(fn);\n    if (!opts.silent) {\n        bs.events.emit(\"options:set\", {options: bs.options.toJS()});\n    }\n    return this.options;\n};\n\nBrowserSync.prototype.addRewriteRule = function (rule) {\n    var bs = this;\n\n    bs.options = bs.options.update(\"rewriteRules\", function (rules) {\n        return rules.concat(rule);\n    });\n\n    bs.resetMiddlewareStack();\n};\n\nBrowserSync.prototype.removeRewriteRule = function (id) {\n    var bs = this;\n    bs.options = bs.options.update(\"rewriteRules\", function (rules) {\n        return rules.filter(function (rule) {\n            return rule.id !== id;\n        });\n    });\n\n    bs.resetMiddlewareStack();\n};\n\nBrowserSync.prototype.setRewriteRules = function (rules) {\n    var bs = this;\n    bs.options = bs.options.update(\"rewriteRules\", function (_) {\n        return rules;\n    });\n\n    bs.resetMiddlewareStack();\n};\n\n/**\n * Add a new rewrite rule to the stack\n * @param {Object} rule\n */\nBrowserSync.prototype.resetMiddlewareStack = function () {\n\n    var bs = this;\n    var middlewares = require(\"./server/utils\").getMiddlewares(bs, bs.options);\n\n    bs.app.stack = middlewares;\n};\n\n/**\n * @param fn\n */\nBrowserSync.prototype.registerCleanupTask = function (fn) {\n\n    this._cleanupTasks.push(fn);\n};\n\n/**\n * Instance Cleanup\n */\nBrowserSync.prototype.cleanup = function (cb) {\n\n    var bs = this;\n    if (!bs.active) {\n        return;\n    }\n\n    // Remove all event listeners\n    if (bs.events) {\n        bs.debug(\"Removing event listeners...\");\n        bs.events.removeAllListeners();\n    }\n\n    // Close any core file watchers\n    if (bs.watchers) {\n        Object.keys(bs.watchers).forEach(function (key) {\n            bs.watchers[key].watchers.forEach(function (watcher) {\n                watcher.close();\n            });\n        });\n    }\n\n    // Run any additional clean up tasks\n    bs._cleanupTasks.forEach(function (fn) {\n        if (_.isFunction(fn)) {\n            fn(bs);\n        }\n    });\n\n    // Reset the flag\n    bs.debug(\"Setting {magenta:active: false\");\n    bs.active = false;\n    bs.paused = false;\n\n    bs.pluginManager.plugins        = {};\n    bs.pluginManager.pluginOptions  = {};\n    bs.pluginManager.defaultPlugins = defaultPlugins;\n\n    bs._userPlugins                = [];\n    bs.userPlugins                 = [];\n    bs._reloadTimer                = undefined;\n    bs._reloadQueue                = [];\n    bs._cleanupTasks               = [];\n\n    if (_.isFunction(cb)) {\n        cb(null, bs);\n    }\n};\n\nmodule.exports = BrowserSync;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/hooks.js":"\"use strict\";\n\nvar _            = require(\"../lodash.custom\");\nvar Immutable    = require(\"immutable\");\nvar snippetUtils = require(\"./snippet\").utils;\n\nmodule.exports = {\n\n    /**\n     *\n     * @this {BrowserSync}\n     * @returns {String}\n     */\n    \"client:js\": function (hooks, data) {\n\n        var js  = snippetUtils.getClientJs(data.port, data.options);\n\n        return hooks.reduce(function (joined, hook) {\n            return joined + hook;\n        }, js);\n    },\n    /**\n     * @this {BrowserSync}\n     * @returns {Array}\n     */\n    \"client:events\": function (hooks, clientEvents) {\n\n        hooks.forEach(function (hook) {\n\n            var result = hook(this);\n\n            if (Array.isArray(result)) {\n                clientEvents = _.union(clientEvents, result);\n            } else {\n                clientEvents.push(result);\n            }\n        }, this);\n\n        return clientEvents;\n    },\n    /**\n     * @returns {Array}\n     */\n    \"server:middleware\": function (hooks, initial) {\n\n        initial = initial || [];\n\n        _.each(hooks, function (hook) {\n\n            var result = hook(this);\n\n            if (Array.isArray(result)) {\n                result.forEach(function (res) {\n                    if (_.isFunction(res)) {\n                        initial = initial.push(res);\n                    }\n                });\n\n            } else {\n                if (_.isFunction(result)) {\n                    initial = initial.push(result);\n                }\n            }\n        }, this);\n\n        return initial;\n    },\n    /**\n     * @param {Array} hooks\n     * @param {Map|List} initial\n     * @param pluginOptions\n     * @returns {any}\n     */\n    \"files:watch\": function (hooks, initial, pluginOptions) {\n\n        var opts;\n\n        if (pluginOptions) {\n            opts = Immutable.fromJS(pluginOptions);\n            opts.forEach(function (value, key) {\n                if (!value) {\n                    return;\n                }\n                var files = value.get(\"files\");\n                if (files) {\n                    var fileArg = require(\"./cli/cli-options\").makeFilesArg(files);\n                    if (fileArg) {\n                        initial = initial.set(key, Immutable.fromJS(fileArg));\n                    }\n                }\n            });\n        }\n\n        return initial;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lodash.custom.js":"/**\n * @license\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash include=\"isUndefined,isFunction,toArray,includes,union,each,isString,merge,isObject,set\" exports=\"node\"`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.13.1';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used to compose bitmasks for comparison styles. */\n  var UNORDERED_COMPARE_FLAG = 1,\n      PARTIAL_COMPARE_FLAG = 2;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(\\.|\\[\\])(?:\\4|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n  /** Used to compose unicode capture groups. */\n  var rsAstral = '[' + rsAstralRange + ']',\n      rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseInt = parseInt;\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = checkGlobal(typeof global == 'object' && global);\n\n  /** Detect free variable `self`. */\n  var freeSelf = checkGlobal(typeof self == 'object' && self);\n\n  /** Detect `this` as the global object. */\n  var thisGlobal = checkGlobal(typeof this == 'object' && this);\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || thisGlobal || Function('return this')();\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Adds the key-value `pair` to `map`.\n   *\n   * @private\n   * @param {Object} map The map to modify.\n   * @param {Array} pair The key-value pair to add.\n   * @returns {Object} Returns `map`.\n   */\n  function addMapEntry(map, pair) {\n    // Don't return `Map#set` because it doesn't return the map instance in IE 11.\n    map.set(pair[0], pair[1]);\n    return map;\n  }\n\n  /**\n   * Adds `value` to `set`.\n   *\n   * @private\n   * @param {Object} set The set to modify.\n   * @param {*} value The value to add.\n   * @returns {Object} Returns `set`.\n   */\n  function addSetEntry(set, value) {\n    set.add(value);\n    return set;\n  }\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    var length = args.length;\n    switch (length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to search.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array ? array.length : 0;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to search.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array ? array.length : 0,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    if (value !== value) {\n      return indexOfNaN(array, fromIndex);\n    }\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a cache value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Checks if `value` is a global object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {null|Object} Returns `value` if it's a global object, else `null`.\n   */\n  function checkGlobal(value) {\n    return (value && value.Object === Object) ? value : null;\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n   */\n  function indexOfNaN(array, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var other = array[index];\n      if (other !== other) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if `value` is a host object in IE < 9.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n   */\n  function isHostObject(value) {\n    // Many host objects are `Object` objects that can coerce to strings\n    // despite having improperly defined `toString` methods.\n    var result = false;\n    if (value != null && typeof value.toString != 'function') {\n      try {\n        result = !!(value + '');\n      } catch (e) {}\n    }\n    return result;\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return string.match(reComplexSymbol);\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype,\n      objectProto = Object.prototype;\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = root['__core-js_shared__'];\n\n  /** Used to detect methods masquerading as native. */\n  var maskSrcKey = (function() {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n    return uid ? ('Symbol(src)_1.' + uid) : '';\n  }());\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = Function.prototype.toString;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /** Used to infer the `Object` constructor. */\n  var objectCtorString = funcToString.call(Object);\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString = objectProto.toString;\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp('^' +\n    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n    .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n  );\n\n  /** Built-in value references. */\n  var Buffer = moduleExports ? root.Buffer : undefined,\n      Reflect = root.Reflect,\n      Symbol = root.Symbol,\n      Uint8Array = root.Uint8Array,\n      enumerate = Reflect ? Reflect.enumerate : undefined,\n      getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined,\n      objectCreate = Object.create,\n      propertyIsEnumerable = objectProto.propertyIsEnumerable,\n      splice = arrayProto.splice;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeGetPrototype = Object.getPrototypeOf,\n      nativeKeys = Object.keys,\n      nativeMax = Math.max;\n\n  /* Built-in method references that are verified to be native. */\n  var DataView = getNative(root, 'DataView'),\n      Map = getNative(root, 'Map'),\n      Promise = getNative(root, 'Promise'),\n      Set = getNative(root, 'Set'),\n      WeakMap = getNative(root, 'WeakMap'),\n      nativeCreate = getNative(Object, 'create');\n\n  /** Used to lookup unminified function names. */\n  var realNames = {};\n\n  /** Used to detect maps, sets, and weakmaps. */\n  var dataViewCtorString = toSource(DataView),\n      mapCtorString = toSource(Map),\n      promiseCtorString = toSource(Promise),\n      setCtorString = toSource(Set),\n      weakMapCtorString = toSource(WeakMap);\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = Symbol ? Symbol.prototype : undefined,\n      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n      symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a `lodash` object which wraps `value` to enable implicit method\n   * chain sequences. Methods that operate on and return arrays, collections,\n   * and functions can be chained together. Methods that retrieve a single value\n   * or may return a primitive value will automatically end the chain sequence\n   * and return the unwrapped value. Otherwise, the value must be unwrapped\n   * with `_#value`.\n   *\n   * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n   * enabled using `_.chain`.\n   *\n   * The execution of chained methods is lazy, that is, it's deferred until\n   * `_#value` is implicitly or explicitly called.\n   *\n   * Lazy evaluation allows several methods to support shortcut fusion.\n   * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n   * the creation of intermediate arrays and can greatly reduce the number of\n   * iteratee executions. Sections of a chain sequence qualify for shortcut\n   * fusion if the section is applied to an array of at least `200` elements\n   * and any iteratees accept only one argument. The heuristic for whether a\n   * section qualifies for shortcut fusion is subject to change.\n   *\n   * Chaining is supported in custom builds as long as the `_#value` method is\n   * directly or indirectly included in the build.\n   *\n   * In addition to lodash methods, wrappers have `Array` and `String` methods.\n   *\n   * The wrapper `Array` methods are:\n   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n   *\n   * The wrapper `String` methods are:\n   * `replace` and `split`\n   *\n   * The wrapper methods that support shortcut fusion are:\n   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n   *\n   * The chainable wrapper methods are:\n   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n   * `zipObject`, `zipObjectDeep`, and `zipWith`\n   *\n   * The wrapper methods that are **not** chainable by default are:\n   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `divide`, `each`,\n   * `eachRight`, `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`,\n   * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`,\n   * `floor`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,\n   * `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`,\n   * `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`,\n   * `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`,\n   * `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,\n   * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`,\n   * `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n   * `upperFirst`, `value`, and `words`\n   *\n   * @name _\n   * @constructor\n   * @category Seq\n   * @param {*} value The value to wrap in a `lodash` instance.\n   * @returns {Object} Returns the new `lodash` wrapper instance.\n   * @example\n   *\n   * function square(n) {\n   *   return n * n;\n   * }\n   *\n   * var wrapped = _([1, 2, 3]);\n   *\n   * // Returns an unwrapped value.\n   * wrapped.reduce(_.add);\n   * // => 6\n   *\n   * // Returns a wrapped value.\n   * var squares = wrapped.map(square);\n   *\n   * _.isArray(squares);\n   * // => false\n   *\n   * _.isArray(squares.value());\n   * // => true\n   */\n  function lodash() {\n    // No operation performed.\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Hash(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n  function hashClear() {\n    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  }\n\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function hashDelete(key) {\n    return this.has(key) && delete this.__data__[key];\n  }\n\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function hashGet(key) {\n    var data = this.__data__;\n    if (nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n    return hasOwnProperty.call(data, key) ? data[key] : undefined;\n  }\n\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function hashHas(key) {\n    var data = this.__data__;\n    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n  }\n\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n  function hashSet(key, value) {\n    var data = this.__data__;\n    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n    return this;\n  }\n\n  // Add methods to `Hash`.\n  Hash.prototype.clear = hashClear;\n  Hash.prototype['delete'] = hashDelete;\n  Hash.prototype.get = hashGet;\n  Hash.prototype.has = hashHas;\n  Hash.prototype.set = hashSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function ListCache(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n  function listCacheClear() {\n    this.__data__ = [];\n  }\n\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n    return true;\n  }\n\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    return index < 0 ? undefined : data[index][1];\n  }\n\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1;\n  }\n\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n    return this;\n  }\n\n  // Add methods to `ListCache`.\n  ListCache.prototype.clear = listCacheClear;\n  ListCache.prototype['delete'] = listCacheDelete;\n  ListCache.prototype.get = listCacheGet;\n  ListCache.prototype.has = listCacheHas;\n  ListCache.prototype.set = listCacheSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function MapCache(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n  function mapCacheClear() {\n    this.__data__ = {\n      'hash': new Hash,\n      'map': new (Map || ListCache),\n      'string': new Hash\n    };\n  }\n\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function mapCacheDelete(key) {\n    return getMapData(this, key)['delete'](key);\n  }\n\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key);\n  }\n\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key);\n  }\n\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n  function mapCacheSet(key, value) {\n    getMapData(this, key).set(key, value);\n    return this;\n  }\n\n  // Add methods to `MapCache`.\n  MapCache.prototype.clear = mapCacheClear;\n  MapCache.prototype['delete'] = mapCacheDelete;\n  MapCache.prototype.get = mapCacheGet;\n  MapCache.prototype.has = mapCacheHas;\n  MapCache.prototype.set = mapCacheSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   *\n   * Creates an array cache object to store unique values.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [values] The values to cache.\n   */\n  function SetCache(values) {\n    var index = -1,\n        length = values ? values.length : 0;\n\n    this.__data__ = new MapCache;\n    while (++index < length) {\n      this.add(values[index]);\n    }\n  }\n\n  /**\n   * Adds `value` to the array cache.\n   *\n   * @private\n   * @name add\n   * @memberOf SetCache\n   * @alias push\n   * @param {*} value The value to cache.\n   * @returns {Object} Returns the cache instance.\n   */\n  function setCacheAdd(value) {\n    this.__data__.set(value, HASH_UNDEFINED);\n    return this;\n  }\n\n  /**\n   * Checks if `value` is in the array cache.\n   *\n   * @private\n   * @name has\n   * @memberOf SetCache\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `true` if `value` is found, else `false`.\n   */\n  function setCacheHas(value) {\n    return this.__data__.has(value);\n  }\n\n  // Add methods to `SetCache`.\n  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n  SetCache.prototype.has = setCacheHas;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a stack cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Stack(entries) {\n    this.__data__ = new ListCache(entries);\n  }\n\n  /**\n   * Removes all key-value entries from the stack.\n   *\n   * @private\n   * @name clear\n   * @memberOf Stack\n   */\n  function stackClear() {\n    this.__data__ = new ListCache;\n  }\n\n  /**\n   * Removes `key` and its value from the stack.\n   *\n   * @private\n   * @name delete\n   * @memberOf Stack\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function stackDelete(key) {\n    return this.__data__['delete'](key);\n  }\n\n  /**\n   * Gets the stack value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Stack\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function stackGet(key) {\n    return this.__data__.get(key);\n  }\n\n  /**\n   * Checks if a stack value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Stack\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function stackHas(key) {\n    return this.__data__.has(key);\n  }\n\n  /**\n   * Sets the stack `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Stack\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the stack cache instance.\n   */\n  function stackSet(key, value) {\n    var cache = this.__data__;\n    if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {\n      cache = this.__data__ = new MapCache(cache.__data__);\n    }\n    cache.set(key, value);\n    return this;\n  }\n\n  // Add methods to `Stack`.\n  Stack.prototype.clear = stackClear;\n  Stack.prototype['delete'] = stackDelete;\n  Stack.prototype.get = stackGet;\n  Stack.prototype.has = stackHas;\n  Stack.prototype.set = stackSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * This function is like `assignValue` except that it doesn't assign\n   * `undefined` values.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignMergeValue(object, key, value) {\n    if ((value !== undefined && !eq(object[key], value)) ||\n        (typeof key == 'number' && value === undefined && !(key in object))) {\n      object[key] = value;\n    }\n  }\n\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignValue(object, key, value) {\n    var objValue = object[key];\n    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n        (value === undefined && !(key in object))) {\n      object[key] = value;\n    }\n  }\n\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function assocIndexOf(array, key) {\n    var length = array.length;\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.assign` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssign(object, source) {\n    return object && copyObject(source, keys(source), object);\n  }\n\n  /**\n   * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n   * traversed objects.\n   *\n   * @private\n   * @param {*} value The value to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @param {boolean} [isFull] Specify a clone including symbols.\n   * @param {Function} [customizer] The function to customize cloning.\n   * @param {string} [key] The key of `value`.\n   * @param {Object} [object] The parent object of `value`.\n   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n   * @returns {*} Returns the cloned value.\n   */\n  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n    var result;\n    if (customizer) {\n      result = object ? customizer(value, key, object, stack) : customizer(value);\n    }\n    if (result !== undefined) {\n      return result;\n    }\n    if (!isObject(value)) {\n      return value;\n    }\n    var isArr = isArray(value);\n    if (isArr) {\n      result = initCloneArray(value);\n      if (!isDeep) {\n        return copyArray(value, result);\n      }\n    } else {\n      var tag = getTag(value),\n          isFunc = tag == funcTag || tag == genTag;\n\n      if (isBuffer(value)) {\n        return cloneBuffer(value, isDeep);\n      }\n      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n        if (isHostObject(value)) {\n          return object ? value : {};\n        }\n        result = initCloneObject(isFunc ? {} : value);\n        if (!isDeep) {\n          return copySymbols(value, baseAssign(result, value));\n        }\n      } else {\n        if (!cloneableTags[tag]) {\n          return object ? value : {};\n        }\n        result = initCloneByTag(value, tag, baseClone, isDeep);\n      }\n    }\n    // Check for circular references and return its corresponding clone.\n    stack || (stack = new Stack);\n    var stacked = stack.get(value);\n    if (stacked) {\n      return stacked;\n    }\n    stack.set(value, result);\n\n    if (!isArr) {\n      var props = isFull ? getAllKeys(value) : keys(value);\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    arrayEach(props || value, function(subValue, key) {\n      if (props) {\n        key = subValue;\n        subValue = value[key];\n      }\n      assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.create` without support for assigning\n   * properties to the created object.\n   *\n   * @private\n   * @param {Object} prototype The object to inherit from.\n   * @returns {Object} Returns the new object.\n   */\n  function baseCreate(proto) {\n    return isObject(proto) ? objectCreate(proto) : {};\n  }\n\n  /**\n   * The base implementation of `_.forEach` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   */\n  var baseEach = createBaseEach(baseForOwn);\n\n  /**\n   * The base implementation of `_.flatten` with support for restricting flattening.\n   *\n   * @private\n   * @param {Array} array The array to flatten.\n   * @param {number} depth The maximum recursion depth.\n   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n   * @param {Array} [result=[]] The initial result value.\n   * @returns {Array} Returns the new flattened array.\n   */\n  function baseFlatten(array, depth, predicate, isStrict, result) {\n    var index = -1,\n        length = array.length;\n\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n\n    while (++index < length) {\n      var value = array[index];\n      if (depth > 0 && predicate(value)) {\n        if (depth > 1) {\n          // Recursively flatten arrays (susceptible to call stack limits).\n          baseFlatten(value, depth - 1, predicate, isStrict, result);\n        } else {\n          arrayPush(result, value);\n        }\n      } else if (!isStrict) {\n        result[result.length] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `baseForOwn` which iterates over `object`\n   * properties returned by `keysFunc` and invokes `iteratee` for each property.\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @returns {Object} Returns `object`.\n   */\n  var baseFor = createBaseFor();\n\n  /**\n   * The base implementation of `_.forOwn` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Object} Returns `object`.\n   */\n  function baseForOwn(object, iteratee) {\n    return object && baseFor(object, iteratee, keys);\n  }\n\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n  function baseGet(object, path) {\n    path = isKey(path, object) ? [path] : castPath(path);\n\n    var index = 0,\n        length = path.length;\n\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])];\n    }\n    return (index && index == length) ? object : undefined;\n  }\n\n  /**\n   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n   * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @param {Function} symbolsFunc The function to get the symbols of `object`.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n  }\n\n  /**\n   * The base implementation of `_.has` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHas(object, key) {\n    // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,\n    // that are composed entirely of index properties, return `false` for\n    // `hasOwnProperty` checks of them.\n    return object != null &&\n      (hasOwnProperty.call(object, key) ||\n        (typeof object == 'object' && key in object && getPrototype(object) === null));\n  }\n\n  /**\n   * The base implementation of `_.hasIn` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object);\n  }\n\n  /**\n   * The base implementation of `_.isEqual` which supports partial comparisons\n   * and tracks traversed objects.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {boolean} [bitmask] The bitmask of comparison flags.\n   *  The bitmask may be composed of the following flags:\n   *     1 - Unordered comparison\n   *     2 - Partial comparison\n   * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   */\n  function baseIsEqual(value, other, customizer, bitmask, stack) {\n    if (value === other) {\n      return true;\n    }\n    if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n      return value !== value && other !== other;\n    }\n    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n  }\n\n  /**\n   * A specialized version of `baseIsEqual` for arrays and objects which performs\n   * deep comparisons and tracks traversed objects enabling objects with circular\n   * references to be compared.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n   *  for more details.\n   * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n    var objIsArr = isArray(object),\n        othIsArr = isArray(other),\n        objTag = arrayTag,\n        othTag = arrayTag;\n\n    if (!objIsArr) {\n      objTag = getTag(object);\n      objTag = objTag == argsTag ? objectTag : objTag;\n    }\n    if (!othIsArr) {\n      othTag = getTag(other);\n      othTag = othTag == argsTag ? objectTag : othTag;\n    }\n    var objIsObj = objTag == objectTag && !isHostObject(object),\n        othIsObj = othTag == objectTag && !isHostObject(other),\n        isSameTag = objTag == othTag;\n\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack);\n      return (objIsArr || isTypedArray(object))\n        ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n        : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n    }\n    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n            othUnwrapped = othIsWrapped ? other.value() : other;\n\n        stack || (stack = new Stack);\n        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n      }\n    }\n    if (!isSameTag) {\n      return false;\n    }\n    stack || (stack = new Stack);\n    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n  }\n\n  /**\n   * The base implementation of `_.isMatch` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property values to match.\n   * @param {Array} matchData The property names, values, and compare flags to match.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n   */\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n        length = index,\n        noCustomizer = !customizer;\n\n    if (object == null) {\n      return !length;\n    }\n    object = Object(object);\n    while (index--) {\n      var data = matchData[index];\n      if ((noCustomizer && data[2])\n            ? data[1] !== object[data[0]]\n            : !(data[0] in object)\n          ) {\n        return false;\n      }\n    }\n    while (++index < length) {\n      data = matchData[index];\n      var key = data[0],\n          objValue = object[key],\n          srcValue = data[1];\n\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false;\n        }\n      } else {\n        var stack = new Stack;\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack);\n        }\n        if (!(result === undefined\n              ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n              : result\n            )) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false;\n    }\n    var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n\n  /**\n   * The base implementation of `_.iteratee`.\n   *\n   * @private\n   * @param {*} [value=_.identity] The value to convert to an iteratee.\n   * @returns {Function} Returns the iteratee.\n   */\n  function baseIteratee(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == 'function') {\n      return value;\n    }\n    if (value == null) {\n      return identity;\n    }\n    if (typeof value == 'object') {\n      return isArray(value)\n        ? baseMatchesProperty(value[0], value[1])\n        : baseMatches(value);\n    }\n    return property(value);\n  }\n\n  /**\n   * The base implementation of `_.keys` which doesn't skip the constructor\n   * property of prototypes or treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeys(object) {\n    return nativeKeys(Object(object));\n  }\n\n  /**\n   * The base implementation of `_.keysIn` which doesn't skip the constructor\n   * property of prototypes or treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeysIn(object) {\n    object = object == null ? object : Object(object);\n\n    var result = [];\n    for (var key in object) {\n      result.push(key);\n    }\n    return result;\n  }\n\n  // Fallback for IE < 9 with es6-shim.\n  if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {\n    baseKeysIn = function(object) {\n      return iteratorToArray(enumerate(object));\n    };\n  }\n\n  /**\n   * The base implementation of `_.matches` which doesn't clone `source`.\n   *\n   * @private\n   * @param {Object} source The object of property values to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatches(source) {\n    var matchData = getMatchData(source);\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n    return function(object) {\n      return object === source || baseIsMatch(object, source, matchData);\n    };\n  }\n\n  /**\n   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n   *\n   * @private\n   * @param {string} path The path of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue);\n    }\n    return function(object) {\n      var objValue = get(object, path);\n      return (objValue === undefined && objValue === srcValue)\n        ? hasIn(object, path)\n        : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n    };\n  }\n\n  /**\n   * The base implementation of `_.merge` without support for multiple sources.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @param {number} srcIndex The index of `source`.\n   * @param {Function} [customizer] The function to customize merged values.\n   * @param {Object} [stack] Tracks traversed source values and their merged\n   *  counterparts.\n   */\n  function baseMerge(object, source, srcIndex, customizer, stack) {\n    if (object === source) {\n      return;\n    }\n    if (!(isArray(source) || isTypedArray(source))) {\n      var props = keysIn(source);\n    }\n    arrayEach(props || source, function(srcValue, key) {\n      if (props) {\n        key = srcValue;\n        srcValue = source[key];\n      }\n      if (isObject(srcValue)) {\n        stack || (stack = new Stack);\n        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n      }\n      else {\n        var newValue = customizer\n          ? customizer(object[key], srcValue, (key + ''), object, source, stack)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = srcValue;\n        }\n        assignMergeValue(object, key, newValue);\n      }\n    });\n  }\n\n  /**\n   * A specialized version of `baseMerge` for arrays and objects which performs\n   * deep merges and tracks traversed objects enabling objects with circular\n   * references to be merged.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @param {string} key The key of the value to merge.\n   * @param {number} srcIndex The index of `source`.\n   * @param {Function} mergeFunc The function to merge values.\n   * @param {Function} [customizer] The function to customize assigned values.\n   * @param {Object} [stack] Tracks traversed source values and their merged\n   *  counterparts.\n   */\n  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n    var objValue = object[key],\n        srcValue = source[key],\n        stacked = stack.get(srcValue);\n\n    if (stacked) {\n      assignMergeValue(object, key, stacked);\n      return;\n    }\n    var newValue = customizer\n      ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n      : undefined;\n\n    var isCommon = newValue === undefined;\n\n    if (isCommon) {\n      newValue = srcValue;\n      if (isArray(srcValue) || isTypedArray(srcValue)) {\n        if (isArray(objValue)) {\n          newValue = objValue;\n        }\n        else if (isArrayLikeObject(objValue)) {\n          newValue = copyArray(objValue);\n        }\n        else {\n          isCommon = false;\n          newValue = baseClone(srcValue, true);\n        }\n      }\n      else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n        if (isArguments(objValue)) {\n          newValue = toPlainObject(objValue);\n        }\n        else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {\n          isCommon = false;\n          newValue = baseClone(srcValue, true);\n        }\n        else {\n          newValue = objValue;\n        }\n      }\n      else {\n        isCommon = false;\n      }\n    }\n    stack.set(srcValue, newValue);\n\n    if (isCommon) {\n      // Recursively merge objects and arrays (susceptible to call stack limits).\n      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    }\n    stack['delete'](srcValue);\n    assignMergeValue(object, key, newValue);\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * A specialized version of `baseProperty` which supports deep paths.\n   *\n   * @private\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyDeep(path) {\n    return function(object) {\n      return baseGet(object, path);\n    };\n  }\n\n  /**\n   * The base implementation of `_.set`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @param {Function} [customizer] The function to customize path creation.\n   * @returns {Object} Returns `object`.\n   */\n  function baseSet(object, path, value, customizer) {\n    path = isKey(path, object) ? [path] : castPath(path);\n\n    var index = -1,\n        length = path.length,\n        lastIndex = length - 1,\n        nested = object;\n\n    while (nested != null && ++index < length) {\n      var key = toKey(path[index]);\n      if (isObject(nested)) {\n        var newValue = value;\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = objValue == null\n              ? (isIndex(path[index + 1]) ? [] : {})\n              : objValue;\n          }\n        }\n        assignValue(nested, key, newValue);\n      }\n      nested = nested[key];\n    }\n    return object;\n  }\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n  }\n\n  /**\n   * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new duplicate free array.\n   */\n  function baseUniq(array, iteratee, comparator) {\n    var index = -1,\n        includes = arrayIncludes,\n        length = array.length,\n        isCommon = true,\n        result = [],\n        seen = result;\n\n    if (comparator) {\n      isCommon = false;\n      includes = arrayIncludesWith;\n    }\n    else if (length >= LARGE_ARRAY_SIZE) {\n      var set = iteratee ? null : createSet(array);\n      if (set) {\n        return setToArray(set);\n      }\n      isCommon = false;\n      includes = cacheHas;\n      seen = new SetCache;\n    }\n    else {\n      seen = iteratee ? [] : result;\n    }\n    outer:\n    while (++index < length) {\n      var value = array[index],\n          computed = iteratee ? iteratee(value) : value;\n\n      value = (comparator || value !== 0) ? value : 0;\n      if (isCommon && computed === computed) {\n        var seenIndex = seen.length;\n        while (seenIndex--) {\n          if (seen[seenIndex] === computed) {\n            continue outer;\n          }\n        }\n        if (iteratee) {\n          seen.push(computed);\n        }\n        result.push(value);\n      }\n      else if (!includes(seen, computed, comparator)) {\n        if (seen !== result) {\n          seen.push(computed);\n        }\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {Array} Returns the cast property path array.\n   */\n  function castPath(value) {\n    return isArray(value) ? value : stringToPath(value);\n  }\n\n  /**\n   * Creates a clone of  `buffer`.\n   *\n   * @private\n   * @param {Buffer} buffer The buffer to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Buffer} Returns the cloned buffer.\n   */\n  function cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n      return buffer.slice();\n    }\n    var result = new buffer.constructor(buffer.length);\n    buffer.copy(result);\n    return result;\n  }\n\n  /**\n   * Creates a clone of `arrayBuffer`.\n   *\n   * @private\n   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n   * @returns {ArrayBuffer} Returns the cloned array buffer.\n   */\n  function cloneArrayBuffer(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n    return result;\n  }\n\n  /**\n   * Creates a clone of `dataView`.\n   *\n   * @private\n   * @param {Object} dataView The data view to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned data view.\n   */\n  function cloneDataView(dataView, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n  }\n\n  /**\n   * Creates a clone of `map`.\n   *\n   * @private\n   * @param {Object} map The map to clone.\n   * @param {Function} cloneFunc The function to clone values.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned map.\n   */\n  function cloneMap(map, isDeep, cloneFunc) {\n    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n    return arrayReduce(array, addMapEntry, new map.constructor);\n  }\n\n  /**\n   * Creates a clone of `regexp`.\n   *\n   * @private\n   * @param {Object} regexp The regexp to clone.\n   * @returns {Object} Returns the cloned regexp.\n   */\n  function cloneRegExp(regexp) {\n    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n    result.lastIndex = regexp.lastIndex;\n    return result;\n  }\n\n  /**\n   * Creates a clone of `set`.\n   *\n   * @private\n   * @param {Object} set The set to clone.\n   * @param {Function} cloneFunc The function to clone values.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned set.\n   */\n  function cloneSet(set, isDeep, cloneFunc) {\n    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n    return arrayReduce(array, addSetEntry, new set.constructor);\n  }\n\n  /**\n   * Creates a clone of the `symbol` object.\n   *\n   * @private\n   * @param {Object} symbol The symbol object to clone.\n   * @returns {Object} Returns the cloned symbol object.\n   */\n  function cloneSymbol(symbol) {\n    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n  }\n\n  /**\n   * Creates a clone of `typedArray`.\n   *\n   * @private\n   * @param {Object} typedArray The typed array to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned typed array.\n   */\n  function cloneTypedArray(typedArray, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n  }\n\n  /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */\n  function copyArray(source, array) {\n    var index = -1,\n        length = source.length;\n\n    array || (array = Array(length));\n    while (++index < length) {\n      array[index] = source[index];\n    }\n    return array;\n  }\n\n  /**\n   * Copies properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy properties from.\n   * @param {Array} props The property identifiers to copy.\n   * @param {Object} [object={}] The object to copy properties to.\n   * @param {Function} [customizer] The function to customize copied values.\n   * @returns {Object} Returns `object`.\n   */\n  function copyObject(source, props, object, customizer) {\n    object || (object = {});\n\n    var index = -1,\n        length = props.length;\n\n    while (++index < length) {\n      var key = props[index];\n\n      var newValue = customizer\n        ? customizer(object[key], source[key], key, object, source)\n        : source[key];\n\n      assignValue(object, key, newValue);\n    }\n    return object;\n  }\n\n  /**\n   * Copies own symbol properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbols(source, object) {\n    return copyObject(source, getSymbols(source), object);\n  }\n\n  /**\n   * Creates a function like `_.assign`.\n   *\n   * @private\n   * @param {Function} assigner The function to assign values.\n   * @returns {Function} Returns the new assigner function.\n   */\n  function createAssigner(assigner) {\n    return rest(function(object, sources) {\n      var index = -1,\n          length = sources.length,\n          customizer = length > 1 ? sources[length - 1] : undefined,\n          guard = length > 2 ? sources[2] : undefined;\n\n      customizer = (assigner.length > 3 && typeof customizer == 'function')\n        ? (length--, customizer)\n        : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        customizer = length < 3 ? undefined : customizer;\n        length = 1;\n      }\n      object = Object(object);\n      while (++index < length) {\n        var source = sources[index];\n        if (source) {\n          assigner(object, source, index, customizer);\n        }\n      }\n      return object;\n    });\n  }\n\n  /**\n   * Creates a `baseEach` or `baseEachRight` function.\n   *\n   * @private\n   * @param {Function} eachFunc The function to iterate over a collection.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseEach(eachFunc, fromRight) {\n    return function(collection, iteratee) {\n      if (collection == null) {\n        return collection;\n      }\n      if (!isArrayLike(collection)) {\n        return eachFunc(collection, iteratee);\n      }\n      var length = collection.length,\n          index = fromRight ? length : -1,\n          iterable = Object(collection);\n\n      while ((fromRight ? index-- : ++index < length)) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break;\n        }\n      }\n      return collection;\n    };\n  }\n\n  /**\n   * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseFor(fromRight) {\n    return function(object, iteratee, keysFunc) {\n      var index = -1,\n          iterable = Object(object),\n          props = keysFunc(object),\n          length = props.length;\n\n      while (length--) {\n        var key = props[fromRight ? length : ++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break;\n        }\n      }\n      return object;\n    };\n  }\n\n  /**\n   * Creates a set of `values`.\n   *\n   * @private\n   * @param {Array} values The values to add to the set.\n   * @returns {Object} Returns the new set.\n   */\n  var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n    return new Set(values);\n  };\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for arrays with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Array} array The array to compare.\n   * @param {Array} other The other array to compare.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n   *  for more details.\n   * @param {Object} stack Tracks traversed `array` and `other` objects.\n   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n   */\n  function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n        arrLength = array.length,\n        othLength = other.length;\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n      return false;\n    }\n    // Assume cyclic values are equal.\n    var stacked = stack.get(array);\n    if (stacked) {\n      return stacked == other;\n    }\n    var index = -1,\n        result = true,\n        seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n    stack.set(array, other);\n\n    // Ignore non-index properties.\n    while (++index < arrLength) {\n      var arrValue = array[index],\n          othValue = other[index];\n\n      if (customizer) {\n        var compared = isPartial\n          ? customizer(othValue, arrValue, index, other, array, stack)\n          : customizer(arrValue, othValue, index, array, other, stack);\n      }\n      if (compared !== undefined) {\n        if (compared) {\n          continue;\n        }\n        result = false;\n        break;\n      }\n      // Recursively compare arrays (susceptible to call stack limits).\n      if (seen) {\n        if (!arraySome(other, function(othValue, othIndex) {\n              if (!seen.has(othIndex) &&\n                  (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n                return seen.add(othIndex);\n              }\n            })) {\n          result = false;\n          break;\n        }\n      } else if (!(\n            arrValue === othValue ||\n              equalFunc(arrValue, othValue, customizer, bitmask, stack)\n          )) {\n        result = false;\n        break;\n      }\n    }\n    stack['delete'](array);\n    return result;\n  }\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for comparing objects of\n   * the same `toStringTag`.\n   *\n   * **Note:** This function only supports comparing values with tags of\n   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {string} tag The `toStringTag` of the objects to compare.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n   *  for more details.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n    switch (tag) {\n      case dataViewTag:\n        if ((object.byteLength != other.byteLength) ||\n            (object.byteOffset != other.byteOffset)) {\n          return false;\n        }\n        object = object.buffer;\n        other = other.buffer;\n\n      case arrayBufferTag:\n        if ((object.byteLength != other.byteLength) ||\n            !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n          return false;\n        }\n        return true;\n\n      case boolTag:\n      case dateTag:\n        // Coerce dates and booleans to numbers, dates to milliseconds and\n        // booleans to `1` or `0` treating invalid dates coerced to `NaN` as\n        // not equal.\n        return +object == +other;\n\n      case errorTag:\n        return object.name == other.name && object.message == other.message;\n\n      case numberTag:\n        // Treat `NaN` vs. `NaN` as equal.\n        return (object != +object) ? other != +other : object == +other;\n\n      case regexpTag:\n      case stringTag:\n        // Coerce regexes to strings and treat strings, primitives and objects,\n        // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring\n        // for more details.\n        return object == (other + '');\n\n      case mapTag:\n        var convert = mapToArray;\n\n      case setTag:\n        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n        convert || (convert = setToArray);\n\n        if (object.size != other.size && !isPartial) {\n          return false;\n        }\n        // Assume cyclic values are equal.\n        var stacked = stack.get(object);\n        if (stacked) {\n          return stacked == other;\n        }\n        bitmask |= UNORDERED_COMPARE_FLAG;\n        stack.set(object, other);\n\n        // Recursively compare objects (susceptible to call stack limits).\n        return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n\n      case symbolTag:\n        if (symbolValueOf) {\n          return symbolValueOf.call(object) == symbolValueOf.call(other);\n        }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for objects with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n   *  for more details.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n        objProps = keys(object),\n        objLength = objProps.length,\n        othProps = keys(other),\n        othLength = othProps.length;\n\n    if (objLength != othLength && !isPartial) {\n      return false;\n    }\n    var index = objLength;\n    while (index--) {\n      var key = objProps[index];\n      if (!(isPartial ? key in other : baseHas(other, key))) {\n        return false;\n      }\n    }\n    // Assume cyclic values are equal.\n    var stacked = stack.get(object);\n    if (stacked) {\n      return stacked == other;\n    }\n    var result = true;\n    stack.set(object, other);\n\n    var skipCtor = isPartial;\n    while (++index < objLength) {\n      key = objProps[index];\n      var objValue = object[key],\n          othValue = other[key];\n\n      if (customizer) {\n        var compared = isPartial\n          ? customizer(othValue, objValue, key, other, object, stack)\n          : customizer(objValue, othValue, key, object, other, stack);\n      }\n      // Recursively compare objects (susceptible to call stack limits).\n      if (!(compared === undefined\n            ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n            : compared\n          )) {\n        result = false;\n        break;\n      }\n      skipCtor || (skipCtor = key == 'constructor');\n    }\n    if (result && !skipCtor) {\n      var objCtor = object.constructor,\n          othCtor = other.constructor;\n\n      // Non `Object` object instances with different constructors are not equal.\n      if (objCtor != othCtor &&\n          ('constructor' in object && 'constructor' in other) &&\n          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n            typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n        result = false;\n      }\n    }\n    stack['delete'](object);\n    return result;\n  }\n\n  /**\n   * Creates an array of own enumerable property names and symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols);\n  }\n\n  /**\n   * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n   * this function returns the custom method, otherwise it returns `baseIteratee`.\n   * If arguments are provided, the chosen function is invoked with them and\n   * its result is returned.\n   *\n   * @private\n   * @param {*} [value] The value to convert to an iteratee.\n   * @param {number} [arity] The arity of the created iteratee.\n   * @returns {Function} Returns the chosen function or its result.\n   */\n  function getIteratee() {\n    var result = lodash.iteratee || iteratee;\n    result = result === iteratee ? baseIteratee : result;\n    return arguments.length ? result(arguments[0], arguments[1]) : result;\n  }\n\n  /**\n   * Gets the \"length\" property value of `object`.\n   *\n   * **Note:** This function is used to avoid a\n   * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects\n   * Safari on at least iOS 8.1-8.3 ARM64.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {*} Returns the \"length\" value.\n   */\n  var getLength = baseProperty('length');\n\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return isKeyable(key)\n      ? data[typeof key == 'string' ? 'string' : 'hash']\n      : data.map;\n  }\n\n  /**\n   * Gets the property names, values, and compare flags of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the match data of `object`.\n   */\n  function getMatchData(object) {\n    var result = keys(object),\n        length = result.length;\n\n    while (length--) {\n      var key = result[length],\n          value = object[key];\n\n      result[length] = [key, value, isStrictComparable(value)];\n    }\n    return result;\n  }\n\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n  function getNative(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n  }\n\n  /**\n   * Gets the `[[Prototype]]` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {null|Object} Returns the `[[Prototype]]`.\n   */\n  function getPrototype(value) {\n    return nativeGetPrototype(Object(value));\n  }\n\n  /**\n   * Creates an array of the own enumerable symbol properties of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n  function getSymbols(object) {\n    // Coerce `object` to an object to avoid non-object errors in V8.\n    // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.\n    return getOwnPropertySymbols(Object(object));\n  }\n\n  // Fallback for IE < 11.\n  if (!getOwnPropertySymbols) {\n    getSymbols = stubArray;\n  }\n\n  /**\n   * Gets the `toStringTag` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function getTag(value) {\n    return objectToString.call(value);\n  }\n\n  // Fallback for data views, maps, sets, and weak maps in IE 11,\n  // for data views in Edge, and promises in Node.js.\n  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n      (Map && getTag(new Map) != mapTag) ||\n      (Promise && getTag(Promise.resolve()) != promiseTag) ||\n      (Set && getTag(new Set) != setTag) ||\n      (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n    getTag = function(value) {\n      var result = objectToString.call(value),\n          Ctor = result == objectTag ? value.constructor : undefined,\n          ctorString = Ctor ? toSource(Ctor) : undefined;\n\n      if (ctorString) {\n        switch (ctorString) {\n          case dataViewCtorString: return dataViewTag;\n          case mapCtorString: return mapTag;\n          case promiseCtorString: return promiseTag;\n          case setCtorString: return setTag;\n          case weakMapCtorString: return weakMapTag;\n        }\n      }\n      return result;\n    };\n  }\n\n  /**\n   * Checks if `path` exists on `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @param {Function} hasFunc The function to check properties.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   */\n  function hasPath(object, path, hasFunc) {\n    path = isKey(path, object) ? [path] : castPath(path);\n\n    var result,\n        index = -1,\n        length = path.length;\n\n    while (++index < length) {\n      var key = toKey(path[index]);\n      if (!(result = object != null && hasFunc(object, key))) {\n        break;\n      }\n      object = object[key];\n    }\n    if (result) {\n      return result;\n    }\n    var length = object ? object.length : 0;\n    return !!length && isLength(length) && isIndex(key, length) &&\n      (isArray(object) || isString(object) || isArguments(object));\n  }\n\n  /**\n   * Initializes an array clone.\n   *\n   * @private\n   * @param {Array} array The array to clone.\n   * @returns {Array} Returns the initialized clone.\n   */\n  function initCloneArray(array) {\n    var length = array.length,\n        result = array.constructor(length);\n\n    // Add properties assigned by `RegExp#exec`.\n    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n      result.index = array.index;\n      result.input = array.input;\n    }\n    return result;\n  }\n\n  /**\n   * Initializes an object clone.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneObject(object) {\n    return (typeof object.constructor == 'function' && !isPrototype(object))\n      ? baseCreate(getPrototype(object))\n      : {};\n  }\n\n  /**\n   * Initializes an object clone based on its `toStringTag`.\n   *\n   * **Note:** This function only supports cloning values with tags of\n   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @param {string} tag The `toStringTag` of the object to clone.\n   * @param {Function} cloneFunc The function to clone values.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneByTag(object, tag, cloneFunc, isDeep) {\n    var Ctor = object.constructor;\n    switch (tag) {\n      case arrayBufferTag:\n        return cloneArrayBuffer(object);\n\n      case boolTag:\n      case dateTag:\n        return new Ctor(+object);\n\n      case dataViewTag:\n        return cloneDataView(object, isDeep);\n\n      case float32Tag: case float64Tag:\n      case int8Tag: case int16Tag: case int32Tag:\n      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n        return cloneTypedArray(object, isDeep);\n\n      case mapTag:\n        return cloneMap(object, isDeep, cloneFunc);\n\n      case numberTag:\n      case stringTag:\n        return new Ctor(object);\n\n      case regexpTag:\n        return cloneRegExp(object);\n\n      case setTag:\n        return cloneSet(object, isDeep, cloneFunc);\n\n      case symbolTag:\n        return cloneSymbol(object);\n    }\n  }\n\n  /**\n   * Creates an array of index keys for `object` values of arrays,\n   * `arguments` objects, and strings, otherwise `null` is returned.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array|null} Returns index keys, else `null`.\n   */\n  function indexKeys(object) {\n    var length = object ? object.length : undefined;\n    if (isLength(length) &&\n        (isArray(object) || isString(object) || isArguments(object))) {\n      return baseTimes(length, String);\n    }\n    return null;\n  }\n\n  /**\n   * Checks if `value` is a flattenable `arguments` object or array.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n   */\n  function isFlattenable(value) {\n    return isArray(value) || isArguments(value);\n  }\n\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n  function isIndex(value, length) {\n    length = length == null ? MAX_SAFE_INTEGER : length;\n    return !!length &&\n      (typeof value == 'number' || reIsUint.test(value)) &&\n      (value > -1 && value % 1 == 0 && value < length);\n  }\n\n  /**\n   * Checks if the given arguments are from an iteratee call.\n   *\n   * @private\n   * @param {*} value The potential iteratee value argument.\n   * @param {*} index The potential iteratee index or key argument.\n   * @param {*} object The potential iteratee object argument.\n   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n   *  else `false`.\n   */\n  function isIterateeCall(value, index, object) {\n    if (!isObject(object)) {\n      return false;\n    }\n    var type = typeof index;\n    if (type == 'number'\n          ? (isArrayLike(object) && isIndex(index, object.length))\n          : (type == 'string' && index in object)\n        ) {\n      return eq(object[index], value);\n    }\n    return false;\n  }\n\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n  function isKey(value, object) {\n    if (isArray(value)) {\n      return false;\n    }\n    var type = typeof value;\n    if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n        value == null || isSymbol(value)) {\n      return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n      (object != null && value in Object(object));\n  }\n\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n  function isKeyable(value) {\n    var type = typeof value;\n    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n      ? (value !== '__proto__')\n      : (value === null);\n  }\n\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n  function isMasked(func) {\n    return !!maskSrcKey && (maskSrcKey in func);\n  }\n\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n    return value === proto;\n  }\n\n  /**\n   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` if suitable for strict\n   *  equality comparisons, else `false`.\n   */\n  function isStrictComparable(value) {\n    return value === value && !isObject(value);\n  }\n\n  /**\n   * A specialized version of `matchesProperty` for source values suitable\n   * for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function matchesStrictComparable(key, srcValue) {\n    return function(object) {\n      if (object == null) {\n        return false;\n      }\n      return object[key] === srcValue &&\n        (srcValue !== undefined || (key in Object(object)));\n    };\n  }\n\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n  var stringToPath = memoize(function(string) {\n    var result = [];\n    toString(string).replace(rePropName, function(match, number, quote, string) {\n      result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n    });\n    return result;\n  });\n\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value;\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n  }\n\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to process.\n   * @returns {string} Returns the source code.\n   */\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n      try {\n        return (func + '');\n      } catch (e) {}\n    }\n    return '';\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates an array of unique values, in order, from all given arrays using\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {...Array} [arrays] The arrays to inspect.\n   * @returns {Array} Returns the new array of combined values.\n   * @example\n   *\n   * _.union([2], [1, 2]);\n   * // => [2, 1]\n   */\n  var union = rest(function(arrays) {\n    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n  });\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Iterates over elements of `collection` and invokes `iteratee` for each element.\n   * The iteratee is invoked with three arguments: (value, index|key, collection).\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n   * property are iterated like arrays. To avoid this behavior use `_.forIn`\n   * or `_.forOwn` for object iteration.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @alias each\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   * @see _.forEachRight\n   * @example\n   *\n   * _([1, 2]).forEach(function(value) {\n   *   console.log(value);\n   * });\n   * // => Logs `1` then `2`.\n   *\n   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n   *   console.log(key);\n   * });\n   * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n   */\n  function forEach(collection, iteratee) {\n    var func = isArray(collection) ? arrayEach : baseEach;\n    return func(collection, getIteratee(iteratee, 3));\n  }\n\n  /**\n   * Checks if `value` is in `collection`. If `collection` is a string, it's\n   * checked for a substring of `value`, otherwise\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n   * is used for equality comparisons. If `fromIndex` is negative, it's used as\n   * the offset from the end of `collection`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object|string} collection The collection to search.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n   * @returns {boolean} Returns `true` if `value` is found, else `false`.\n   * @example\n   *\n   * _.includes([1, 2, 3], 1);\n   * // => true\n   *\n   * _.includes([1, 2, 3], 1, 2);\n   * // => false\n   *\n   * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n   * // => true\n   *\n   * _.includes('pebbles', 'eb');\n   * // => true\n   */\n  function includes(collection, value, fromIndex, guard) {\n    collection = isArrayLike(collection) ? collection : values(collection);\n    fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n    var length = collection.length;\n    if (fromIndex < 0) {\n      fromIndex = nativeMax(length + fromIndex, 0);\n    }\n    return isString(collection)\n      ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n      : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function() {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result);\n      return result;\n    };\n    memoized.cache = new (memoize.Cache || MapCache);\n    return memoized;\n  }\n\n  // Assign cache to `_.memoize`.\n  memoize.Cache = MapCache;\n\n  /**\n   * Creates a function that invokes `func` with the `this` binding of the\n   * created function and arguments from `start` and beyond provided as\n   * an array.\n   *\n   * **Note:** This method is based on the\n   * [rest parameter](https://mdn.io/rest_parameters).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Function\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @returns {Function} Returns the new function.\n   * @example\n   *\n   * var say = _.rest(function(what, names) {\n   *   return what + ' ' + _.initial(names).join(', ') +\n   *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n   * });\n   *\n   * say('hello', 'fred', 'barney', 'pebbles');\n   * // => 'hello fred, barney, & pebbles'\n   */\n  function rest(func, start) {\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);\n    return function() {\n      var args = arguments,\n          index = -1,\n          length = nativeMax(args.length - start, 0),\n          array = Array(length);\n\n      while (++index < length) {\n        array[index] = args[start + index];\n      }\n      switch (start) {\n        case 0: return func.call(this, array);\n        case 1: return func.call(this, args[0], array);\n        case 2: return func.call(this, args[0], args[1], array);\n      }\n      var otherArgs = Array(start + 1);\n      index = -1;\n      while (++index < start) {\n        otherArgs[index] = args[index];\n      }\n      otherArgs[start] = array;\n      return apply(func, this, otherArgs);\n    };\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'user': 'fred' };\n   * var other = { 'user': 'fred' };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n  function eq(value, other) {\n    return value === other || (value !== value && other !== other);\n  }\n\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n  function isArguments(value) {\n    // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.\n    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n      (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n  }\n\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @type {Function}\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n  var isArray = Array.isArray;\n\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n  function isArrayLike(value) {\n    return value != null && isLength(getLength(value)) && !isFunction(value);\n  }\n\n  /**\n   * This method is like `_.isArrayLike` except that it also checks if `value`\n   * is an object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array-like object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArrayLikeObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLikeObject(document.body.children);\n   * // => true\n   *\n   * _.isArrayLikeObject('abc');\n   * // => false\n   *\n   * _.isArrayLikeObject(_.noop);\n   * // => false\n   */\n  function isArrayLikeObject(value) {\n    return isObjectLike(value) && isArrayLike(value);\n  }\n\n  /**\n   * Checks if `value` is a buffer.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n   * @example\n   *\n   * _.isBuffer(new Buffer(2));\n   * // => true\n   *\n   * _.isBuffer(new Uint8Array(2));\n   * // => false\n   */\n  var isBuffer = !Buffer ? stubFalse : function(value) {\n    return value instanceof Buffer;\n  };\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n  function isFunction(value) {\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 8 which returns 'object' for typed array and weak map constructors,\n    // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n    var tag = isObject(value) ? objectToString.call(value) : '';\n    return tag == funcTag || tag == genTag;\n  }\n\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This function is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length,\n   *  else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n  function isLength(value) {\n    return typeof value == 'number' &&\n      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n  }\n\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n  function isObject(value) {\n    var type = typeof value;\n    return !!value && (type == 'object' || type == 'function');\n  }\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return !!value && typeof value == 'object';\n  }\n\n  /**\n   * Checks if `value` is a plain object, that is, an object created by the\n   * `Object` constructor or one with a `[[Prototype]]` of `null`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.8.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a plain object,\n   *  else `false`.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * _.isPlainObject(new Foo);\n   * // => false\n   *\n   * _.isPlainObject([1, 2, 3]);\n   * // => false\n   *\n   * _.isPlainObject({ 'x': 0, 'y': 0 });\n   * // => true\n   *\n   * _.isPlainObject(Object.create(null));\n   * // => true\n   */\n  function isPlainObject(value) {\n    if (!isObjectLike(value) ||\n        objectToString.call(value) != objectTag || isHostObject(value)) {\n      return false;\n    }\n    var proto = getPrototype(value);\n    if (proto === null) {\n      return true;\n    }\n    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n    return (typeof Ctor == 'function' &&\n      Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n  }\n\n  /**\n   * Checks if `value` is classified as a `String` primitive or object.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isString('abc');\n   * // => true\n   *\n   * _.isString(1);\n   * // => false\n   */\n  function isString(value) {\n    return typeof value == 'string' ||\n      (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n  }\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol(value) {\n    return typeof value == 'symbol' ||\n      (isObjectLike(value) && objectToString.call(value) == symbolTag);\n  }\n\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n  function isTypedArray(value) {\n    return isObjectLike(value) &&\n      isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n  }\n\n  /**\n   * Checks if `value` is `undefined`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n   * @example\n   *\n   * _.isUndefined(void 0);\n   * // => true\n   *\n   * _.isUndefined(null);\n   * // => false\n   */\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  /**\n   * Converts `value` to an array.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {Array} Returns the converted array.\n   * @example\n   *\n   * _.toArray({ 'a': 1, 'b': 2 });\n   * // => [1, 2]\n   *\n   * _.toArray('abc');\n   * // => ['a', 'b', 'c']\n   *\n   * _.toArray(1);\n   * // => []\n   *\n   * _.toArray(null);\n   * // => []\n   */\n  function toArray(value) {\n    if (!value) {\n      return [];\n    }\n    if (isArrayLike(value)) {\n      return isString(value) ? stringToArray(value) : copyArray(value);\n    }\n    if (iteratorSymbol && value[iteratorSymbol]) {\n      return iteratorToArray(value[iteratorSymbol]());\n    }\n    var tag = getTag(value),\n        func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n    return func(value);\n  }\n\n  /**\n   * Converts `value` to a finite number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.12.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted number.\n   * @example\n   *\n   * _.toFinite(3.2);\n   * // => 3.2\n   *\n   * _.toFinite(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toFinite(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toFinite('3.2');\n   * // => 3.2\n   */\n  function toFinite(value) {\n    if (!value) {\n      return value === 0 ? value : 0;\n    }\n    value = toNumber(value);\n    if (value === INFINITY || value === -INFINITY) {\n      var sign = (value < 0 ? -1 : 1);\n      return sign * MAX_INTEGER;\n    }\n    return value === value ? value : 0;\n  }\n\n  /**\n   * Converts `value` to an integer.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted integer.\n   * @example\n   *\n   * _.toInteger(3.2);\n   * // => 3\n   *\n   * _.toInteger(Number.MIN_VALUE);\n   * // => 0\n   *\n   * _.toInteger(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toInteger('3.2');\n   * // => 3\n   */\n  function toInteger(value) {\n    var result = toFinite(value),\n        remainder = result % 1;\n\n    return result === result ? (remainder ? result - remainder : result) : 0;\n  }\n\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value;\n    }\n    if (isSymbol(value)) {\n      return NAN;\n    }\n    if (isObject(value)) {\n      var other = isFunction(value.valueOf) ? value.valueOf() : value;\n      value = isObject(other) ? (other + '') : other;\n    }\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value;\n    }\n    value = value.replace(reTrim, '');\n    var isBinary = reIsBinary.test(value);\n    return (isBinary || reIsOctal.test(value))\n      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n      : (reIsBadHex.test(value) ? NAN : +value);\n  }\n\n  /**\n   * Converts `value` to a plain object flattening inherited enumerable string\n   * keyed properties of `value` to own properties of the plain object.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {Object} Returns the converted plain object.\n   * @example\n   *\n   * function Foo() {\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.assign({ 'a': 1 }, new Foo);\n   * // => { 'a': 1, 'b': 2 }\n   *\n   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n   * // => { 'a': 1, 'b': 2, 'c': 3 }\n   */\n  function toPlainObject(value) {\n    return copyObject(value, keysIn(value));\n  }\n\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n  function toString(value) {\n    return value == null ? '' : baseToString(value);\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is used in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path);\n    return result === undefined ? defaultValue : result;\n  }\n\n  /**\n   * Checks if `path` is a direct or inherited property of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.hasIn(object, 'a');\n   * // => true\n   *\n   * _.hasIn(object, 'a.b');\n   * // => true\n   *\n   * _.hasIn(object, ['a', 'b']);\n   * // => true\n   *\n   * _.hasIn(object, 'b');\n   * // => false\n   */\n  function hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n  }\n\n  /**\n   * Creates an array of the own enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects. See the\n   * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n   * for more details.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keys(new Foo);\n   * // => ['a', 'b'] (iteration order is not guaranteed)\n   *\n   * _.keys('hi');\n   * // => ['0', '1']\n   */\n  function keys(object) {\n    var isProto = isPrototype(object);\n    if (!(isProto || isArrayLike(object))) {\n      return baseKeys(object);\n    }\n    var indexes = indexKeys(object),\n        skipIndexes = !!indexes,\n        result = indexes || [],\n        length = result.length;\n\n    for (var key in object) {\n      if (baseHas(object, key) &&\n          !(skipIndexes && (key == 'length' || isIndex(key, length))) &&\n          !(isProto && key == 'constructor')) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Creates an array of the own and inherited enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keysIn(new Foo);\n   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n   */\n  function keysIn(object) {\n    var index = -1,\n        isProto = isPrototype(object),\n        props = baseKeysIn(object),\n        propsLength = props.length,\n        indexes = indexKeys(object),\n        skipIndexes = !!indexes,\n        result = indexes || [],\n        length = result.length;\n\n    while (++index < propsLength) {\n      var key = props[index];\n      if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&\n          !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * This method is like `_.assign` except that it recursively merges own and\n   * inherited enumerable string keyed properties of source objects into the\n   * destination object. Source properties that resolve to `undefined` are\n   * skipped if a destination value exists. Array and plain object properties\n   * are merged recursively. Other objects and value types are overridden by\n   * assignment. Source objects are applied from left to right. Subsequent\n   * sources overwrite property assignments of previous sources.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.5.0\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * var users = {\n   *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n   * };\n   *\n   * var ages = {\n   *   'data': [{ 'age': 36 }, { 'age': 40 }]\n   * };\n   *\n   * _.merge(users, ages);\n   * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n   */\n  var merge = createAssigner(function(object, source, srcIndex) {\n    baseMerge(object, source, srcIndex);\n  });\n\n  /**\n   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n   * it's created. Arrays are created for missing index properties while objects\n   * are created for all other missing properties. Use `_.setWith` to customize\n   * `path` creation.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.set(object, 'a[0].b.c', 4);\n   * console.log(object.a[0].b.c);\n   * // => 4\n   *\n   * _.set(object, ['x', '0', 'y', 'z'], 5);\n   * console.log(object.x[0].y.z);\n   * // => 5\n   */\n  function set(object, path, value) {\n    return object == null ? object : baseSet(object, path, value);\n  }\n\n  /**\n   * Creates an array of the own enumerable string keyed property values of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property values.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.values(new Foo);\n   * // => [1, 2] (iteration order is not guaranteed)\n   *\n   * _.values('hi');\n   * // => ['h', 'i']\n   */\n  function values(object) {\n    return object ? baseValues(object, keys(object)) : [];\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * This method returns the first argument given to it.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'user': 'fred' };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n  function identity(value) {\n    return value;\n  }\n\n  /**\n   * Creates a function that invokes `func` with the arguments of the created\n   * function. If `func` is a property name, the created function returns the\n   * property value for a given element. If `func` is an array or object, the\n   * created function returns `true` for elements that contain the equivalent\n   * source properties, otherwise it returns `false`.\n   *\n   * @static\n   * @since 4.0.0\n   * @memberOf _\n   * @category Util\n   * @param {*} [func=_.identity] The value to convert to a callback.\n   * @returns {Function} Returns the callback.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': true },\n   *   { 'user': 'fred',   'age': 40, 'active': false }\n   * ];\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n   * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.filter(users, _.iteratee(['user', 'fred']));\n   * // => [{ 'user': 'fred', 'age': 40 }]\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.map(users, _.iteratee('user'));\n   * // => ['barney', 'fred']\n   *\n   * // Create custom iteratee shorthands.\n   * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n   *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n   *     return func.test(string);\n   *   };\n   * });\n   *\n   * _.filter(['abc', 'def'], /ef/);\n   * // => ['def']\n   */\n  function iteratee(func) {\n    return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));\n  }\n\n  /**\n   * A method that returns `undefined`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.3.0\n   * @category Util\n   * @example\n   *\n   * _.times(2, _.noop);\n   * // => [undefined, undefined]\n   */\n  function noop() {\n    // No operation performed.\n  }\n\n  /**\n   * Creates a function that returns the value at `path` of a given object.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   * @example\n   *\n   * var objects = [\n   *   { 'a': { 'b': 2 } },\n   *   { 'a': { 'b': 1 } }\n   * ];\n   *\n   * _.map(objects, _.property('a.b'));\n   * // => [2, 1]\n   *\n   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n   * // => [1, 2]\n   */\n  function property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n  }\n\n  /**\n   * A method that returns a new empty array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {Array} Returns the new empty array.\n   * @example\n   *\n   * var arrays = _.times(2, _.stubArray);\n   *\n   * console.log(arrays);\n   * // => [[], []]\n   *\n   * console.log(arrays[0] === arrays[1]);\n   * // => false\n   */\n  function stubArray() {\n    return [];\n  }\n\n  /**\n   * A method that returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n  function stubFalse() {\n    return false;\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  // Add methods that return wrapped values in chain sequences.\n  lodash.iteratee = iteratee;\n  lodash.keys = keys;\n  lodash.keysIn = keysIn;\n  lodash.memoize = memoize;\n  lodash.merge = merge;\n  lodash.property = property;\n  lodash.rest = rest;\n  lodash.set = set;\n  lodash.toArray = toArray;\n  lodash.toPlainObject = toPlainObject;\n  lodash.union = union;\n  lodash.values = values;\n\n  /*------------------------------------------------------------------------*/\n\n  // Add methods that return unwrapped values in chain sequences.\n  lodash.eq = eq;\n  lodash.forEach = forEach;\n  lodash.get = get;\n  lodash.hasIn = hasIn;\n  lodash.identity = identity;\n  lodash.includes = includes;\n  lodash.isArguments = isArguments;\n  lodash.isArray = isArray;\n  lodash.isArrayLike = isArrayLike;\n  lodash.isArrayLikeObject = isArrayLikeObject;\n  lodash.isBuffer = isBuffer;\n  lodash.isFunction = isFunction;\n  lodash.isLength = isLength;\n  lodash.isObject = isObject;\n  lodash.isObjectLike = isObjectLike;\n  lodash.isPlainObject = isPlainObject;\n  lodash.isString = isString;\n  lodash.isSymbol = isSymbol;\n  lodash.isTypedArray = isTypedArray;\n  lodash.isUndefined = isUndefined;\n  lodash.stubArray = stubArray;\n  lodash.stubFalse = stubFalse;\n  lodash.noop = noop;\n  lodash.toFinite = toFinite;\n  lodash.toInteger = toInteger;\n  lodash.toNumber = toNumber;\n  lodash.toString = toString;\n\n  // Add aliases.\n  lodash.each = forEach;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * The semantic version number.\n   *\n   * @static\n   * @memberOf _\n   * @type {string}\n   */\n  lodash.VERSION = VERSION;\n\n  /*--------------------------------------------------------------------------*/\n\n  if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = lodash)._ = lodash;\n    // Export for CommonJS support.\n    freeExports._ = lodash;\n  }\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/snippet.js":"\"use strict\";\n\nvar connectUtils = require(\"./connect-utils\");\nvar config       = require(\"./config\");\n\nvar lrSnippet    = require(\"resp-modifier\");\nvar path         = require(\"path\");\nvar _            = require(\"../lodash.custom\");\nvar utils        = require(\"./utils\");\nvar fs           = require(\"fs\");\n\n/**\n * Utils for snippet injection\n */\nvar snippetUtils = {\n    /**\n     * @param {String} url\n     * @param {Array} excludeList\n     * @returns {boolean}\n     */\n    isExcluded: function (url, excludeList) {\n\n        var extension = path.extname(url);\n\n        if (extension) {\n\n            if (~url.indexOf(\"?\")) {\n                return true;\n            }\n            extension = extension.slice(1);\n            return _.includes(excludeList, extension);\n        }\n        return false;\n    },\n    /**\n     * @param {String} snippet\n     * @param {Object} options\n     * @returns {{match: RegExp, fn: Function}}\n     */\n    getRegex: function (snippet, options) {\n\n        var fn = options.getIn([\"rule\", \"fn\"]);\n\n        return {\n            match: options.getIn([\"rule\", \"match\"]),\n            fn: function (req, res, match) {\n                return fn.apply(null, [snippet, match]);\n            },\n            once: true,\n            id: \"bs-snippet\"\n        };\n    },\n    getSnippetMiddleware: function (snippet, options, rewriteRules) {\n        return lrSnippet.create(snippetUtils.getRules(snippet, options, rewriteRules));\n    },\n    getRules: function (snippet, options, rewriteRules) {\n\n        var rules = [snippetUtils.getRegex(snippet, options)];\n\n        if (rewriteRules) {\n            rules = rules.concat(rewriteRules);\n        }\n\n        return {\n            rules: rules,\n            blacklist: utils.arrayify(options.get(\"blacklist\")),\n            whitelist: utils.arrayify(options.get(\"whitelist\"))\n        };\n    },\n    /**\n     * @param {Object} req\n     * @param {Array} [excludeList]\n     * @returns {Object}\n     */\n    isOldIe: function (excludeList) {\n        return function (req, res, next) {\n            var ua = req.headers[\"user-agent\"];\n            var match = /MSIE (\\d)\\.\\d/.exec(ua);\n            if (match) {\n                if (parseInt(match[1], 10) < 9) {\n                    if (!snippetUtils.isExcluded(req.url, excludeList)) {\n                        req.headers[\"accept\"] = \"text/html\";\n                    }\n                }\n            }\n            next();\n        }\n    },\n    /**\n     * @param {Number} port\n     * @param {BrowserSync.options} options\n     * @returns {String}\n     */\n    getClientJs: function (port, options) {\n        var socket = snippetUtils.getSocketScript();\n        var noConflictJs = \"window.___browserSync___oldSocketIo = window.io;\";\n        return noConflictJs + socket + \";\" + connectUtils.socketConnector(options);\n    },\n    /**\n     * @returns {String}\n     */\n    getSocketScript: function () {\n        return fs.readFileSync(path.join(__dirname, config.socketIoScript), \"utf-8\");\n    }\n};\nmodule.exports.utils = snippetUtils;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/connect-utils.js":"\"use strict\";\n\nvar _             = require(\"../lodash.custom\");\nvar fs            = require(\"fs\");\nvar config        = require(\"./config\");\n\nfunction getPath(options, relative, port) {\n    if (options.get(\"mode\") === \"snippet\") {\n        return options.get(\"scheme\") + \"://HOST:\" + port + relative;\n    } else {\n        return \"//HOST:\" + port + relative;\n    }\n}\n\nvar connectUtils = {\n    /**\n     * @param {Immutable.Map} options\n     * @returns {String}\n     */\n    scriptTags: function (options) {\n\n        var scriptPath     = this.clientScript(options);\n        var async          = options.getIn([\"snippetOptions\", \"async\"]);\n        var scriptDomain   = options.getIn([\"script\", \"domain\"]);\n\n        /**\n         * Generate the [src] attribute based on user options\n         */\n        var scriptSrc = (function () {\n\n            if (options.get(\"localOnly\")) {\n                return [\n                    options.get(\"scheme\"),\n                    \"://localhost:\",\n                    options.get(\"port\"),\n                    scriptPath\n                ].join(\"\");\n            }\n\n            /**\n             * First, was \"scriptPath\" set? if so the user wanted full control over the\n             * script tag output\n             *\n             */\n            if (_.isFunction(options.get(\"scriptPath\"))) {\n                return options.get(\"scriptPath\").apply(null, getScriptArgs(options, scriptPath));\n            }\n\n            /**\n             * Next, if \"script.domain\" was given, allow that + the path to the JS file\n             * eg:\n             *  script.domain=localhost:3000\n             * -> localhost:3000/browser-sync/browser-sync-client.js\n             */\n            if (scriptDomain) {\n                if (_.isFunction(scriptDomain)) {\n                    return scriptDomain.call(null, options) + scriptPath;\n                }\n                if (scriptDomain.match(/\\{port\\}/)) {\n                    return scriptDomain.replace(\"{port}\", options.get(\"port\")) + scriptPath;\n                }\n                return scriptDomain + scriptPath;\n            }\n\n            /**\n             * Now if server or proxy, use dynamic script\n             * eg:\n             *  browser-sync start --server\n             * ->\n             *  \"HOST:3000/browser-sync/browser-sync-client.js\".replace(\"HOST\", location.hostname)\n             */\n            if (options.get(\"server\") || options.get(\"proxy\")) {\n                return scriptPath;\n            }\n\n            /**\n             * Final use case is snippet mode\n             * -> \"http://HOST:3000/browser-sync/browser-sync-client.js\".replace(\"HOST\", location.hostname)\n             * -> \"//HOST:3000/browser-sync/browser-sync-client.js\".replace(\"HOST\", location.hostname)\"\n             */\n            return getPath(options, scriptPath, options.get(\"port\"));\n        })();\n\n        /**\n         * Decide which template shall be used to generate the script tags\n         */\n        var template = (function () {\n            if (scriptDomain || options.get(\"localOnly\")) {\n                return config.templates.scriptTagSimple;\n            }\n            return config.templates.scriptTag;\n        })();\n\n        /**\n         * Finally read the template file from disk and replace\n         * the dynamic values.\n         */\n        return fs.readFileSync(template, \"utf8\")\n            .replace(\"%script%\", scriptSrc)\n            .replace(\"%async%\", async ? \"async\" : \"\");\n    },\n    /**\n     * @param {Map} options\n     * @returns {String}\n     */\n    socketConnector: function (options) {\n\n        var socket        = options.get(\"socket\");\n        var template      = fs.readFileSync(config.templates.connector, \"utf-8\");\n        var url           = connectUtils.getConnectionUrl(options);\n\n        /**\n         * ***Backwards compatibility***. While `socket.path` is technically a\n         * socketIoClientConfig property, it's been documented previously\n         * as a top-level option, so must stay.\n         */\n        var clientConfig  = socket\n            .get(\"socketIoClientConfig\")\n            .merge({\n                path: socket.get(\"path\")\n            });\n\n        template = template\n            .replace(\"%config%\", JSON.stringify(clientConfig.toJS()))\n            .replace(\"%url%\",  url);\n\n        return template;\n    },\n    /**\n     * @param {Object} socketOpts\n     * @param {Map} options\n     * @returns {String|Function}\n     */\n    getNamespace: function (socketOpts, options) {\n\n        var namespace = socketOpts.namespace;\n\n        if (typeof namespace === \"function\") {\n            return namespace(options);\n        }\n\n        if (!namespace.match(/^\\//)) {\n            namespace = \"/\" + namespace;\n        }\n\n        return namespace;\n    },\n    /**\n     * @param {Map} options\n     * @returns {string}\n     */\n    getConnectionUrl: function (options) {\n\n        var socketOpts       = options.get(\"socket\").toJS();\n        var namespace        = connectUtils.getNamespace(socketOpts, options);\n\n        var protocol         = \"\";\n        var withHostnamePort = \"'{protocol}' + location.hostname + ':{port}{ns}'\";\n        var withHost         = \"'{protocol}' + location.host + '{ns}'\";\n        var withDomain       = \"'{domain}{ns}'\";\n        var port             = options.get(\"port\");\n\n        // default use-case is server/proxy\n        var string           = withHost;\n\n        if (options.get(\"mode\") !== \"server\") {\n            protocol = options.get(\"scheme\") + \"://\";\n            string   = withHostnamePort;\n        }\n\n        if (options.get(\"mode\") === \"proxy\" && options.getIn([\"proxy\", \"ws\"])) {\n            port = options.getIn([\"socket\", \"port\"]);\n        }\n\n        /**\n         * Ensure socket.domain is always a string (for noop replacements later)\n         */\n        socketOpts.domain = (function () {\n            if (options.get(\"localOnly\")) {\n                string = withDomain;\n                return [\n                    options.get(\"scheme\"),\n                    \"://localhost:\",\n                    options.get(\"port\")\n                ].join(\"\");\n            }\n            if (socketOpts.domain) {\n                string = withDomain;\n                /**\n                 * User provided a function\n                 */\n                if (_.isFunction(socketOpts.domain)) {\n                    return socketOpts.domain.call(null, options);\n                }\n                /**\n                 * User provided a string\n                 */\n                if (_.isString(socketOpts.domain)) {\n                    return socketOpts.domain;\n                }\n            }\n            return \"\";\n        })();\n\n        return string\n            .replace(\"{protocol}\", protocol)\n            .replace(\"{port}\",     port)\n            .replace(\"{domain}\",   socketOpts.domain.replace(\"{port}\", port))\n            .replace(\"{ns}\",       namespace);\n    },\n    /**\n     * @param {Object} [options]\n     * @param {Boolean} [both]\n     */\n    clientScript: function (options, both) {\n\n        var prefix    = options.getIn([\"socket\", \"clientPath\"]);\n        var script    = prefix + \"/browser-sync-client.js\";\n        var versioned = prefix + \"/browser-sync-client.js?v=\" + options.get(\"version\");\n\n        if (both) {\n            return {\n                path: script,\n                versioned: versioned\n            };\n        }\n\n        return versioned;\n    }\n};\n\n/**\n * @param options\n * @returns {*[]}\n */\nfunction getScriptArgs (options, scriptPath) {\n    var abspath = options.get(\"scheme\") + \"://HOST:\" + options.get(\"port\") + scriptPath;\n    return [\n        scriptPath,\n        options.get(\"port\"),\n        options.set(\"absolute\", abspath)\n    ];\n}\n\nmodule.exports = connectUtils;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/config.js":"\"use strict\";\n\nvar path = require(\"path\");\n/**\n * @type {{controlPanel: {jsFile: string, baseDir: *}, socketIoScript: string, configFile: string, client: {shims: string}}}\n */\nmodule.exports = {\n    controlPanel: {\n        jsFile: \"/js/app.js\",\n        baseDir: path.join(__dirname, \"control-panel\")\n    },\n    templates: {\n        scriptTag: path.join(__dirname, \"templates/script-tags.tmpl\"),\n        scriptTagSimple: path.join(__dirname, \"templates/script-tags-simple.tmpl\"),\n        connector: path.join(__dirname, \"templates/connector.tmpl\")\n    },\n    socketIoScript: \"/public/socket.io.min.1.6.0.js\",\n    configFile: \"default-config.js\",\n    userFile: \"bs-config.js\",\n    template: \"cli-template.js\",\n    httpProtocol: {\n        path: \"/__browser_sync__\"\n    },\n    client: {\n        shims: \"/client/client-shims.js\"\n    },\n    errors: {\n        \"server+proxy\": \"Invalid config. You cannot specify both server & proxy options.\",\n        \"proxy+https\":  \"Invalid config. You set https: true, but your proxy target doesn't reflect this.\"\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/utils.js":"\"use strict\";\n\nvar _             = require(\"../lodash.custom\");\nvar devIp         = require(\"dev-ip\")();\nvar Immutable     = require(\"immutable\");\nvar portScanner   = require(\"portscanner\");\nvar path          = require(\"path\");\nvar List          = require(\"immutable\").List;\nvar UAParser      = require(\"ua-parser-js\");\nvar parser        = new UAParser();\n\nvar utils = {\n    /**\n     * @param {Object} options\n     * @returns {String|boolean} - the IP address\n     * @param devIp\n     */\n    getHostIp: function (options, devIp) {\n\n        if (options) {\n            var host = options.get(\"host\");\n            if (host && host !== \"localhost\") {\n                return host;\n            }\n            if (options.get(\"detect\") === false || !devIp.length) {\n                return false;\n            }\n        }\n\n        return devIp.length ? devIp[0] : false;\n    },\n    /**\n     * Set URL Options\n     */\n    getUrlOptions: function (options) {\n\n        var scheme = options.get(\"scheme\");\n\n        var port   = options.get(\"port\");\n        var urls   = {};\n\n        if (options.get(\"online\") === false) {\n            urls.local = utils.getUrl(scheme + \"://localhost:\" + port, options);\n            return Immutable.fromJS(urls);\n        }\n\n        var external  = utils.xip(utils.getHostIp(options, devIp), options);\n        var localhost = \"localhost\";\n\n        if (options.get(\"xip\")) {\n            localhost = \"127.0.0.1\";\n        }\n\n        localhost = utils.xip(localhost, options);\n\n        return Immutable.fromJS(utils.getUrls(external, localhost, scheme, options));\n    },\n    /**\n     * Append a start path if given in options\n     * @param {String} url\n     * @param {Object} options\n     * @returns {String}\n     */\n    getUrl: function (url, options) {\n\n        var prefix = \"/\";\n        var startPath = options.get(\"startPath\");\n\n        if (startPath) {\n            if (startPath.charAt(0) === \"/\") {\n                prefix = \"\";\n            }\n            url = url + prefix + startPath;\n        }\n\n        return url;\n    },\n    /**\n     * @param {String} external\n     * @param {String} local\n     * @param {String} scheme\n     * @param {Object} options\n     * @returns {{local: string, external: string}}\n     */\n    getUrls: function (external, local, scheme, options) {\n\n        var urls = {\n            local: utils.getUrl(utils._makeUrl(scheme, local, options.get(\"port\")), options)\n        };\n\n        if (external !== local) {\n            urls.external = utils.getUrl(utils._makeUrl(scheme, external, options.get(\"port\")), options);\n        }\n\n        return urls;\n    },\n    /**\n     * @param {String} scheme\n     * @param {String} host\n     * @param {Number} port\n     * @returns {String}\n     * @private\n     */\n    _makeUrl: function (scheme, host, port) {\n        return scheme + \"://\" + host + \":\" + port;\n    },\n    /**\n     * Get ports\n     * @param {Object} options\n     * @param {Function} cb\n     */\n    getPorts: function (options, cb) {\n\n        var port  = options.get(\"port\");\n        var ports = options.get(\"ports\"); // backwards compatibility\n        var max;\n\n        if (ports) {\n            port = ports.get(\"min\");\n            max  = ports.get(\"max\") || null;\n        }\n\n        utils.getPort(port, max, cb);\n    },\n    getPort: function (port, max, cb) {\n        portScanner.findAPortNotInUse(port, max, {\n            host: \"localhost\",\n            timeout: 1000\n        }, cb);\n    },\n    /**\n     * @param {String} ua\n     * @returns {Object}\n     */\n    getUaString: function (ua) {\n        return parser.setUA(ua).getBrowser();\n    },\n    /**\n     * Open the page in browser\n     * @param {String} url\n     * @param {Object} options\n     * @param {BrowserSync} bs\n     */\n    openBrowser: function (url, options, bs) {\n\n        var open    = options.get(\"open\");\n        var browser = options.get(\"browser\");\n\n        if (_.isString(open)) {\n            if (options.getIn([\"urls\", open])) {\n                url = options.getIn([\"urls\", open]);\n            }\n        }\n\n        if (open) {\n            if (browser !== \"default\") {\n                if (utils.isList(browser)) {\n                    browser.forEach(function (browser) {\n                        utils.open(url, browser, bs);\n                    });\n                } else {\n                    utils.open(url, browser, bs); // single\n                }\n            } else {\n                utils.open(url, null, bs);\n            }\n        }\n    },\n    /**\n     * Wrapper for opn module\n     * @param url\n     * @param name\n     * @param bs\n     */\n    open: function (url, name, bs) {\n        var options = (function () {\n            if (_.isString(name)) {\n                return {app: name};\n            }\n            if (Immutable.Map.isMap(name)) {\n                return name.toJS();\n            }\n            return {};\n        })();\n        var opn = require(\"opn\");\n        opn(url, options).catch(function() {\n            bs.events.emit(\"browser:error\");\n        });\n    },\n    /**\n     * @param {Boolean} kill\n     * @param {String|Error} [errMessage]\n     * @param {Function} [cb]\n     */\n    fail: function (kill, errMessage, cb) {\n        if (kill) {\n            if (_.isFunction(cb)) {\n                if (errMessage.message) { // Is this an error object?\n                    cb(errMessage);\n                } else {\n                    cb(new Error(errMessage));\n                }\n            }\n            process.exit(1);\n        }\n    },\n    /**\n     * Add support for xip.io urls\n     * @param {String} host\n     * @param {Object} options\n     * @returns {String}\n     */\n    xip: function (host, options) {\n        var suffix = options.get(\"hostnameSuffix\");\n        if (options.get(\"xip\")) {\n            return host + \".xip.io\";\n        }\n        if (suffix) {\n            return host + suffix;\n        }\n        return host;\n    },\n    /**\n     * Determine if an array of file paths will cause a full page reload.\n     * @param {Array} needles - filepath such as [\"core.css\", \"index.html\"]\n     * @param {Array} haystack\n     * @returns {Boolean}\n     */\n    willCauseReload: function (needles, haystack) {\n        return needles.some(function (needle) {\n            return !_.includes(haystack, path.extname(needle).replace(\".\", \"\"));\n        });\n    },\n    isList: Immutable.List.isList,\n    isMap: Immutable.List.isMap,\n    /**\n     * @param {Map} options\n     * @returns {Array}\n     */\n    getConfigErrors: function (options) {\n\n        var messages = require(\"./config\").errors;\n\n        var errors = [];\n\n        if (options.get(\"server\") && options.get(\"proxy\")) {\n            errors.push(messages[\"server+proxy\"]);\n        }\n\n        return errors;\n    },\n    /**\n     * @param {Map} options\n     * @param {Function} [cb]\n     */\n    verifyConfig: function (options, cb) {\n        var errors = utils.getConfigErrors(options);\n        if (errors.length) {\n            utils.fail(true, errors.join(\"\\n\"), cb);\n            return false;\n        }\n        return true;\n    },\n    /**\n     * @param err\n     */\n    defaultCallback: function (err) {\n        if (err && err.message) {\n            console.error(err.message);\n        }\n    },\n    eachSeries: function (arr, iterator, callback) {\n        callback = callback || function () {};\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                } else {\n                    ++completed;\n                    if (completed >= arr.length) {\n                        callback();\n                    } else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    },\n    /**\n     * @param {Immutable.List|Array|String} incoming\n     * @returns {Array}\n     */\n    arrayify: function (incoming) {\n        if (List.isList(incoming)) {\n            return incoming.toArray();\n        }\n        return [].concat(incoming).filter(Boolean);\n    }\n};\n\nmodule.exports              = utils;\nmodule.exports.portscanner  = portScanner;\nmodule.exports.UAParser     = UAParser;\nmodule.exports.connect      = require(\"connect\");\nmodule.exports.devIp        = devIp;\nmodule.exports.serveStatic  = require(\"serve-static\");\nmodule.exports.easyExtender = require(\"easy-extender\");\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/async-tasks.js":"var async           = require(\"./async\");\n\nmodule.exports = [\n    {\n        step: \"Finding an empty port\",\n        fn: async.getEmptyPort\n    },\n    {\n        step: \"Getting an extra port for Proxy\",\n        fn: async.getExtraPortForProxy\n    },\n    {\n        step: \"Checking online status\",\n        fn: async.getOnlineStatus\n    },\n    {\n        step: \"Resolve user plugins from options\",\n        fn: async.resolveInlineUserPlugins\n    },\n    {\n        step: \"Set Urls and other options that rely on port/online status\",\n        fn: async.setOptions\n    },\n    {\n        step: \"Setting Internal Events\",\n        fn: async.setInternalEvents\n    },\n    {\n        step: \"Setting file watchers\",\n        fn: async.setFileWatchers\n    },\n    {\n        step: \"Merging middlewares from core + plugins\",\n        fn: async.mergeMiddlewares\n    },\n    {\n        step: \"Starting the Server\",\n        fn: async.startServer\n    },\n    {\n        step: \"Starting the HTTPS Tunnel\",\n        fn: async.startTunnel\n    },\n    {\n        step: \"Starting the web-socket server\",\n        fn: async.startSockets\n    },\n    {\n        step: \"Starting the UI\",\n        fn: async.startUi\n    },\n    {\n        step: \"Merge UI settings\",\n        fn: async.mergeUiSettings\n    },\n    {\n        step: \"Init user plugins\",\n        fn: async.initUserPlugins\n    }\n];\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/async.js":"\"use strict\";\n\nvar _            = require(\"../lodash.custom\");\nvar Immutable    = require(\"immutable\");\n\nvar utils        = require(\"./utils\");\nvar pluginUtils  = require(\"./plugins\");\nvar connectUtils = require(\"./connect-utils\");\n\nmodule.exports = {\n    /**\n     * BrowserSync needs at least 1 free port.\n     * It will check the one provided in config\n     * and keep incrementing until an available one is found.\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    getEmptyPort: function (bs, done) {\n        utils.getPorts(bs.options, function (err, port) {\n            if (err) {\n                return utils.fail(true, err, bs.cb);\n            }\n            bs.debug(\"Found a free port: {magenta:%s\", port);\n            done(null, {\n                options: {\n                    port: port\n                }\n            });\n        });\n    },\n    /**\n     * If the running mode is proxy, we'll use a separate port\n     * for the Browsersync web-socket server. This is to eliminate any issues\n     * with trying to proxy web sockets through to the users server.\n     * @param bs\n     * @param done\n     */\n    getExtraPortForProxy: function (bs, done) {\n        /**\n         * An extra port is not needed in snippet/server mode\n         */\n        if (bs.options.get(\"mode\") !== \"proxy\") {\n            return done();\n        }\n\n        /**\n         * Web socket support is disabled by default\n         */\n        if (!bs.options.getIn([\"proxy\", \"ws\"])) {\n            return done();\n        }\n\n        /**\n         * Use 1 higher than server port by default...\n         */\n        var socketPort = bs.options.get(\"port\") + 1;\n\n        /**\n         * Or use the user-defined socket.port option instead\n         */\n        if (bs.options.hasIn([\"socket\", \"port\"])) {\n            socketPort = bs.options.getIn([\"socket\", \"port\"]);\n        }\n\n        utils.getPort(socketPort, null, function (err, port) {\n            if (err) {\n                return utils.fail(true, err, bs.cb);\n            }\n            done(null, {\n                optionsIn: [\n                    {\n                        path: [\"socket\", \"port\"],\n                        value: port\n                    }\n                ]\n            });\n        });\n    },\n    /**\n     * Some features require an internet connection.\n     * If the user did not provide either `true` or `false`\n     * for the online option, we will attempt to resolve www.google.com\n     * as a way of determining network connectivity\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    getOnlineStatus: function (bs, done) {\n        if (_.isUndefined(bs.options.get(\"online\")) && _.isUndefined(process.env.TESTING)) {\n            require(\"dns\").resolve(\"www.google.com\", function (err) {\n                var online = false;\n                if (err) {\n                    bs.debug(\"Could not resolve www.google.com, setting {magenta:online: false}\");\n                } else {\n                    bs.debug(\"Resolved www.google.com, setting {magenta:online: true}\");\n                    online = true;\n                }\n                done(null, {\n                    options: {\n                        online: online\n                    }\n                });\n            });\n        } else {\n            done();\n        }\n    },\n    /**\n     * Try to load plugins that were given in options\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    resolveInlineUserPlugins: function (bs, done) {\n\n        var plugins = bs.options\n            .get(\"plugins\")\n            .map(pluginUtils.resolvePlugin)\n            .map(pluginUtils.requirePlugin);\n\n        plugins\n            .forEach(function (plugin) {\n                if (plugin.get(\"errors\").size) {\n                    return logPluginError(plugin);\n                }\n                var jsPlugin = plugin.toJS();\n                jsPlugin.options = jsPlugin.options || {};\n                jsPlugin.options.moduleName = jsPlugin.moduleName;\n                bs.registerPlugin(jsPlugin.module, jsPlugin.options);\n            });\n\n        function logPluginError (plugin) {\n            utils.fail(true, plugin.getIn([\"errors\", 0]), bs.cb);\n        }\n\n        done();\n    },\n    /**\n     *\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    setOptions: function (bs, done) {\n        done(null, {\n            options: {\n                urls:        utils.getUrlOptions(bs.options),\n                snippet:     connectUtils.scriptTags(bs.options),\n                scriptPaths: Immutable.fromJS(connectUtils.clientScript(bs.options, true)),\n                files:       bs.pluginManager.hook(\n                    \"files:watch\",\n                    bs.options.get(\"files\"),\n                    bs.pluginManager.pluginOptions\n                )\n            }\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    setInternalEvents: function (bs, done) {\n        require(\"./internal-events\")(bs);\n        done();\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    setFileWatchers: function (bs, done) {\n        done(null, {\n            instance: {\n                watchers: bs.pluginManager.get(\"file:watcher\")(bs)\n            }\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    mergeMiddlewares: function (bs, done) {\n\n        done(null, {\n            options: {\n                middleware: bs.pluginManager.hook(\n                    \"server:middleware\",\n                    bs.options.get(\"middleware\")\n                )\n            }\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    startServer: function (bs, done) {\n\n        var server = bs.pluginManager.get(\"server\")(bs);\n\n        done(null, {\n            instance: {\n                server: server.server,\n                app: server.app\n            }\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    startTunnel: function (bs, done) {\n        if (bs.options.get(\"tunnel\") && bs.options.get(\"online\")) {\n            var localTunnel = require(\"./tunnel\");\n            localTunnel(bs, function (err, tunnel) {\n                if (err) {\n                    return done(err);\n                } else {\n                    return done(null, {\n                        optionsIn: [\n                            {\n                                path:  [\"urls\", \"tunnel\"],\n                                value: tunnel.url\n                            }\n                        ],\n                        instance: {\n                            tunnel: tunnel\n                        }\n                    });\n                }\n            });\n        } else {\n            done();\n        }\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    startSockets: function (bs, done) {\n\n        var clientEvents = bs.pluginManager.hook(\n            \"client:events\",\n            bs.options.get(\"clientEvents\").toJS()\n        );\n\n        // Start the socket, needs an existing server.\n        var io = bs.pluginManager.get(\"socket\")(\n            bs.server,\n            clientEvents,\n            bs\n        );\n\n        done(null, {\n            instance: {\n                io: io\n            },\n            options: {\n                clientEvents: Immutable.fromJS(clientEvents)\n            }\n        });\n    },\n    /**\n     *\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    startUi: function (bs, done) {\n\n        var PLUGIN_NAME = \"UI\";\n        var userPlugins   = bs.getUserPlugins();\n        var ui            = bs.pluginManager.get(PLUGIN_NAME);\n        var uiOpts        = bs.options.get(\"ui\");\n\n        if (!uiOpts || uiOpts.get(\"enabled\") === false) {\n            return done();\n        }\n\n        // if user provided a UI, use it instead\n        if (userPlugins.some(function (item) {\n            return item.name === PLUGIN_NAME;\n        })) {\n            uiOpts = bs.options.get(\"ui\").mergeDeep(Immutable.fromJS(bs.pluginManager.pluginOptions[PLUGIN_NAME]));\n        }\n\n        return ui(uiOpts.toJS(), bs, function (err, ui) {\n            if (err) {\n                return done(err);\n            }\n            done(null, {\n                instance: {\n                    ui: ui\n                }\n            });\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    mergeUiSettings: function (bs, done) {\n\n        if (!bs.ui) {\n            return done();\n        }\n\n        done(null, {\n            options: {\n                urls: bs.options.get(\"urls\").merge(bs.ui.options.get(\"urls\"))\n            }\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    initUserPlugins: function (bs, done) {\n\n        bs.pluginManager.initUserPlugins(bs);\n\n        done(null, {\n            options: {\n                userPlugins: bs.getUserPlugins()\n            }\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/plugins.js":"var Immutable  = require(\"immutable\");\nvar Map        = Immutable.Map;\nvar isMap      = Immutable.Map.isMap;\nvar List       = Immutable.List;\nvar qs         = require(\"qs\");\nvar path       = require(\"path\");\nvar fs         = require(\"fs\");\n\nvar Plugin = Immutable.Record({\n    moduleName: \"\",\n    name:       \"\",\n    active:     true,\n    module:     undefined,\n    options:    Map({}),\n    via:        \"inline\",\n    dir:        process.cwd(),\n    init:       undefined,\n    errors:     List([])\n});\n\n/**\n * Accept a string/object\n * and resolve it into the plugin format above\n * @param item\n * @returns {*}\n */\nfunction resolvePlugin(item) {\n\n    /**\n     * Handle when string was given, such as plugins: ['bs-html-injector']\n     */\n    if (typeof item === \"string\") {\n        return getFromString(item);\n    }\n\n    if (!isMap(item)) {\n        return new Plugin().mergeDeep({errors: [new Error(\"Plugin not supported in this format\")]});\n    }\n\n    if (item.has(\"module\")) {\n\n        var nameOrObj = item.get(\"module\");\n        var options = item.get(\"options\");\n\n        /**\n         * The 'module' key can be a string, this allows\n         * inline plugin references, but with options\n         * eg:\n         *\n         * bs.init({\n         *     plugins: [\n         *         {\n         *             module: './myjs-file.js'\n         *             options: {\n         *                 files: \"*.html\"\n         *             }\n         *         }\n         *     ]\n         * });\n         */\n        if (typeof nameOrObj === \"string\") {\n            return getFromString(nameOrObj)\n                .mergeDeep({\n                    options: options\n                });\n        }\n\n        /**\n         * If the plugin was given completely inline (because it needs options)\n         * eg:\n         *\n         * bs.init({\n         *     plugins: [\n         *         {\n         *             module: {\n         *                 plugin: function() {\n         *                     console.log('My plugin code')\n         *                 }\n         *             },\n         *             options: {\n         *                 files: \"*.html\"\n         *             }\n         *         }\n         *     ]\n         * })\n         */\n        if (Immutable.Map.isMap(nameOrObj)) {\n            return new Plugin({\n                module: nameOrObj,\n                options: options\n            });\n        }\n    }\n\n    /**\n     * If a module was given directly. For example, ater calling require.\n     *\n     * eg:\n     *    var myplugin = require('./some-js');\n     *    bs.init({plugins: [myplugin]});\n     */\n    if (item.has(\"plugin\")) {\n        return new Plugin({\n            module: item\n        })\n    }\n\n    /**\n     * If we reach here, the plugin option was used incorrectly\n     */\n    return new Plugin().mergeDeep({errors: [new Error(\"Plugin was not configured correctly\")]})\n}\n\nmodule.exports.resolvePlugin = resolvePlugin;\n\n/**\n * Load a plugin from disk\n * @param item\n * @returns {*}\n */\nfunction requirePlugin (item) {\n\n    /**\n     * if the \"module\" property already exists and\n     * is not a string, then we bail and don't bother looking\n     * for the file\n     */\n    if (item.get(\"module\") && typeof item.get(\"module\") !== \"string\") {\n        return item;\n    }\n\n    try {\n        /**\n         * Try a raw node require() call - this will be how\n         * regular \"npm installed\" plugins wil work\n         */\n        var maybe = path.resolve(process.cwd(), \"node_modules\", item.get(\"name\"));\n        return item.set(\"module\", require(maybe));\n    } catch (e) {\n        /**\n         * If require threw an MODULE_NOT_FOUND error, try again\n         * by resolving from cwd. This is needed since cli\n         * users will not add ./ to the front of a path (which\n         * node requires to resolve from cwd)\n         */\n        if (e.code === \"MODULE_NOT_FOUND\") {\n            var maybe = path.resolve(process.cwd(), item.get(\"name\"));\n            if (fs.existsSync(maybe)) {\n                return item.set(\"module\", require(maybe));\n            } else {\n                /**\n                 * Finally return a plugin that contains the error\n                 * this will be picked up later and discarded\n                 */\n                return item.update(\"errors\", function (errors) {\n                    return errors.concat(e);\n                });\n            }\n        }\n        throw e;\n    }\n}\nmodule.exports.requirePlugin = requirePlugin;\n\nfunction getFromString(string) {\n\n    /**\n     * We allow query strings for plugins, so always split on ?\n     */\n    var split = string.split(\"?\");\n\n    var outGoing = new Plugin({\n        moduleName: split[0],\n        name: split[0]\n    });\n\n    if (split.length > 1) {\n        return outGoing.update(\"options\", function (opts) {\n            return opts.mergeDeep(qs.parse(split[1]));\n        });\n    }\n\n    return outGoing;\n}\n\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/logger.js":"\"use strict\";\n\nvar messages = require(\"./connect-utils\");\nvar utils    = require(\"./utils\");\nvar _        = require(\"../lodash.custom\");\n\nvar template = \"[{blue:%s}] \";\n\nvar logger   = require(\"eazy-logger\").Logger({\n    prefix: template.replace(\"%s\", \"BS\"),\n    useLevelPrefixes: false\n});\n\nmodule.exports.logger = logger;\n\n/**\n * @param name\n * @returns {*}\n */\nmodule.exports.getLogger = function (name) {\n    return logger.clone(function (config) {\n        config.prefix = config.prefix + template.replace(\"%s\", name);\n        return config;\n    });\n};\n\n/**\n * Logging Callbacks\n */\nmodule.exports.callbacks = {\n    /**\n     * Log when file-watching has started\n     * @param {BrowserSync} bs\n     * @param data\n     */\n    \"file:watching\": function (bs, data) {\n        if (Object.keys(data).length) {\n            logger.info(\"Watching files...\");\n        }\n    },\n    /**\n     * Log when a file changes\n     * @param {BrowserSync} bs\n     * @param data\n     */\n    \"file:reload\": function (bs, data) {\n        if (canLogFileChange(bs, data)) {\n\n            if (data.path[0] === \"*\") {\n                return logger.info(\"{cyan:Reloading files that match: {magenta:%s\", data.path);\n            }\n\n            logger.info(\"{cyan:File event [\" + data.event + \"] : {magenta:%s\", data.path);\n        }\n    },\n    /**\n     *\n     */\n    \"service:exit\": function () {\n        logger.debug(\"Exiting...\");\n    },\n    /**\n     *\n     */\n    \"browser:reload\": function (bs) {\n        if (canLogFileChange(bs)) {\n            logger.info(\"{cyan:Reloading Browsers...\");\n        }\n    },\n    /**\n     *\n     */\n    \"browser:error\": function () {\n        logger.error(\"Couldn't open browser (if you are using BrowserSync in a headless environment, you might want to set the {cyan:open} option to {cyan:false})\");\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param data\n     */\n    \"stream:changed\": function (bs, data) {\n        if (canLogFileChange(bs)) {\n            var changed = data.changed;\n\n            logger.info(\"{cyan:%s %s changed} ({magenta:%s})\",\n                changed.length,\n                changed.length > 1 ? \"files\" : \"file\",\n                changed.join(\", \")\n            );\n        }\n    },\n    /**\n     * Client connected logging\n     * @param {BrowserSync} bs\n     * @param data\n     */\n    \"client:connected\": function (bs, data) {\n\n        var uaString = utils.getUaString(data.ua);\n        var msg = \"{cyan:Browser Connected: {magenta:%s, version: %s}\";\n        var method = \"info\";\n\n        if (!bs.options.get(\"logConnections\")) {\n            method = \"debug\";\n        }\n\n        logger.log(method, msg,\n            uaString.name,\n            uaString.version\n        );\n    },\n    /**\n     * Main logging when the service is running\n     * @param {BrowserSync} bs\n     * @param data\n     */\n    \"service:running\": function (bs, data) {\n\n        var type    = data.type;\n\n        if (type === \"server\") {\n\n            var baseDir = bs.options.getIn([\"server\", \"baseDir\"]);\n\n            logUrls(bs.options.get(\"urls\").toJS());\n\n            if (baseDir) {\n                if (utils.isList(baseDir)) {\n                    baseDir.forEach(serveFiles);\n                } else {\n                    serveFiles(baseDir);\n                }\n            }\n        }\n\n        if (type === \"proxy\") {\n\n            logger.info(\"Proxying: {cyan:%s}\", bs.options.getIn([\"proxy\", \"target\"]));\n            logUrls(bs.options.get(\"urls\").toJS());\n        }\n\n        if (type === \"snippet\") {\n\n            if (bs.options.get(\"logSnippet\")) {\n\n                logger.info(\n                    \"{bold:Copy the following snippet into your website, \" +\n                    \"just before the closing {cyan:</body>} tag\"\n                );\n\n                logger.unprefixed(\"info\",\n                    messages.scriptTags(bs.options)\n                );\n            }\n\n            logUrls(bs.options.get(\"urls\").filter(function (value, key) {\n                return key.slice(0, 2) === \"ui\";\n            }).toJS());\n        }\n\n        function serveFiles (base) {\n            logger.info(\"Serving files from: {magenta:%s}\", base);\n        }\n    }\n};\n\n/**\n * Plugin interface for BrowserSync\n * @param {EventEmitter} emitter\n * @param {BrowserSync} bs\n * @returns {Object}\n */\nmodule.exports.plugin = function (emitter, bs) {\n\n    var logPrefix = bs.options.get(\"logPrefix\");\n    var logLevel  = bs.options.get(\"logLevel\");\n\n    // Should set logger level here!\n    logger.setLevel(logLevel);\n\n    if (logPrefix) {\n        if (_.isFunction(logPrefix)) {\n            logger.setPrefix(logPrefix);\n        } else {\n            logger.setPrefix(template.replace(\"%s\", logPrefix));\n        }\n    }\n\n    _.each(exports.callbacks, function (func, event) {\n        emitter.on(event, func.bind(this, bs));\n    });\n\n    return logger;\n};\n\n/**\n *\n * @param urls\n */\nfunction logUrls (urls) {\n\n    var keys = Object.keys(urls);\n    var longestName = 0;\n    var longesturl  = 0;\n    var offset      = 2;\n\n    if (!keys.length) {\n        return;\n    }\n\n    var names = keys.map(function (key) {\n        if (key.length > longestName) {\n            longestName = key.length;\n        }\n        if (urls[key].length > longesturl) {\n            longesturl = urls[key].length;\n        }\n        return key;\n    });\n\n    var underline  = getChars(longestName + offset + longesturl + 1, \"-\");\n    var underlined = false;\n\n    logger.info(\"{bold:Access URLs:\");\n    logger.unprefixed(\"info\", \"{grey: %s\", underline);\n\n    keys.forEach(function (key, i) {\n        var keyname = getKeyName(key);\n        logger.unprefixed(\"info\", \" %s: {magenta:%s}\",\n            getPadding(key.length, longestName + offset) + keyname,\n            urls[key]\n        );\n        if (!underlined && names[i + 1] && names[i + 1].indexOf(\"ui\") > -1) {\n            underlined = true;\n            logger.unprefixed(\"info\", \"{grey: %s}\", underline);\n        }\n    });\n\n    logger.unprefixed(\"info\", \"{grey: %s}\", underline);\n}\n\n/**\n * @param {Number} len\n * @param {Number} max\n * @returns {string}\n */\nfunction getPadding (len, max) {\n    return new Array(max - (len + 1)).join(\" \");\n}\n\n/**\n * @param {Number} len\n * @param {String} char\n * @returns {string}\n */\nfunction getChars (len, char) {\n    return new Array(len).join(char);\n}\n\n/**\n * Transform url-key names into something more presentable\n * @param key\n * @returns {string}\n */\nfunction getKeyName(key) {\n    if (key.indexOf(\"ui\") > -1) {\n        if (key === \"ui\") {\n            return \"UI\";\n        }\n        if (key === \"ui-external\") {\n            return \"UI External\";\n        }\n    }\n    return key.substr(0, 1).toUpperCase() + key.substring(1);\n}\n\n/**\n * Determine if file changes should be logged\n * @param bs\n * @param data\n * @returns {boolean}\n */\nfunction canLogFileChange(bs, data) {\n    if (data && data.log === false) {\n        return false;\n    }\n\n    return bs.options.get(\"logFileChanges\");\n}\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/sockets.js":"\"use strict\";\n\nvar socket  = require(\"socket.io\");\nvar utils   = require(\"./server/utils\");\nvar Steward = require(\"emitter-steward\");\n\n/**\n * Plugin interface\n * @returns {*|function(this:exports)}\n */\nmodule.exports.plugin = function (server, clientEvents, bs) {\n    return exports.init(server, clientEvents, bs);\n};\n\n/**\n * @param {http.Server} server\n * @param clientEvents\n * @param {BrowserSync} bs\n */\nmodule.exports.init = function (server, clientEvents, bs) {\n\n    var emitter      = bs.events;\n\n    var socketConfig = bs.options\n        .get(\"socket\")\n        .toJS();\n\n    if (bs.options.get(\"mode\") === \"proxy\" && bs.options.getIn([\"proxy\", \"ws\"])) {\n        server = utils.getServer(null, bs.options).server;\n        server.listen(bs.options.getIn([\"socket\", \"port\"]));\n        bs.registerCleanupTask(function () {\n            server.close();\n        });\n    }\n\n    var socketIoConfig  = socketConfig.socketIoOptions;\n    socketIoConfig.path = socketConfig.path;\n\n    var io = socket(server, socketIoConfig);\n\n    // Override default namespace.\n    io.sockets = io.of(socketConfig.namespace);\n\n    io.set(\"heartbeat interval\", socketConfig.clients.heartbeatTimeout);\n\n    var steward  = new Steward(emitter);\n    bs.registerCleanupTask(steward.destroy.bind(steward));\n\n    /**\n     * Listen for new connections\n     */\n    io.sockets.on(\"connection\", handleConnection);\n\n    /**\n     * Handle each new connection\n     * @param {Object} client\n     */\n    function handleConnection (client) {\n\n        // set ghostmode callbacks\n        if (bs.options.get(\"ghostMode\")) {\n\n            addGhostMode(client);\n        }\n\n        client.emit(\"connection\", bs.options.toJS()); //todo - trim the amount of options sent to clients\n\n        emitter.emit(\"client:connected\", {\n            ua: client.handshake.headers[\"user-agent\"]\n        });\n    }\n\n    /**\n     * @param {string} event\n     * @param {Socket.client} client\n     * @param {Object} data\n     */\n    function handleClientEvent(event, client, data) {\n\n        if (steward.valid(client.id)) {\n\n            client.broadcast.emit(event, data);\n        }\n    }\n\n    /**\n     * @param client\n     */\n    function addGhostMode (client) {\n\n        clientEvents.forEach(addEvent);\n\n        function addEvent(event) {\n\n            client.on(event, handleClientEvent.bind(null, event, client));\n        }\n    }\n\n    return io;\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/server/utils.js":"\"use strict\";\n\nvar fs           = require(\"fs\");\nvar path         = require(\"path\");\nvar join         = require(\"path\").join;\nvar connect      = require(\"connect\");\nvar Immutable    = require(\"immutable\");\nvar http         = require(\"http\");\nvar https        = require(\"https\");\nvar Map          = require(\"immutable\").Map;\nvar fromJS       = require(\"immutable\").fromJS;\nvar List         = require(\"immutable\").List;\nvar snippet      = require(\"./../snippet\").utils;\nvar _            = require(\"./../../lodash.custom\");\nvar serveStatic  = require(\"serve-static\");\nvar logger       = require(\"../logger\");\nvar snippetUtils = require(\"../snippet\").utils;\nvar lrSnippet    = require(\"resp-modifier\");\nvar utils        = require(\"../utils\");\n\nfunction getCa (options) {\n    var caOption = options.getIn([\"https\", \"ca\"]);\n    // if not provided, use Browsersync self-signed\n    if (typeof caOption === \"undefined\") {\n        return fs.readFileSync(join(__dirname, \"certs\", \"server.csr\"));\n    }\n    // if a string was given, read that file from disk\n    if (typeof caOption === \"string\") {\n        return fs.readFileSync(caOption);\n    }\n    // if an array was given, read all\n    if (List.isList(caOption)) {\n        return caOption.toArray().map(function (x) {\n            return fs.readFileSync(x);\n        });\n    }\n}\n\nfunction getKey(options) {\n    return fs.readFileSync(options.getIn([\"https\", \"key\"])  || join(__dirname, \"certs\", \"server.key\"));\n}\n\nfunction getCert(options) {\n    return fs.readFileSync(options.getIn([\"https\", \"cert\"]) || join(__dirname, \"certs\", \"server.crt\"));\n}\n\nfunction getHttpsServerDefaults (options) {\n    return fromJS({\n        key: getKey(options),\n        cert: getCert(options),\n        ca: getCa(options),\n        passphrase: \"\"\n    });\n}\n\nfunction getPFXDefaults (options) {\n    return fromJS({\n        pfx: fs.readFileSync(options.getIn([\"https\", \"pfx\"]))\n    });\n}\n\nvar serverUtils = {\n    /**\n     * @param options\n     * @returns {{key, cert}}\n     */\n    getHttpsOptions: function (options) {\n        var userOption = options.get(\"https\");\n        if (Map.isMap(userOption)) {\n            if (userOption.has(\"pfx\")) {\n                return userOption.mergeDeep(getPFXDefaults(options));\n            }\n            return userOption.mergeDeep(getHttpsServerDefaults(options));\n        }\n        return getHttpsServerDefaults(options);\n    },\n    /**\n     * Get either http or https server\n     * or use the httpModule provided in options if present\n     */\n    getServer: function (app, options) {\n        return {\n            server: (function () {\n\n                var httpModule = serverUtils.getHttpModule(options);\n\n                if (options.get(\"scheme\") === \"https\") {\n                    var opts = serverUtils.getHttpsOptions(options);\n                    return httpModule.createServer(opts.toJS(), app);\n                }\n\n                return httpModule.createServer(app);\n            })(),\n            app: app\n        };\n    },\n    getHttpModule: function (options) {\n        /**\n         * Users may provide a string to be used by nodes\n         * require lookup.\n         */\n        var httpModule = options.get(\"httpModule\");\n\n        if (typeof httpModule === \"string\") {\n            /**\n             * Note, this could throw, but let that happen as\n             * the error message good enough.\n             */\n            var maybe = path.resolve(process.cwd(), \"node_modules\", httpModule);\n            return require(maybe);\n        }\n\n        if (options.get(\"scheme\") === \"https\") {\n            return https;\n        }\n\n        return http;\n    },\n    getMiddlewares: function (bs) {\n\n        var clientJs = bs.pluginManager.hook(\"client:js\", {\n            port: bs.options.get(\"port\"),\n            options: bs.options\n        });\n\n        var scripts = bs.pluginManager.get(\"client:script\")(\n            bs.options.toJS(),\n            clientJs,\n            \"middleware\"\n        );\n\n        var defaultMiddlewares = [\n            {\n                id: \"Browsersync HTTP Protocol\",\n                route: require(\"../config\").httpProtocol.path,\n                handle: require(\"../http-protocol\").middleware(bs)\n            },\n            {\n                id: \"Browsersync IE8 Support\",\n                route: \"\",\n                handle: snippet.isOldIe(bs.options.get(\"excludedFileTypes\").toJS())\n            },\n            {\n                id: \"Browsersync Response Modifier\",\n                route: \"\",\n                handle: serverUtils.getSnippetMiddleware(bs)\n            },\n            {\n                id: \"Browsersync Client - versioned\",\n                route: bs.options.getIn([\"scriptPaths\", \"versioned\"]),\n                handle: scripts\n            },\n            {\n                id: \"Browsersync Client\",\n                route: bs.options.getIn([\"scriptPaths\", \"path\"]),\n                handle: scripts\n            }\n        ];\n\n        /**\n         * Add cors middleware to the front of the stack\n         * if a user provided a 'cors' flag\n         */\n        if (bs.options.get(\"cors\")) {\n            defaultMiddlewares.unshift({\n                id: \"Browsersync CORS support\",\n                route: \"\",\n                handle: serverUtils.getCorsMiddlewware()\n            })\n        }\n\n        /**\n         * Add serve static middleware\n         */\n        if (bs.options.get(\"serveStatic\")) {\n\n            var ssMiddlewares = serverUtils.getServeStaticMiddlewares(bs.options.get(\"serveStatic\"), bs.options.get(\"serveStaticOptions\", Immutable.Map({})).toJS());\n            var withErrors    = ssMiddlewares.filter(function(x) { return x.get(\"errors\").size > 0 });\n            var withoutErrors = ssMiddlewares.filter(function(x) { return x.get(\"errors\").size === 0 });\n\n            if (withErrors.size) {\n                withErrors.forEach(function (item) {\n                    logger.logger.error(\"{red:Warning!} %s\", item.getIn([\"errors\", 0, \"data\", \"message\"]));\n                });\n            }\n\n            if (withoutErrors.size) {\n                withoutErrors.forEach(function (item) {\n                    defaultMiddlewares.push.apply(defaultMiddlewares, item.get(\"items\").toJS());\n                });\n            }\n        }\n\n        /**\n         * Add user-provided middlewares\n         */\n        var userMiddlewares   = bs.options.get(\"middleware\").map(normaliseMiddleware).toArray();\n        var beforeMiddlewares = userMiddlewares.filter(function (x) { return x.override; });\n        var afterMiddlewares  = userMiddlewares.filter(function (x) { return !x.override; });\n\n        return [].concat(beforeMiddlewares, defaultMiddlewares, afterMiddlewares);\n\n        function normaliseMiddleware(item) {\n            /**\n             * Object given in options, which\n             * ended up being a Map\n             */\n            if (Map.isMap(item)) {\n                return item.toJS();\n            }\n            /**\n             * Single function\n             */\n            if (typeof item === \"function\") {\n                return {\n                    route: \"\",\n                    handle: item\n                }\n            }\n            /**\n             * Plain obj\n             */\n            if ((item.route !== undefined) && item.handle) {\n                return item;\n            }\n        }\n    },\n    getBaseApp: function (bs) {\n\n        var app         = connect();\n        var middlewares = serverUtils.getMiddlewares(bs);\n\n        /**\n         * Add all internal middlewares\n         */\n        middlewares.forEach(function (item) {\n            app.stack.push(item);\n        });\n\n        return app;\n    },\n    getSnippetMiddleware: function (bs) {\n\n        var rules = [];\n        var blacklist = List([])\n            .concat(bs.options.getIn([\"snippetOptions\", \"ignorePaths\"]))\n            .concat(bs.options.getIn([\"snippetOptions\", \"blacklist\"]))\n            .filter(Boolean);\n\n        var whitelist = List([])\n            .concat(bs.options.getIn([\"snippetOptions\", \"whitelist\"]));\n\n        // Snippet\n        rules.push(snippetUtils.getRegex(bs.options.get(\"snippet\"), bs.options.get(\"snippetOptions\")));\n\n        // User\n        bs.options.get(\"rewriteRules\").forEach(function (rule) {\n            if (Map.isMap(rule)) {\n                rules.push(rule.toJS());\n            }\n            if (_.isPlainObject(rule)) {\n                rules.push(rule);\n            }\n        });\n\n        // Proxy\n        if (bs.options.get(\"proxy\")) {\n            var proxyRule = require(\"./proxy-utils\").rewriteLinks(bs.options.getIn([\"proxy\", \"url\"]).toJS());\n            rules.push(proxyRule);\n        }\n\n        var lr = lrSnippet.create({\n            rules:     rules,\n            blacklist: blacklist.toArray(),\n            whitelist: whitelist.toArray()\n        });\n\n        return lr.middleware;\n    },\n    getCorsMiddlewware: function () {\n\n        return function (req, res, next) {\n            // Website you wish to allow to connect\n            res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n\n            // Request methods you wish to allow\n            res.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS, PUT, PATCH, DELETE\");\n\n            // Request headers you wish to allow\n            res.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With,content-type\");\n\n            // Set to true if you need the website to include cookies in the requests sent\n            // to the API (e.g. in case you use sessions)\n            res.setHeader(\"Access-Control-Allow-Credentials\", true);\n            next();\n        }\n    },\n    /**\n     * @param ssOption\n     * @param serveStaticOptions\n     * @returns {*}\n     */\n    getServeStaticMiddlewares: function (ssOption, serveStaticOptions) {\n\n        return ssOption.map(function (dir, i) {\n\n            /**\n             * When a user gives a plain string only, eg:\n             *   serveStatic: ['./temp']\n             *     ->\n             *       This means a middleware will be created with\n             *         route: ''\n             *         handle: serveStatic('./temp', options)\n             */\n            if (_.isString(dir)) {\n                return getFromString(dir)\n            }\n\n            /**\n             * If a user gave an object eg:\n             *   serveStatic: [{route: \"\", dir: [\"test\", \"./tmp\"]}]\n             *     ->\n             *       This means we need to create a middle for each route + dir combo\n             */\n            if (Immutable.Map.isMap(dir)) {\n                return getFromMap(dir, i);\n            }\n\n            /**\n             * At this point, an item in the serveStatic array was not a string\n             * or an object so we return an error that can be logged\n             */\n            return fromJS({\n                items: [],\n                errors: [{\n                    type: \"Invalid Type\",\n                    data: {\n                        message: \"Only strings and Objects (with route+dir) are supported for the ServeStatic option\"\n                    }\n                }]\n            })\n        });\n\n        /**\n         * @param {string} x\n         * @returns {string}\n         */\n        function getRoute (x) {\n            if (x === \"\") return \"\";\n            return x[0] === \"/\" ? x : \"/\" + x;\n        }\n\n        /**\n         * @param dir\n         * @returns {Map}\n         */\n        function getFromString(dir) {\n            return fromJS({\n                items: [\n                    {\n                        route: \"\",\n                        handle: serveStatic(dir, serveStaticOptions)\n                    }\n                ],\n                errors: []\n            })\n        }\n\n        /**\n         * @param dir\n         * @returns {Map}\n         */\n        function getFromMap(dir) {\n\n            var ssOptions = (function () {\n                if (dir.get(\"options\")) {\n                    return dir.get(\"options\").toJS();\n                }\n                return {}\n            })();\n\n            var route = Immutable.List([]).concat(dir.get(\"route\")).filter(_.isString);\n            var _dir  = Immutable.List([]).concat(dir.get(\"dir\")).filter(_.isString);\n\n            if (_dir.size === 0) {\n\n                return fromJS({\n                    items: [],\n                    errors: [{\n                        type: \"Invalid Object\",\n                        data: {\n                            message: \"Serve Static requires a 'dir' property when using an Object\"\n                        }\n                    }]\n                })\n            }\n\n            var ssItems = (function () {\n\n                /**\n                 * iterate over every 'route' item\n                 * @type {Immutable.List<any>|Immutable.List<*>|Immutable.List<any>|*}\n                 */\n                var routeItems = (function () {\n\n                    /**\n                     * If no 'route' was given, assume we want to match all\n                     * paths\n                     */\n                    if (route.size === 0) {\n                        return _dir.map(function (dirString) {\n                            return Map({\n                                route: \"\",\n                                dir: dirString\n                            });\n                        });\n                    }\n\n                    return route.reduce(function (acc, routeString) {\n                        /**\n                         * For each 'route' item, also iterate through 'dirs'\n                         * @type {Immutable.Iterable<K, M>}\n                         */\n                        var perDir = _dir.map(function (dirString) {\n                            return Map({\n                                route: getRoute(routeString),\n                                dir: dirString\n                            })\n                        });\n                        return acc.concat(perDir);\n\n                    }, List([]));\n                })();\n\n                /**\n                 * Now create a serverStatic Middleware for each item\n                 */\n                return routeItems.map(function (routeItem) {\n                    return routeItem.merge({\n                        handle: serveStatic(routeItem.get(\"dir\"), ssOptions)\n                    });\n                });\n            })();\n\n            return fromJS({\n                items: ssItems,\n                errors: []\n            });\n        }\n    }\n};\n\nmodule.exports = serverUtils;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/file-watcher.js":"\"use strict\";\n\nvar _ = require(\"../lodash.custom\");\nvar utils = require(\"./utils\");\nvar Rx = require(\"rx\");\n\n/**\n * Plugin interface\n * @returns {*|function(this:exports)}\n */\nmodule.exports.plugin = function (bs) {\n\n    var options = bs.options;\n    var emitter = bs.emitter;\n\n    var defaultWatchOptions = options.get(\"watchOptions\").toJS();\n\n    return options.get(\"files\").reduce(function (map, glob, namespace) {\n\n        /**\n         * Default CB when not given\n         * @param event\n         * @param path\n         */\n        var fn = function (event, path) {\n            emitter.emit(\"file:changed\", {\n                event: event,\n                path: path,\n                namespace: namespace\n            });\n        };\n\n        var jsItem = glob.toJS();\n\n        if (jsItem.globs.length) {\n            var watcher = watch(jsItem.globs, defaultWatchOptions, fn);\n            map[namespace] = {\n                watchers: [watcher]\n            };\n        }\n\n        if (jsItem.objs.length) {\n            jsItem.objs.forEach(function (item) {\n                if (!_.isFunction(item.fn)) {\n                    item.fn = fn;\n                }\n                var watcher = watch(item.match, item.options || defaultWatchOptions, item.fn.bind(bs.publicInstance));\n                if (!map[namespace]) {\n                    map[namespace] = {\n                        watchers: [watcher]\n                    };\n                } else {\n                    map[namespace].watchers.push(watcher);\n                }\n            });\n        }\n\n        return map;\n\n    }, {});\n};\n\n/**\n * @param patterns\n * @param opts\n * @param cb\n * @returns {*}\n */\nfunction watch (patterns, opts, cb) {\n\n    if (typeof opts === \"function\") {\n        cb = opts;\n        opts = {};\n    }\n\n    var watcher = require(\"chokidar\")\n        .watch(patterns, opts);\n\n    if (_.isFunction(cb)) {\n        watcher.on(\"all\", cb);\n    }\n\n    return watcher;\n}\n\nmodule.exports.watch = watch;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/server/index.js":"\"use strict\";\n\nvar enableDestroy = require(\"server-destroy\");\nvar _ = require(\"../../lodash.custom\");\n\n/**\n * Browsersync server\n * Three available modes: Snippet, Server or Proxy\n */\nmodule.exports.plugin = function (bs) {\n\n    var debug   = bs.debug;\n    var proxy   = bs.options.get(\"proxy\");\n    var type    = bs.options.get(\"mode\");\n\n    var bsServer = createServer(bs);\n\n    if (type === \"server\" || type === \"snippet\") {\n        debug(\"Static Server running ({magenta:%s}) ...\", bs.options.get(\"scheme\"));\n    }\n\n    if (proxy) {\n        debug(\"Proxy running, proxing: {magenta:%s}\", proxy.get(\"target\"));\n    }\n\n    if (bsServer) {\n\n        /**\n         * Allow server to be destroyed gracefully\n         */\n        enableDestroy(bsServer.server);\n\n        /**\n         * Listen on the available port\n         */\n        bsServer.server.listen(bs.options.get(\"port\"));\n\n        /**\n         * Hack to deal with https://github.com/socketio/socket.io/issues/1602#issuecomment-224270022\n         */\n        bs.registerCleanupTask(function () {\n            if (bs.io && bs.io.sockets) {\n                setCloseReceived(bs.io.sockets);\n            }\n            if (bs.ui && bs.ui.socket) {\n                setCloseReceived(bs.ui.socket);\n            }\n        });\n\n        /**\n         * Destroy the server on cleanup\n         */\n        bs.registerCleanupTask(function () {\n            bsServer.server.destroy();\n        });\n    }\n\n    function setCloseReceived(io) {\n        Object.keys(io.sockets).forEach(function (key) {\n            _.set(io.sockets[key], \"conn.transport.socket._closeReceived\", true);\n        });\n    }\n\n    debug(\"Running mode: %s\", type.toUpperCase());\n\n    return {\n        server: bsServer.server,\n        app:    bsServer.app\n    };\n};\n\n/**\n * Launch the server for serving the client JS plus static files\n * @param {BrowserSync} bs\n * @returns {{staticServer: (http.Server), proxyServer: (http.Server)}}\n */\nfunction createServer (bs) {\n\n    var proxy   = bs.options.get(\"proxy\");\n    var server  = bs.options.get(\"server\");\n\n    if (!proxy && !server) {\n        return require(\"./snippet-server\")(bs);\n    }\n\n    if (proxy) {\n        return require(\"./proxy-server\")(bs);\n    }\n\n    if (server) {\n        return require(\"./static-server\")(bs);\n    }\n}\n\nmodule.exports.createServer = createServer;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/tunnel.js":"\"use strict\";\n\nvar _ = require(\"../lodash.custom\");\nvar utils = require(\"util\");\n\n/**\n * @param {BrowserSync} bs\n * @param {Function} cb\n */\nmodule.exports = function (bs, cb) {\n\n    var opts         = {};\n    var options      = bs.options;\n    var port         = options.get(\"port\");\n\n    if (_.isString(options.get(\"tunnel\"))) {\n        opts.subdomain = options.get(\"tunnel\");\n    }\n\n    bs.debug(\"Requesting a tunnel connection on port: {magenta:%s}\", port);\n    bs.debug(\"Requesting a tunnel connection with options: {magenta:%s}\", utils.inspect(opts));\n\n    require(\"localtunnel\")(port, opts, function (err, tunnel) {\n        if (err) {\n            return cb(err);\n        }\n\n        tunnel.on(\"error\", function (err) {\n            bs.logger.info(\"Localtunnel issue: \" + err.message);\n            bs.logger.info(\"Oops! The localtunnel appears to have disconnected. Reconnecting...\");\n        });\n\n        return cb(null, tunnel);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-client/index.js":"\"use strict\";\n\nvar etag  = require(\"etag\");\nvar fresh = require(\"fresh\");\nvar fs    = require(\"fs\");\nvar path  = require(\"path\");\nvar zlib  = require(\"zlib\");\n\nvar minifiedScript   = path.join(__dirname, \"/dist/index.min.js\");\nvar unminifiedScript = path.join(__dirname, \"/dist/index.js\");\n\n/**\n * Does the current request support compressed encoding?\n * @param {Object} req\n * @returns {boolean}\n */\nfunction supportsGzip (req) {\n    var accept = req.headers['accept-encoding'];\n    return accept && accept.indexOf('gzip') > -1;\n}\n\n/**\n * Set headers on the response\n * @param {Object} res\n * @param {String} body\n */\nfunction setHeaders(res, body) {\n\n    res.setHeader(\"Cache-Control\", \"public, max-age=0\");\n    res.setHeader(\"Content-Type\", \"text/javascript\");\n    res.setHeader(\"ETag\", etag(body));\n}\n\n/**\n * @param {Object} options\n * @param {String} connector\n * @returns {String}\n */\nfunction getScriptBody(options, connector) {\n\n    var script = minifiedScript;\n\n    if (options && !options.minify) {\n        script = unminifiedScript;\n    }\n\n    return connector + fs.readFileSync(script);\n}\n\n/**\n * @param {Object} req\n * @returns {String}\n */\nfunction isConditionalGet(req) {\n    return req.headers[\"if-none-match\"] || req.headers[\"if-modified-since\"];\n}\n\n/**\n * Return a not-modified response\n * @param {Object} res\n */\nfunction notModified(res) {\n    res.removeHeader(\"Content-Type\");\n    res.statusCode = 304;\n    res.end();\n}\n\n/**\n * Public method for returning either a middleware fn\n * or the content as a string\n * @param {Object} options\n * @param {String} connector - content to be prepended\n * @param {String} type - either `file` or `middleware`\n * @returns {*}\n */\nfunction init(options, connector, type) {\n\n    var gzipCached;\n\n    /**\n     * Combine string to create the final version\n     * @type {String}\n     */\n    var requestBody = getScriptBody(options, connector);\n\n    /**\n     * If the user asked for a file, simply return the string.\n     */\n    if (type && type === \"file\") {\n        return requestBody;\n    }\n\n    /**\n     * Otherwise return a function to be used a middleware\n     */\n    return function (req, res) {\n\n        /**\n         * default to using the uncompressed string\n         * @type {String}\n         */\n        var output = requestBody;\n\n        /**\n         * Set the appropriate headers for caching\n         */\n        setHeaders(res, output);\n\n        if (isConditionalGet(req) && fresh(req.headers, res._headers)) {\n            return notModified(res);\n        }\n\n        /**\n         * If gzip is supported, compress the string once\n         * and save for future requests\n         */\n        if (supportsGzip(req)) {\n\n            res.setHeader(\"Content-Encoding\", \"gzip\");\n\n            if (!gzipCached) {\n                var buf = new Buffer(output, \"utf-8\");\n                zlib.gzip(buf, function (_, result) {\n                    gzipCached = result;\n                    res.end(result);\n                });\n            } else {\n                res.end(gzipCached);\n            }\n\n        } else {\n            res.end(output);\n        }\n    };\n}\n\nmodule.exports.middleware = init;\nmodule.exports.plugin = init;\nmodule.exports.minified = function () {\n    return fs.readFileSync(minifiedScript, 'utf8');\n};\nmodule.exports.unminified = function () {\n    return fs.readFileSync(unminifiedScript, 'utf8');\n}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/index.js":"\"use strict\";\n\nvar UI          = require(\"./lib/UI\");\nvar config      = require(\"./lib/config\");\nvar Events      = require(\"events\").EventEmitter;\n\n/**\n * Hooks are for attaching functionality to BrowserSync\n */\nmodule.exports.hooks = {\n    /**\n     * Client JS is added to each connected client\n     */\n    \"client:js\": fileContent(config.defaults.clientJs)\n};\n\n/**\n * BrowserSync Plugin interface\n * @param {Object} opts\n * @param {BrowserSync} bs\n * @param {Function} cb\n * @returns {UI}\n */\nmodule.exports[\"plugin\"] = function (opts, bs, cb) {\n    var ui = new UI(opts, bs, new Events());\n    bs.setOption(\"session\", new Date().getTime());\n    ui.cb = cb || function () { /*noop*/ };\n    ui.init();\n    return ui;\n};\n\nmodule.exports[\"plugin:name\"]       = config.defaults.pluginName;\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction getPath (filepath) {\n    return require(\"path\").join(__dirname, filepath);\n}\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction fileContent (filepath) {\n    return require(\"fs\").readFileSync(getPath(filepath));\n}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/UI.js":"var fs          = require(\"fs\");\nvar path        = require(\"path\");\n\nvar config      = require(\"./config\");\nvar eachSeries  = require(\"async-each-series\");\nvar asyncTasks  = require(\"./async-tasks\");\nvar hooks       = require(\"./hooks\");\nvar merge       = require(\"./opts\").merge;\n\nvar defaultPlugins = {\n    \"sync-options\":     require(\"./plugins/sync-options/sync-options.plugin\"),\n    \"overview\":         require(\"./plugins/overview/overview.plugin\"),\n    \"history\":          require(\"./plugins/history/history.plugin\"),\n    \"plugins\":          require(\"./plugins/plugins/plugins.plugin\"),\n    \"remote-debug\":     require(\"./plugins/remote-debug/remote-debug.plugin\"),\n    \"help\":             require(\"./plugins/help/help.plugin\"),\n    \"connections\":      require(\"./plugins/connections/connections.plugin\"),\n    \"network-throttle\": require(\"./plugins/network-throttle/network-throttle.plugin\")\n};\n\n/**\n * @param {Object} opts - Any options specifically\n *                        passed to the control panel\n * @param {BrowserSync} bs\n * @param {EventEmitter} emitter\n * @constructor\n * @returns {UI}\n */\nvar UI = function (opts, bs, emitter) {\n\n    var ui            = this;\n    ui.bs             = bs;\n    ui.config         = config.merge();\n    ui.events         = emitter;\n    ui.options        = merge(opts);\n    ui.logger         = bs.getLogger(ui.config.get(\"pluginName\"));\n    ui.defaultPlugins = defaultPlugins;\n    ui.listeners      = {};\n    ui.clients        = bs.io.of(bs.options.getIn([\"socket\", \"namespace\"]));\n    ui.socket         = bs.io.of(ui.config.getIn([\"socket\", \"namespace\"]));\n\n    if (ui.options.get(\"logLevel\")) {\n        ui.logger.setLevel(ui.options.get(\"logLevel\"));\n    }\n\n    /**\n     *\n     */\n    ui.pluginManager = new bs.utils.easyExtender(defaultPlugins, hooks).init();\n\n    /**\n     * Transform/save data RE: plugins\n     * @type {*}\n     */\n    ui.bsPlugins = require(\"./resolve-plugins\")(bs.getUserPlugins());\n\n    return ui;\n};\n\n/**\n * Detect an available port\n * @returns {UI}\n */\nUI.prototype.init = function () {\n\n    var ui = this;\n\n    eachSeries(\n        asyncTasks,\n        taskRunner(ui),\n        tasksComplete(ui)\n    );\n\n    return this;\n};\n\n/**\n * @param cb\n */\nUI.prototype.getServer = function (cb) {\n    var ui = this;\n    if (ui.server) {\n        return ui.server;\n    }\n    this.events.on(\"ui:running\", function () {\n        cb(null, ui.server);\n    });\n};\n\n/**\n * @returns {Array}\n */\nUI.prototype.getInitialTemplates = function () {\n    var prefix = path.resolve(__dirname, \"../templates/directives\");\n    return fs.readdirSync(prefix)\n        .map(function (name) {\n            return path.resolve(prefix, name);\n        });\n};\n\n/**\n * @param event\n */\nUI.prototype.delegateEvent = function (event) {\n\n    var ui = this;\n    var listeners = ui.listeners[event.namespace];\n\n    if (listeners) {\n        if (listeners.event) {\n            listeners.event.call(ui, event);\n        } else {\n            if (event.event && listeners[event.event]) {\n                listeners[event.event].call(ui, event.data);\n            }\n        }\n    }\n};\n\n/**\n * @param cb\n */\nUI.prototype.listen = function (ns, events) {\n    var ui = this;\n    if (Array.isArray(ns)) {\n        ns = ns.join(\":\");\n    }\n    if (!ui.listeners[ns]) {\n        ui.listeners[ns] = events;\n    }\n};\n\n/**\n * @param name\n * @param value\n * @returns {Map|*}\n */\nUI.prototype.setOption = function (name, value) {\n    var ui     = this;\n    ui.options = ui.options.set(name, value);\n    return ui.options;\n};\n\n/**\n * @param path\n * @param value\n * @returns {Map|*}\n */\nUI.prototype.setOptionIn = function (path, value) {\n    this.options = this.options.setIn(path, value);\n    return this.options;\n};\n\n/**\n * @param fn\n */\nUI.prototype.setMany = function (fn) {\n    this.options = this.options.withMutations(fn);\n    return this.options;\n};\n\n/**\n * @param path\n * @returns {any|*}\n */\nUI.prototype.getOptionIn = function (path) {\n    return this.options.getIn(path);\n};\n\n/**\n * Run each setup task in sequence\n * @param ui\n * @returns {Function}\n */\nfunction taskRunner (ui) {\n\n    return function (item, cb) {\n\n        ui.logger.debug(\"Starting Step: \" + item.step);\n\n        /**\n         * Give each step access to the UI Instance\n         */\n        item.fn(ui, function (err, out) {\n            if (err) {\n                return cb(err);\n            }\n            if (out) {\n                handleOut(ui, out);\n            }\n            ui.logger.debug(\"{green:Step Complete: \" + item.step);\n            cb();\n        });\n    };\n}\n\n/**\n * Setup tasks may return options or instance properties to be set\n * @param {UI} ui\n * @param {Object} out\n */\nfunction handleOut (ui, out) {\n\n    if (out.options) {\n        Object.keys(out.options).forEach(function (key) {\n            ui.options = ui.options.set(key, out.options[key]);\n        });\n    }\n\n    if (out.optionsIn) {\n        out.optionsIn.forEach(function (item) {\n            ui.options = ui.options.setIn(item.path, item.value);\n        });\n    }\n\n    if (out.instance) {\n        Object.keys(out.instance).forEach(function (key) {\n            ui[key] = out.instance[key];\n        });\n    }\n}\n\n/**\n * All async tasks complete at this point\n * @param ui\n */\nfunction tasksComplete (ui) {\n\n    return function (err) {\n\n        /**\n         * Log any error according to BrowserSync's Logging level\n         */\n        if (err) {\n            ui.logger.setOnce(\"useLevelPrefixes\", true).error(err.message || err);\n        }\n\n        /**\n         * Running event\n         */\n        ui.events.emit(\"ui:running\", {instance: ui, options: ui.options});\n\n        /**\n         * Finally call the user-provided callback\n         */\n        ui.cb(null, ui);\n    };\n}\n\nmodule.exports = UI;","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/config.js":"var Immutable = require(\"immutable\");\n\n/**\n * Any configurable paths/config\n * @type {{pluginName: string, indexPage: string, socketJs: string, appJs: string, connector: string}}\n */\nvar defaults = {\n    pluginName:  \"UI\",\n    indexPage:   \"/index.html\",\n    socketJs:    \"/js/vendor/socket.js\",\n    appJs:       \"/js/dist/app.js\",\n    app:         \"/app.js\",\n    appExtraJs:  \"/js/app-extra.js\",\n    connector:   \"/js/connector.js\",\n    pagesConfig: \"/js/pages-config.js\",\n    public: {\n        svg: \"/img/icons/icons.svg\",\n        css: \"/css/core.min.css\"\n    },\n    clientJs:    \"/lib/client-js.js\",\n    socket: {\n        namespace: \"/browser-sync-cp\"\n    },\n    components: {\n        header: \"/components/header.html\",\n        footer: \"/components/footer.html\"\n    }\n};\n\nmodule.exports.defaults = defaults;\n\n/**\n * @param [userConfig]\n * @returns {Map}\n */\nmodule.exports.merge    = function (userConfig) {\n    return Immutable\n        .fromJS(defaults)\n        .mergeDeep(userConfig);\n};","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/async-tasks.js":"var async       = require(\"./async\");\n\nmodule.exports = [\n    {\n        step: \"Setting default plugins\",\n        fn:   async.initDefaultHooks\n    },\n    {\n        step: \"Finding a free port\",\n        fn:   async.findAFreePort\n    },\n    {\n        step: \"Setting options also relevant to UI from BS\",\n        fn:   async.setBsOptions\n    },\n    {\n        step: \"Setting available URLS for UI\",\n        fn:   async.setUrlOptions\n    },\n    {\n        step: \"Starting the Control Panel Server\",\n        fn:   async.startServer\n    },\n    {\n        step: \"Add element events\",\n        fn:   async.addElementEvents\n    },\n    {\n        step: \"Registering default plugins\",\n        fn:   async.registerPlugins\n    },\n    {\n        step: \"Add options setting event\",\n        fn: async.addOptionsEvent\n    }\n];","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/async.js":"var Immutable = require(\"immutable\");\nvar url = require(\"url\");\n\nmodule.exports = {\n    /**\n     * The UI uses it's own server/port\n     * @param ui\n     * @param done\n     */\n    findAFreePort: function (ui, done) {\n        var port = ui.options.get(\"port\");\n        ui.bs.utils.portscanner.findAPortNotInUse(port, port + 100, {\n            host: \"localhost\",\n            timeout: 1000\n        }, function (err, port) {\n            if (err) {\n                return done(err);\n            }\n            done(null, {\n                options: {\n                    port: port\n                }\n            });\n        });\n    },\n    /**\n     * Default hooks do things like creating/joining JS files &\n     * building angular config\n     * @param ui\n     * @param done\n     */\n    initDefaultHooks: function (ui, done) {\n\n        var out = ui.pluginManager.hook(\"page\", ui);\n\n        done(null, {\n            instance: {\n                clientJs:    ui.pluginManager.hook(\"client:js\", ui),\n                templates:   ui.pluginManager.hook(\"templates\", ui.getInitialTemplates(), ui),\n                pagesConfig: out.pagesConfig,\n                pages:       out.pagesObj,\n                pageMarkup:  out.pageMarkup\n            }\n        });\n    },\n    setBsOptions: function (ui, done) {\n        done(null, {\n            options: {\n                bs: Immutable.Map({\n                    mode: ui.bs.options.get(\"mode\"),\n                    port: ui.bs.options.get(\"port\")\n                })\n            }\n        });\n    },\n    /**\n     * @param ui\n     * @param done\n     */\n    setUrlOptions: function (ui, done) {\n\n        var port        = ui.options.get(\"port\");\n        var bsUrls      = ui.bs.getOptionIn([\"urls\"]).toJS();\n        var urls        = {\n            ui: \"http://localhost:\" + port\n        };\n\n        if (bsUrls.external) {\n            urls[\"ui-external\"] = [\"http://\", url.parse(bsUrls.external).hostname, \":\", port].join(\"\");\n        }\n\n        done(null, {\n            options: {\n                urls: Immutable.fromJS(urls)\n            }\n        });\n    },\n    /**\n     * Simple static file server with some middlewares for custom\n     * scripts/routes.\n     * @param ui\n     * @param done\n     */\n    startServer: function (ui, done) {\n\n        var bs          = ui.bs;\n        var port        = ui.options.get(\"port\");\n\n        ui.logger.debug(\"Using port %s\", port);\n\n        var server = require(\"./server\")(ui, {\n            middleware: {\n                socket: bs.getMiddleware(\"socket-js\"),\n                connector: bs.getSocketConnector(bs.options.get(\"port\"), {\n                    path: bs.options.getIn([\"socket\", \"path\"]),\n                    namespace: ui.config.getIn([\"socket\", \"namespace\"])\n                })\n            }\n        });\n\n        require('server-destroy')(server.server);\n\n        bs.registerCleanupTask(function () {\n            if (server.server) {\n                server.server.destroy();\n            }\n            if (ui.servers) {\n                Object.keys(ui.servers).forEach(function (key) {\n                    if (ui.servers[key].server) {\n                        ui.servers[key].server.destroy();\n                    }\n                });\n            }\n        });\n\n        done(null, {\n            instance: {\n                server: server.server.listen(port),\n                app: server.app\n            }\n        });\n\n    },\n    /**\n     * Allow an API for adding/removing elements to clients\n     * @param ui\n     * @param done\n     */\n    addElementEvents: function (ui, done) {\n\n        var elems = ui.pluginManager.hook(\"elements\");\n        var bs    = ui.bs;\n\n        if (!Object.keys(elems).length) {\n            return done();\n        }\n\n        ui.setOption(\"clientFiles\", Immutable.fromJS(elems));\n\n        done(null, {\n            instance: {\n                enableElement:  require(\"./client-elements\").enable(ui.clients, ui, bs),\n                disableElement: require(\"./client-elements\").disable(ui.clients, ui, bs),\n                addElement:     require(\"./client-elements\").addElement\n            }\n        });\n    },\n    /**\n     * Run default plugins\n     * @param ui\n     * @param done\n     */\n    registerPlugins: function (ui, done) {\n        Object.keys(ui.defaultPlugins).forEach(function (key) {\n            ui.pluginManager.get(key)(ui, ui.bs);\n        });\n        done();\n    },\n    /**\n     * The most important event is the initial connection where\n     * the options are received from the socket\n     * @param ui\n     * @param done\n     */\n    addOptionsEvent: function (ui, done) {\n\n        var bs = ui.bs;\n\n        ui.clients.on(\"connection\", function (client) {\n\n            client.emit(\"ui:connection\", ui.options.toJS());\n\n            ui.options.get(\"clientFiles\").map(function (item) {\n                if (item.get(\"active\")) {\n                    ui.addElement(client, item.toJS());\n                }\n            });\n        });\n\n        ui.socket.on(\"connection\", function (client) {\n\n            client.emit(\"connection\", bs.getOptions().toJS());\n\n            client.emit(\"ui:connection\", ui.options.toJS());\n\n            client.on(\"ui:get:options\", function () {\n                client.emit(\"ui:receive:options\", {\n                    bs: bs.getOptions().toJS(),\n                    ui: ui.options.toJS()\n                });\n            });\n\n            // proxy client events\n            client.on(\"ui:client:proxy\", function (evt) {\n                ui.clients.emit(evt.event, evt.data);\n            });\n\n            client.on(\"ui\", function (data) {\n                ui.delegateEvent(data);\n            });\n        });\n        done();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/hooks.js":"var fs         = require(\"fs\");\nvar path       = require(\"path\");\n\nvar pluginTmpl     = templateFile(\"/plugin.tmpl\");\nvar configTmpl     = templateFile(\"/config.tmpl\");\nvar configItem     = templateFile(\"/config.item.tmpl\");\nvar inlineTemp     = templateFile(\"/inline.template.tmpl\");\nvar pluginItemTmpl = fs.readFileSync(path.resolve(__dirname, \"../\", \"templates/plugin.item.tmpl\"), \"utf-8\");\n\nfunction templateFile (filepath) {\n    return fs.readFileSync(path.join(__dirname, \"/../templates\", filepath || \"\"), \"utf-8\");\n}\n\n/**\n * @type {{page: Function, markup: Function, client:js: Function, templates: Function}}\n */\nmodule.exports = {\n    /**\n     * Create the url config for each section of the ui\n     * @param hooks\n     * @param ui\n     */\n    \"page\": function (hooks, ui) {\n\n        var config = hooks\n            .map(transformConfig)\n            .reduce(createConfigItem, {});\n\n        return {\n            /**\n             * pagesConfig - This is the angular configuration such as routes\n             */\n            pagesConfig: configTmpl\n                .replace(\"%when%\", hooks.reduce(\n                    createAngularRoutes,\n                    \"\"\n                ))\n                .replace(\"%pages%\", JSON.stringify(\n                    config,\n                    null,\n                    4\n                )),\n            /**\n             * pagesConfig in object form\n             */\n            pagesObj: config,\n            pageMarkup: function () {\n                return preAngular(ui.pluginManager.plugins, config, ui);\n            }\n        };\n    },\n    /**\n     * Controller markup for each plugin\n     * @param hooks\n     * @returns {*}\n     */\n    \"markup\": function (hooks) {\n        return hooks.reduce(pluginTemplate, \"\");\n    },\n    /**\n     * @param hooks\n     * @param {UI} ui\n     * @returns {*|string}\n     */\n    \"client:js\": function (hooks, ui) {\n\n        /**\n         * Add client JS from Browsersync Plugins\n         */\n        ui.bsPlugins.forEach(function (plugin) {\n            if (plugin.has(\"client:js\")) {\n                plugin.get(\"client:js\").forEach(function (value) {\n                    hooks.push(value);\n                });\n            }\n        });\n\n        var out = hooks.reduce(function (all, item) {\n            if (typeof item === \"string\") {\n                all += \";\" + item;\n            } else if (Array.isArray(item)) {\n                item.forEach(function (item) {\n                    all += \";\" + item;\n                });\n            }\n            return all;\n        }, \"\");\n\n        return out;\n    },\n    /**\n     * @param hooks\n     * @param initial\n     * @param {UI} ui\n     * @returns {String}\n     */\n    \"templates\": function (hooks, initial, ui) {\n\n        /**\n         * Add templates from each Browsersync registered plugin\n         * @type {string}\n         */\n        var pluginDirectives = ui.bsPlugins.reduce(function (all, plugin) {\n\n            if (!plugin.has(\"templates\")) {\n                return all;\n            }\n\n            /**\n             * Slugify-ish the plugin name\n             *  eg: Test Browsersync Plugin\n             *    = test-browsersync-plugin\n             * @type {string}\n             */\n            var slug = plugin.get(\"name\")\n                .trim()\n                .split(\" \")\n                .map(function (word) {\n                    return word.trim().toLowerCase();\n                })\n                .join(\"-\");\n\n            /**\n             * For every plugin that has templates, wrap\n             * the markup in the <script type=\"text/ng-template\" id=\"{{slug}}\"></script>\n             * markup to result in the single output string.\n             */\n            plugin.get(\"templates\").forEach(function (value, key) {\n                all +=  angularWrap([slug, path.basename(key)].join(\"/\"), value);\n            });\n\n            return all;\n\n        }, \"\");\n\n        /**\n         * Combine the markup from the plugins done above with any\n         * others registered via hooks + initial\n         * to create the final markup\n         */\n        return [pluginDirectives, createInlineTemplates(hooks.concat([initial]))].join(\"\");\n    },\n    /**\n     * Allow plugins to register toggle-able elements\n     * @param hooks\n     * @returns {{}}\n     */\n    \"elements\": function (hooks) {\n        var obj = {};\n        hooks.forEach(function (elements) {\n            elements.forEach(function (item) {\n                if (!obj[item.name]) {\n                    obj[item.name] = item;\n                }\n            });\n        });\n        return obj;\n    }\n};\n\n/**\n * @param hooks\n * @returns {String}\n */\nfunction createInlineTemplates (hooks) {\n    return hooks.reduce(function (combined, item) {\n        return combined + item.reduce(function (all, filepath) {\n            return all + angularWrap(\n                path.basename(filepath),\n                fs.readFileSync(filepath));\n        }, \"\");\n    }, \"\");\n}\n\n/**\n * @param item\n * @returns {*}\n */\nfunction transformConfig (item) {\n    return item;\n}\n\n/**\n * @param {String} all\n * @param {Object} item\n * @returns {*}\n */\nfunction createAngularRoutes(all, item) {\n    return all + configItem.replace(/%(.+)%/g, function () {\n        var key = arguments[1];\n        if (item[key]) {\n            return item[key];\n        }\n    });\n}\n\n/**\n * @param joined\n * @param item\n * @returns {*}\n */\nfunction createConfigItem (joined, item) {\n    if (item.path === \"/\") {\n        joined[\"overview\"] = item;\n    } else {\n        joined[item.path.slice(1)] = item;\n    }\n    return joined;\n}\n\n/**\n * @returns {*}\n */\nfunction pluginTemplate (combined, item) {\n    return [combined, pluginTmpl.replace(\"%markup%\", item)].join(\"\\n\");\n}\n\n/**\n * @param plugins\n * @param config\n * @returns {*}\n */\nfunction preAngular (plugins, config, ui) {\n\n    return Object.keys(plugins)\n        .filter(function (key) {\n            return config[key]; // only work on plugins that have pages\n        })\n        .map(function (key) {\n            if (key === \"plugins\") {\n                var pluginMarkup = ui.bsPlugins.reduce(function (all, item, i) {\n                    all += pluginItemTmpl\n                        .replace(\"%content%\", item.get(\"markup\") || \"\")\n                        .replace(/%index%/g, i)\n                        .replace(/%name%/g, item.get(\"name\"));\n\n                    return all;\n                }, \"\");\n                plugins[key].hooks.markup = plugins[key].hooks.markup.replace(\"%pluginlist%\", pluginMarkup);\n            }\n            return angularWrap(config[key].template, bindOnce(plugins[key].hooks.markup, config[key]));\n        })\n        .reduce(function (combined, item) {\n            return combined + item;\n        }, \"\");\n}\n\n/**\n * @param templateName\n * @param markup\n * @returns {*}\n */\nfunction angularWrap (templateName, markup) {\n    return inlineTemp\n        .replace(\"%content%\", markup)\n        .replace(\"%id%\", templateName);\n}\n\n/**\n * @param markup\n * @param config\n * @returns {*|string}\n */\nfunction bindOnce (markup, config) {\n    return markup.toString().replace(/\\{\\{ctrl.section\\.(.+?)\\}\\}/g, function ($1, $2) {\n        return config[$2] || \"\";\n    });\n}\n\nmodule.exports.bindOnce = bindOnce;\n\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/opts.js":"var Immutable  = require(\"immutable\");\n\nvar defaults = Immutable.fromJS({\n    port: 3001,\n    weinre: {\n        port: 8080\n    }\n});\n\n/**\n * @param {Object} obj\n * @returns {Map}\n */\nmodule.exports.merge = function (obj) {\n    return defaults.mergeDeep(Immutable.fromJS(obj));\n};\n\n/**\n * @param {Immutable.Map} obj\n * @returns {*}\n */\n//function transformOptions(obj) {\n//\n//    var out;\n//\n//    Object.keys(transforms).forEach(function (key) {\n//        out = obj.set(key, transforms[key](obj));\n//    });\n//\n//    return out;\n//}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/sync-options/sync-options.plugin.js":"const PLUGIN_NAME = \"Sync Options\";\n\n/**\n * @type {{plugin: Function, plugin:name: string, hooks: object}}\n */\nmodule.exports = {\n\n    \"plugin\": function (ui, bs) {\n\n        ui.listen(\"sync-options\", {\n\n            \"set\": function (data) {\n\n                ui.logger.debug(\"Setting option: {magenta:%s}:{cyan:%s}\", data.path.join(\".\"), data.value);\n                bs.setOptionIn(data.path, data.value);\n\n            },\n\n            \"setMany\": function (data) {\n\n                ui.logger.debug(\"Setting Many options...\");\n\n                if (data.value !== true) {\n                    data.value = false;\n                }\n\n                bs.setMany(function (item) {\n                    [\n                        [\"codeSync\"],\n                        [\"ghostMode\", \"clicks\"],\n                        [\"ghostMode\", \"scroll\"],\n                        [\"ghostMode\", \"forms\", \"inputs\"],\n                        [\"ghostMode\", \"forms\", \"toggles\"],\n                        [\"ghostMode\", \"forms\", \"submit\"]\n                    ].forEach(function (option) {\n                            item.setIn(option, data.value);\n                        });\n                });\n\n                return bs;\n            }\n        });\n    },\n    \"hooks\": {\n        \"markup\": fileContent(\"sync-options.html\"),\n        \"client:js\": fileContent(\"sync-options.client.js\"),\n        \"templates\": [],\n        \"page\": {\n            path: \"/sync-options\",\n            title: PLUGIN_NAME,\n            template: \"sync-options.html\",\n            controller: PLUGIN_NAME.replace(\" \", \"\") + \"Controller\",\n            order: 2,\n            icon: \"sync\"\n        }\n    },\n    \"plugin:name\": PLUGIN_NAME\n};\n\nfunction getPath (filepath) {\n    return require(\"path\").join(__dirname, filepath);\n}\n\nfunction fileContent (filepath) {\n    return require(\"fs\").readFileSync(getPath(filepath), \"utf-8\");\n}\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/overview/overview.plugin.js":"const PLUGIN_NAME = \"Overview\";\n\n/**\n * @type {{plugin: Function, plugin:name: string, markup: string}}\n */\nmodule.exports = {\n    /**\n     * Plugin init\n     */\n    \"plugin\": function () { /* noop */ },\n\n    /**\n     * Hooks\n     */\n    \"hooks\": {\n        \"markup\": fileContent(\"/overview.html\"),\n        \"client:js\": fileContent(\"/overview.client.js\"),\n        \"templates\": [\n            getPath(\"/snippet-info.html\"),\n            getPath(\"/url-info.html\")\n        ],\n        \"page\": {\n            path: \"/\",\n            title: PLUGIN_NAME,\n            template: \"overview.html\",\n            controller: PLUGIN_NAME.replace(\" \", \"\") + \"Controller\",\n            order: 1,\n            icon: \"cog\"\n        }\n    },\n    /**\n     * Plugin name\n     */\n    \"plugin:name\": PLUGIN_NAME\n};\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction getPath (filepath) {\n    return require(\"path\").join(__dirname, filepath);\n}\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction fileContent (filepath) {\n    return require(\"fs\").readFileSync(getPath(filepath), \"utf-8\");\n}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/history/history.plugin.js":"var historyPlugin = require(\"./history\");\n\nconst PLUGIN_NAME = \"History\";\n\n/**\n * @type {{plugin: Function, plugin:name: string, markup: string}}\n */\nmodule.exports = {\n    /**\n     * @param ui\n     * @param bs\n     */\n    \"plugin\": function (ui, bs) {\n        ui.history = historyPlugin.init(ui, bs);\n    },\n    /**\n     * Hooks\n     */\n    \"hooks\": {\n        \"markup\": fileContent(\"history.html\"),\n        \"client:js\": fileContent(\"/history.client.js\"),\n        \"templates\": [\n            getPath(\"/history.directive.html\")\n        ],\n        \"page\": {\n            path: \"/history\",\n            title: PLUGIN_NAME,\n            template: \"history.html\",\n            controller: PLUGIN_NAME + \"Controller\",\n            order: 3,\n            icon: \"list2\"\n        }\n    },\n    /**\n     * Plugin name\n     */\n    \"plugin:name\": PLUGIN_NAME\n};\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction getPath (filepath) {\n    return require(\"path\").join(__dirname, filepath);\n}\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction fileContent (filepath) {\n    return require(\"fs\").readFileSync(getPath(filepath), \"utf-8\");\n}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/history/history.js":"var url       = require(\"url\");\nvar Immutable = require(\"immutable\");\n\nmodule.exports.init = function (ui, bs) {\n\n    var validUrls = Immutable.OrderedSet();\n\n    var methods = {\n        /**\n         * Send the url list to UI\n         * @param urls\n         */\n        sendUpdatedUrls: function (urls) {\n            ui.socket.emit(\"ui:history:update\", decorateUrls(urls));\n        },\n        /**\n         * Only send to UI if list changed\n         * @param current\n         * @param temp\n         */\n        sendUpdatedIfChanged: function (current, temp) {\n            if (!Immutable.is(current, temp)) {\n                validUrls = temp;\n                methods.sendUpdatedUrls(validUrls);\n            }\n        },\n        /**\n         * Send all clients to a URL - this is a proxy\n         * in case we need to limit/check anything.\n         * @param data\n         */\n        sendToUrl: function (data) {\n\n            var parsed = url.parse(data.path);\n\n            data.override = true;\n            data.path = parsed.path;\n            data.url  = parsed.href;\n\n            ui.clients.emit(\"browser:location\", data);\n        },\n        /**\n         * Add a new path\n         * @param data\n         */\n        addPath: function (data) {\n            var temp = addPath(validUrls, url.parse(data.href), bs.options.get(\"mode\"));\n            methods.sendUpdatedIfChanged(validUrls, temp, ui.socket);\n        },\n        /**\n         * Remove a path\n         * @param data\n         */\n        removePath: function (data) {\n            var temp = removePath(validUrls, data.path);\n            methods.sendUpdatedIfChanged(validUrls, temp, ui.socket);\n        },\n        /**\n         * Get the current list\n         */\n        getVisited: function () {\n            ui.socket.emit(\"ui:receive:visited\", decorateUrls(validUrls));\n        }\n    };\n\n    ui.clients.on(\"connection\", function (client) {\n        client.on(\"ui:history:connected\", methods.addPath);\n    });\n\n    ui.socket.on(\"connection\", function (uiClient) {\n        /**\n         * Send urls on first connection\n         */\n        uiClient.on(\"ui:get:visited\",    methods.getVisited);\n        methods.sendUpdatedUrls(validUrls);\n    });\n\n    ui.listen(\"history\", {\n        \"sendAllTo\": methods.sendToUrl,\n        \"remove\":    methods.removePath,\n        \"clear\":     function () {\n            validUrls = Immutable.OrderedSet([]);\n            methods.sendUpdatedUrls(validUrls);\n        }\n    });\n\n    return methods;\n};\n\n/**\n * @param {Immutable.Set} urls\n * @returns {Array}\n */\nfunction decorateUrls (urls) {\n    var count = 0;\n    return urls.map(function (value) {\n        count += 1;\n        return {\n            path: value,\n            key: count\n        };\n    }).toJS().reverse();\n}\n\n/**\n * If snippet mode, add the full URL\n * if server/proxy, add JUST the path\n * @param immSet\n * @param urlObj\n * @param mode\n * @returns {Set}\n */\nfunction addPath(immSet, urlObj, mode) {\n    return immSet.add(\n        mode === \"snippet\"\n            ? urlObj.href\n            : urlObj.path\n    );\n}\n\nmodule.exports.addPath = addPath;\n\n/**\n * @param immSet\n * @param urlPath\n * @returns {*}\n */\nfunction removePath(immSet, urlPath) {\n    return immSet.remove(url.parse(urlPath).path);\n}\n\nmodule.exports.removePath = removePath;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/plugins/plugins.plugin.js":"const PLUGIN_NAME = \"Plugins\";\n\n/**\n * @type {{plugin: Function, plugin:name: string, markup: string}}\n */\nmodule.exports = {\n    /**\n     * @param ui\n     * @param bs\n     */\n    \"plugin\": function (ui, bs) {\n\n        ui.listen(\"plugins\", {\n\n            \"set\": function (data) {\n                bs.events.emit(\"plugins:configure\", data);\n            },\n\n            \"setMany\": function (data) {\n\n                if (data.value !== true) {\n                    data.value = false;\n                }\n\n                bs.getUserPlugins()\n                    .filter(function (item) {\n                        return item.name !== \"UI    \"; // todo dupe code server/client\n                    })\n                    .forEach(function (item) {\n                        item.active = data.value;\n                        bs.events.emit(\"plugins:configure\", item);\n                    });\n            }\n        });\n    },\n    /**\n     * Hooks\n     */\n    \"hooks\": {\n        \"markup\": fileContent(\"plugins.html\"),\n        \"client:js\": fileContent(\"/plugins.client.js\"),\n        \"templates\": [\n            //getPath(\"plugins.directive.html\")\n        ],\n        \"page\": {\n            path: \"/plugins\",\n            title: PLUGIN_NAME,\n            template: \"plugins.html\",\n            controller: PLUGIN_NAME + \"Controller\",\n            order: 4,\n            icon: \"plug\"\n        }\n    },\n    /**\n     * Plugin name\n     */\n    \"plugin:name\": PLUGIN_NAME\n};\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction getPath (filepath) {\n    return require(\"path\").join(__dirname, filepath);\n}\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction fileContent (filepath) {\n    return require(\"fs\").readFileSync(getPath(filepath), \"utf-8\");\n}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/remote-debug/remote-debug.plugin.js":"var weinre         = require(\"./weinre\");\n//var compression     = require(\"./compression\");\n//var noCachePlugin   = require(\"./no-cache\");\nvar overlayPlugin  = require(\"./overlay-grid/overlay-grid\");\nvar clientFiles    = require(\"./client-files\");\n\nconst PLUGIN_NAME  = \"Remote Debug\";\n\n/**\n * @type {{plugin: Function, plugin:name: string, markup: string}}\n */\nmodule.exports = {\n    /**\n     * @param ui\n     * @param bs\n     */\n    \"plugin\": function (ui, bs) {\n\n        if (bs.options.get(\"scheme\") === \"https\") {\n            ui.setMany(function (item) {\n                item.deleteIn([\"clientFiles\", \"weinre\"]);\n            });\n        } else {\n            ui.weinre = weinre.init(ui);\n        }\n\n        ui.overlayGrid = overlayPlugin.init(ui, bs);\n\n        //ui.noCache     = noCachePlugin.init(ui, bs);\n        //ui.compression = compression.init(ui, bs);\n\n        /**\n         * Listen for file events\n         */\n        ui.listen(\"remote-debug:files\", {\n            \"enableFile\": function (file) {\n                ui.enableElement(file);\n            },\n            \"disableFile\": function (file) {\n                ui.disableElement(file);\n            }\n        });\n\n        /**\n         * Listen for weinre toggles\n         */\n        ui.listen(\"remote-debug:weinre\", ui.weinre);\n\n        /**\n         * Listen for overlay-grid events\n         */\n        ui.listen(\"remote-debug:overlay-grid\", ui.overlayGrid);\n    },\n    /**\n     * Hooks\n     */\n    \"hooks\": {\n        \"markup\": fileContent(\"remote-debug.html\"),\n        \"client:js\": [\n            fileContent(\"/remote-debug.client.js\"),\n            fileContent(\"/overlay-grid/overlay-grid.client.js\")\n        ],\n        \"templates\": [\n            getPath(\"/overlay-grid/overlay-grid.html\")\n        ],\n        \"page\": {\n            path: \"/remote-debug\",\n            title: PLUGIN_NAME,\n            template: \"remote-debug.html\",\n            controller: PLUGIN_NAME.replace(\" \", \"\") + \"Controller\",\n            order: 4,\n            icon: \"bug\"\n        },\n        elements: clientFiles.files\n    },\n    /**\n     * Plugin name\n     */\n    \"plugin:name\": PLUGIN_NAME\n};\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction getPath (filepath) {\n    return require(\"path\").join(__dirname, filepath);\n}\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction fileContent (filepath) {\n    return require(\"fs\").readFileSync(getPath(filepath), \"utf-8\");\n}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/remote-debug/weinre.js":"var url            = require(\"url\");\nvar Immutable      = require(\"immutable\");\nvar path           = require(\"path\");\n\nvar weinreApp;\n\nconst WEINRE_NAME      = \"weinre-debug\";\nconst WEINRE_ID        = \"#browsersync\";\nconst WEINRE_ELEM_ID   = \"__browser-sync-weinre__\";\n\nvar weinreTargetUrl    = {\n    protocol: \"http:\",\n    pathname: \"/target/target-script-min.js\",\n    hash: WEINRE_ID\n};\n\nvar weinreClientUrl    = {\n    protocol: \"http:\",\n    pathname: \"/client/\",\n    hash: WEINRE_ID\n};\n\n/**\n * Prepare weinre for later possible use.\n * @param ui\n */\nfunction init (ui) {\n\n    var hostUrl    = getHostUrl(ui, ui.bs);\n    var weinrePort = ui.getOptionIn([\"weinre\", \"port\"]);\n\n    weinreTargetUrl.hostname = hostUrl.hostname;\n    weinreClientUrl.hostname = hostUrl.hostname;\n    weinreClientUrl.port     = weinrePort;\n    weinreTargetUrl.port     = weinrePort;\n\n    ui.setOption(WEINRE_NAME, Immutable.fromJS({\n        name:  WEINRE_NAME,\n        active: false,\n        url:    false,\n        targetUrl: url.format(weinreTargetUrl),\n        clientUrl: url.format(weinreClientUrl),\n        port: weinrePort\n    }));\n\n    setWeinreClientUrl(ui, url.format(weinreClientUrl));\n\n    var methods = {\n        toggle: function (data) {\n            toggleWeinre(ui.socket, ui.clients, ui, ui.bs, data);\n        },\n        event: function (event) {\n            methods[event.event](event.data);\n        }\n    };\n\n    return methods;\n}\n\n/**\n * Get a suitable host URL for weinre\n * @param ui\n * @param bs\n * @returns {*}\n */\nfunction getHostUrl(ui, bs) {\n\n    var url = bs.getOptionIn([\"urls\", \"external\"]);\n\n    if (!url) {\n        url = bs.getOptionIn([\"urls\", \"local\"]);\n    }\n\n    return require(\"url\").parse(url);\n}\n\n\n/**\n * @param ui\n * @param weinreClientUrl\n */\nfunction setWeinreClientUrl(ui, weinreClientUrl) {\n    var weinre = ui.options.getIn([\"clientFiles\", \"weinre\"]).toJS();\n    ui.setMany(function (item) {\n        item.setIn([\"clientFiles\", \"weinre\", \"hidden\"], weinre.hidden.replace(\"%s\", weinreClientUrl));\n        return item;\n    });\n}\n\n/**\n * @param socket\n * @param clients\n * @param ui\n * @param bs\n * @param value\n */\nfunction toggleWeinre (socket, clients, ui, bs, value) {\n\n    if (value !== true) {\n        value = false;\n    }\n\n    if (value) {\n\n        var _debugger = enableWeinre(ui, bs);\n\n        // set the state of weinre\n        ui.setMany(function (item) {\n            item.setIn([WEINRE_NAME, \"active\"], true);\n            item.setIn([WEINRE_NAME, \"url\"], _debugger.url);\n            item.setIn([WEINRE_NAME, \"active\"], true);\n            item.setIn([\"clientFiles\", \"weinre\", \"active\"], true);\n        }, {silent: true});\n\n\n        // Let the UI know about it\n        socket.emit(\"ui:weinre:enabled\", _debugger);\n\n        var fileitem = {\n            type: \"js\",\n            src: ui.getOptionIn([WEINRE_NAME, \"targetUrl\"]),\n            id: WEINRE_ELEM_ID\n        };\n\n        // Add the element to all clients\n        ui.addElement(clients, fileitem);\n\n        // Save for page refreshes\n        //clientScripts = clientScripts.set(\"weinre\", fileitem);\n\n    } else {\n\n        // Stop it\n        disableWeinre(ui, bs);\n\n        //clientScripts = clientScripts.remove(\"weinre\");\n\n        // Reset the state\n        ui.setOptionIn([WEINRE_NAME, \"active\"], false, {silent: false}); // Force a reload here\n        ui.setOptionIn([\"clientFiles\", \"weinre\", \"active\"], false); // Force a reload here\n\n        // Let the UI know\n        socket.emit(\"ui:weinre:disabled\");\n\n        // Reload all browsers to remove weinre elements/JS\n        clients.emit(\"browser:reload\");\n\n    }\n}\n\n/**\n * Enable the debugger\n * @param ui\n * @param bs\n * @returns {{url: string, port: number}}\n */\nfunction enableWeinre (ui, bs) {\n\n    if (weinreApp && typeof weinreApp.destroy === \"function\") {\n        weinreApp.destroy();\n        weinreApp = undefined;\n    }\n\n    var port     = ui.getOptionIn([WEINRE_NAME, \"port\"]);\n\n    var logger   = require(path.join(path.dirname(require.resolve(\"weinre\")), \"utils.js\"));\n\n    logger.log = function (message) {\n        ui.logger.debug(\"[weinre]: %s\", message);\n    };\n\n    var weinre   = require(\"weinre\");\n    var external = getHostUrl(ui, bs);\n\n    weinreApp = weinre.run({\n        httpPort: port,\n        boundHost: external.hostname,\n        verbose: false,\n        debug: false,\n        readTimeout: 5,\n        deathTimeout: 15 });\n\n    require(\"server-destroy\")(weinreApp);\n\n    return ui.options.get(WEINRE_NAME).toJS();\n}\n\n/**\n * @param ui\n * @returns {any|*}\n */\nfunction disableWeinre (ui) {\n    if (weinreApp) {\n        weinreApp.close();\n        weinreApp = false;\n    }\n    return ui.options.get(WEINRE_NAME).toJS();\n}\n\nmodule.exports.init         = init;\nmodule.exports.toggleWeinre = toggleWeinre;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/remote-debug/overlay-grid/overlay-grid.js":"var Immutable = require(\"immutable\");\nvar fs        = require(\"fs\");\nvar path      = require(\"path\");\nvar baseHorizontal = fs.readFileSync(path.resolve(__dirname, \"css/grid-overlay-horizontal.css\"), \"utf8\");\nvar baseVertical   = fs.readFileSync(path.resolve(__dirname, \"css/grid-overlay-vertical.css\"), \"utf8\");\n\nfunction template (string, obj) {\n    obj = obj || {};\n    return string.replace(/\\{\\{(.+?)\\}\\}/g, function () {\n        if (obj[arguments[1]]) {\n           return obj[arguments[1]];\n        }\n        return \"\";\n    });\n}\n\nfunction getCss(opts) {\n\n    var base = opts.selector + \" {position:relative;}\";\n\n    if (opts.horizontal) {\n        base += baseHorizontal;\n    }\n\n    if (opts.vertical) {\n        base += baseVertical;\n    }\n\n    return template(base, opts);\n}\n\nmodule.exports.init = function (ui) {\n\n    const TRANSMIT_EVENT = \"ui:remote-debug:css-overlay-grid\";\n    const READY_EVENT    = \"ui:remote-debug:css-overlay-grid:ready\";\n    const OPT_PATH       = [\"remote-debug\", \"overlay-grid\"];\n\n    var defaults = {\n        offsetY:  \"0\",\n        offsetX:  \"0\",\n        size:     \"16px\",\n        selector: \"body\",\n        color:    \"rgba(0, 0, 0, .2)\",\n        horizontal: true,\n        vertical: true\n    };\n\n    ui.clients.on(\"connection\", function (client) {\n        client.on(READY_EVENT, function () {\n            client.emit(TRANSMIT_EVENT, {\n                innerHTML: getCss(ui.options.getIn(OPT_PATH).toJS())\n            });\n        });\n    });\n\n    ui.setOptionIn(OPT_PATH, Immutable.Map({\n        name: \"overlay-grid\",\n        title: \"Overlay CSS Grid\",\n        active: false,\n        tagline: \"Add an adjustable CSS overlay grid to your webpage\",\n        innerHTML: \"\"\n    }).merge(defaults));\n\n\n    var methods = {\n        toggle: function (value) {\n            if (value !== true) {\n                value = false;\n            }\n            if (value) {\n                ui.setOptionIn(OPT_PATH.concat(\"active\"), true);\n                ui.enableElement({name: \"overlay-grid-js\"});\n            } else {\n                ui.setOptionIn(OPT_PATH.concat(\"active\"), false);\n                ui.disableElement({name: \"overlay-grid-js\"});\n                ui.clients.emit(\"ui:element:remove\", {id: \"__bs_overlay-grid-styles__\"});\n            }\n        },\n        adjust: function (data) {\n\n            ui.setOptionIn(OPT_PATH, ui.getOptionIn(OPT_PATH).merge(data));\n\n            ui.clients.emit(TRANSMIT_EVENT, {\n                innerHTML: getCss(ui.options.getIn(OPT_PATH).toJS())\n            });\n        },\n        \"toggle:axis\": function (item) {\n\n            ui.setOptionIn(OPT_PATH.concat([item.axis]), item.value);\n\n            ui.clients.emit(TRANSMIT_EVENT, {\n                innerHTML: getCss(ui.options.getIn(OPT_PATH).toJS())\n            });\n        },\n        event: function (event) {\n            methods[event.event](event.data);\n        }\n    };\n\n    return methods;\n};","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/remote-debug/client-files.js":"var files = [\n    {\n        name: \"weinre\",\n        context: \"remote-debug\",\n        active: false,\n        title: \"Remote Debugger (weinre)\",\n        tagline: \"\",\n        hidden: \"<a href=\\\"%s\\\" target=\\\"_blank\\\">Access remote debugger (opens in a new tab)</a></p>\"\n    },\n    {\n        type: \"css\",\n        context: \"remote-debug\",\n        id: \"__browser-sync-pesticide__\",\n        active: false,\n        file: __dirname + \"/css/pesticide.min.css\",\n        title: \"CSS Outlining\",\n        served: false,\n        name: \"pesticide\",\n        src: \"/browser-sync/pesticide.css\",\n        tagline: \"Add simple CSS outlines to all elements. (powered by <a href=\\\"http://pesticide.io\\\" target=\\\"_blank\\\">Pesticide.io</a>)\",\n        hidden: \"\"\n    },\n    {\n        type: \"css\",\n        context: \"remote-debug\",\n        id: \"__browser-sync-pesticidedepth__\",\n        active: false,\n        file: __dirname + \"/css/pesticide-depth.css\",\n        title: \"CSS Depth Outlining\",\n        served: false,\n        name: \"pesticide-depth\",\n        src: \"/browser-sync/pesticide-depth.css\",\n        tagline: \"Add CSS box-shadows to all elements. (powered by <a href=\\\"http://pesticide.io\\\" target=\\\"_blank\\\">Pesticide.io</a>)\",\n        hidden: \"\"\n    },\n    {\n        type:    \"js\",\n        context: \"n/a\",\n        id:      \"__browser-sync-gridoverlay__\",\n        active:  false,\n        file:    __dirname + \"/overlay-grid/js/grid-overlay.js\",\n        served:  false,\n        name:    \"overlay-grid-js\",\n        src:     \"/browser-sync/grid-overlay-js.js\"\n    }\n];\n\nmodule.exports.files = files;","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/help/help.plugin.js":"const PLUGIN_NAME = \"Help / About\";\n\n/**\n * @type {{plugin: Function, plugin:name: string, markup: string}}\n */\nmodule.exports = {\n    /**\n     * Plugin init\n     */\n    \"plugin\": function () {},\n    /**\n     * Hooks\n     */\n    \"hooks\": {\n        \"markup\": fileContent(\"/../../../static/content/help.content.html\"),\n        \"client:js\": fileContent(\"/help.client.js\"),\n        \"templates\": [\n            getPath(\"/help.directive.html\")\n        ],\n        \"page\": {\n            path: \"/help\",\n            title: PLUGIN_NAME,\n            template: \"help.html\",\n            controller: \"HelpAboutController\",\n            order: 6,\n            icon: \"help\"\n        }\n    },\n    /**\n     * Plugin name\n     */\n    \"plugin:name\": PLUGIN_NAME\n};\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction getPath (filepath) {\n    return require(\"path\").join(__dirname, filepath);\n}\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction fileContent (filepath) {\n    return require(\"fs\").readFileSync(getPath(filepath), \"utf-8\");\n}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/connections/connections.plugin.js":"var connections = require(\"./lib/connections\");\n\nconst PLUGIN_NAME = \"Connections\";\n\n/**\n * @type {{plugin: Function, plugin:name: string, markup: string}}\n */\nmodule.exports = {\n    /**\n     * @param {UI} ui\n     * @param {BrowserSync} bs\n     */\n    \"plugin\": function (ui, bs) {\n        connections.init(ui, bs);\n    },\n    /**\n     * Hooks\n     */\n    \"hooks\": {\n        \"client:js\": fileContent(\"/connections.client.js\"),\n        \"templates\": [\n            getPath(\"/connections.directive.html\")\n        ]\n    },\n    /**\n     * Plugin name\n     */\n    \"plugin:name\": PLUGIN_NAME\n};\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction getPath (filepath) {\n    return require(\"path\").join(__dirname, filepath);\n}\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction fileContent (filepath) {\n    return require(\"fs\").readFileSync(getPath(filepath), \"utf-8\");\n}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/connections/lib/connections.js":"var Immutable = require(\"immutable\");\n\n/**\n * Track connected clients\n * @param {UI} ui\n * @param {BrowserSync} bs\n */\nmodule.exports.init = function (ui, bs) {\n\n    var uaParser = new bs.utils.UAParser();\n\n    var currentConnections = [];\n\n    ui.clients.on(\"connection\", function (client) {\n        client.on(\"client:heartbeat\", function (data) {\n            var match;\n            if (currentConnections.some(function (item, index) {\n                    if (item.id === client.id) {\n                        match = index;\n                        return true;\n                    }\n                    return false;\n                })) {\n                if (typeof match === \"number\") {\n                    currentConnections[match].timestamp = new Date().getTime();\n                    currentConnections[match].data = data;\n                }\n            } else {\n                currentConnections.push({\n                    id: client.id,\n                    timestamp: new Date().getTime(),\n                    browser: uaParser.setUA(client.handshake.headers[\"user-agent\"]).getBrowser(),\n                    data: data\n                });\n            }\n        });\n    });\n\n    var registry;\n    var temp;\n    var initialSent;\n\n    var int = setInterval(function () {\n\n        var sockets = ui.clients.sockets;\n        var keys = Object.keys(sockets);\n\n        if (keys.length) {\n            temp = Immutable.List(keys.map(function (clientKey) {\n                var currentClient = sockets[clientKey];\n                return Immutable.fromJS({\n                    id: currentClient.id,\n                    browser: uaParser.setUA(currentClient.handshake.headers[\"user-agent\"]).getBrowser()\n                });\n            }));\n            if (!registry) {\n                registry = temp;\n                sendUpdated(ui.socket, decorateClients(registry.toJS(), currentConnections));\n            } else {\n                if (Immutable.is(registry, temp)) {\n                    if (!initialSent) {\n                        sendUpdated(ui.socket, decorateClients(registry.toJS(), currentConnections));\n                        initialSent = true;\n                    }\n                } else {\n                    registry = temp;\n                    sendUpdated(ui.socket, decorateClients(registry.toJS(), currentConnections));\n                }\n            }\n        } else {\n            sendUpdated(ui.socket, []);\n        }\n\n    }, 1000);\n\n    bs.registerCleanupTask(function () {\n        clearInterval(int);\n    });\n};\n\n\n/**\n * Use heart-beated data to decorate clients\n * @param clients\n * @param clientsInfo\n * @returns {*}\n */\nfunction decorateClients(clients, clientsInfo) {\n    return clients.map(function (item) {\n        clientsInfo.forEach(function (client) {\n            if (client.id === item.id) {\n                item.data = client.data;\n                return false;\n            }\n        });\n        return item;\n    });\n}\n\n/**\n * @param socket\n * @param connectedClients\n */\nfunction sendUpdated(socket, connectedClients) {\n    socket.emit(\"ui:connections:update\", connectedClients);\n}\n\n/**\n * @param clients\n * @param data\n */\n//function highlightClient (clients, data) {\n//    var socket = getClientById(clients, data.id);\n//    if (socket) {\n//        socket.emit(\"highlight\");\n//    }\n//}\n\n/**\n * @param clients\n * @param id\n */\n//function getClientById (clients, id) {\n//    var match;\n//    clients.sockets.some(function (item, i) {\n//        if (item.id === id) {\n//            match = clients.sockets[i];\n//            return true;\n//        }\n//    });\n//    return match;\n//}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/network-throttle/network-throttle.plugin.js":"var networkThrottle = require(\"./network-throttle\");\n\nconst PLUGIN_NAME = \"Network Throttle\";\n\n/**\n * @type {{plugin: Function, plugin:name: string, markup: string}}\n */\nmodule.exports = {\n    /**\n     * Plugin init\n     */\n    \"plugin\": function (ui, bs) {\n        ui.throttle = networkThrottle.init(ui, bs);\n        ui.listen(\"network-throttle\", ui.throttle);\n    },\n\n    /**\n     * Hooks\n     */\n    \"hooks\": {\n        \"markup\": fileContent(\"/network-throttle.html\"),\n        \"client:js\": [fileContent(\"/network-throttle.client.js\")],\n        \"templates\": [],\n        \"page\": {\n            path: \"/network-throttle\",\n            title: PLUGIN_NAME,\n            template: \"network-throttle.html\",\n            controller: \"NetworkThrottleController\",\n            order: 5,\n            icon: \"time\"\n        }\n    },\n    /**\n     * Plugin name\n     */\n    \"plugin:name\": PLUGIN_NAME\n};\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction getPath (filepath) {\n    return require(\"path\").join(__dirname, filepath);\n}\n\n/**\n * @param filepath\n * @returns {*}\n */\nfunction fileContent (filepath) {\n    return require(\"fs\").readFileSync(getPath(filepath));\n}","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync-ui/lib/plugins/network-throttle/network-throttle.js":"var Immutable = require(\"immutable\");\n\nmodule.exports.init = function (ui) {\n\n    var optPath = [\"network-throttle\"];\n    var serverOptPath = optPath.concat([\"servers\"]);\n    ui.servers  = {};\n\n    ui.setOptionIn(optPath, Immutable.fromJS({\n        name: \"network-throttle\",\n        title: \"Network Throttle\",\n        active: false,\n        targets: require(\"./targets\")\n    }));\n\n    ui.setOptionIn(serverOptPath, Immutable.Map({}));\n\n    /**\n     * @param input\n     * @returns {number}\n     */\n    function getPortArg(input) {\n        input = input.trim();\n        if (input.length && input.match(/\\d{3,5}/)) {\n            input = parseInt(input, 10);\n        } else {\n            input = ui.bs.options.get(\"port\") + 1;\n        }\n        return input;\n    }\n\n    /**\n     * @returns {string}\n     */\n    function getTargetUrl() {\n        return require(\"url\").parse(ui.bs.options.getIn([\"urls\", \"local\"]));\n    }\n\n    var methods = {\n        /**\n         * @param data\n         */\n        \"server:create\": function (data) {\n\n            data.port = getPortArg(data.port);\n            data.cb   = data.cb || function () { /* noop */};\n\n            /**\n             * @param opts\n             */\n            function saveThrottleInfo (opts) {\n\n                var urls = getUrls(ui.bs.options.set(\"port\", opts.port).toJS());\n\n                ui.setOptionIn(serverOptPath.concat([opts.port]), Immutable.fromJS({\n                    urls: urls,\n                    speed: opts.speed\n                }));\n\n                setTimeout(function () {\n\n                    ui.socket.emit(\"ui:network-throttle:update\", {\n                        servers: ui.getOptionIn(serverOptPath).toJS(),\n                        event: \"server:create\"\n                    });\n\n                    ui.servers[opts.port] = opts.server;\n\n                    data.cb(null, opts);\n\n                }, 300);\n\n            }\n\n            /**\n             * @param err\n             * @param port\n             */\n            function createThrottle (err, port) {\n\n                var target = getTargetUrl();\n\n                var args = {\n                    port: port,\n                    target: target,\n                    speed: data.speed\n                };\n\n                if (ui.bs.getOption(\"scheme\") === \"https\") {\n                    var httpsOpts = require(\"browser-sync/lib/server/utils\").getHttpsOptions(ui.bs.options);\n                    args.key  = httpsOpts.key;\n                    args.cert = httpsOpts.cert;\n                }\n\n                args.server = require(\"./throttle-server\")(args);\n                require('server-destroy')(args.server);\n                args.server.listen(port);\n\n                saveThrottleInfo(args);\n            }\n\n            /**\n             * Try for a free port\n             */\n            ui.bs.utils.portscanner.findAPortNotInUse(data.port, data.port + 100, \"127.0.0.1\", function (err, port) {\n                if (err) {\n                    return createThrottle(err);\n                } else {\n                    createThrottle(null, port);\n                }\n            });\n        },\n        /**\n         * @param data\n         */\n        \"server:destroy\": function (data) {\n            if (ui.servers[data.port]) {\n                ui.servers[data.port].destroy();\n                ui.setMany(function (item) {\n                    item.deleteIn(serverOptPath.concat([parseInt(data.port, 10)]));\n                });\n                delete ui.servers[data.port];\n            }\n            ui.socket.emit(\"ui:network-throttle:update\", {\n                servers: ui.getOptionIn(serverOptPath).toJS(),\n                event: \"server:destroy\"\n            });\n        },\n        /**\n         * @param event\n         */\n        event: function (event) {\n            methods[event.event](event.data);\n        }\n    };\n\n    return methods;\n};\n\n/**\n * Get local + external urls with a different port\n * @param opts\n * @returns {List<T>|List<any>}\n */\nfunction getUrls (opts) {\n\n    var list    = [];\n\n    var bsLocal = require(\"url\").parse(opts.urls.local);\n\n    list.push([bsLocal.protocol + \"//\", bsLocal.hostname, \":\", opts.port].join(\"\"));\n\n    if (opts.urls.external) {\n        var external = require(\"url\").parse(opts.urls.external);\n        list.push([bsLocal.protocol + \"//\", external.hostname, \":\", opts.port].join(\"\"));\n    }\n\n    return Immutable.List(list);\n}\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/public/public-utils.js":"\"use strict\";\n\nvar _ = require(\"../../lodash.custom\");\n\nmodule.exports = {\n    /**\n     * Emit the internal `file:change` event\n     * @param {EventEmitter} emitter\n     * @param {string} path\n     * @param {boolean} [log]\n     */\n    emitChangeEvent: function emitChangeEvent (emitter, path, log) {\n        emitter.emit(\"file:changed\", {\n            path:      path,\n            log:       log,\n            namespace: \"core\",\n            event:     \"change\"\n        });\n    },\n    /**\n     * Emit the internal `browser:reload` event\n     * @param {EventEmitter} emitter\n     */\n    emitBrowserReload: function emitChangeEvent (emitter) {\n        emitter.emit(\"_browser:reload\");\n    },\n    /**\n     * Emit the internal `stream:changed` event\n     * @param {EventEmitter} emitter\n     * @param {Array} changed\n     */\n    emitStreamChangedEvent: function (emitter, changed) {\n        emitter.emit(\"stream:changed\", {changed: changed});\n    },\n    /**\n     * This code handles the switch between .reload & .stream\n     * since 2.6.0\n     * @param name\n     * @param args\n     * @returns {boolean}\n     */\n    isStreamArg: function (name, args) {\n\n        if (name === \"stream\") {\n            return true;\n        }\n\n        if (name !== \"reload\") {\n            return false;\n        }\n\n        var firstArg = args[0];\n\n        /**\n         * If here, it's reload with args\n         */\n        if (_.isObject(firstArg)) {\n            if (!Array.isArray(firstArg) && Object.keys(firstArg).length) {\n                return firstArg.stream === true;\n            }\n        }\n\n        return false;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/bin/browser-sync.js":"#!/usr/bin/env node\nvar startOpts  = require(\"../lib/cli/opts.start.json\");\nvar reloadOpts = require(\"../lib/cli/opts.reload.json\");\nvar recipeOpts = require(\"../lib/cli/opts.recipe.json\");\nvar pkg        = require(\"../package.json\");\nvar utils      = require(\"../lib/utils\");\n\n/**\n * Handle cli input\n */\nif (!module.parent) {\n    var yargs = require(\"yargs\")\n        .command(\"start\", \"Start the server\")\n        .command(\"init\", \"Create a configuration file\")\n        .command(\"reload\", \"Send a reload event over HTTP protocol\")\n        .command(\"recipe\", \"Generate the files for a recipe\")\n        .version(function () {\n            return pkg.version;\n        })\n        .epilogue(\"For help running a certain command, type <command> --help\\neg: $0 start --help\");\n\n    var argv    = yargs.argv;\n    var command = argv._[0];\n    var valid   = [\"start\", \"init\", \"reload\", \"recipe\"];\n\n    if (valid.indexOf(command) > -1) {\n        handleIncoming(command, yargs.reset());\n    } else {\n        yargs.showHelp();\n    }\n}\n\n/**\n * @param {{cli: object, [whitelist]: array, [cb]: function}} opts\n * @returns {*}\n */\nfunction handleCli(opts) {\n\n    opts.cb = opts.cb || utils.defaultCallback;\n    return require(\"../lib/cli/command.\" + opts.cli.input[0])(opts);\n}\n\nmodule.exports = handleCli;\n\n/**\n * @param {string} command\n * @param {object} yargs\n */\nfunction handleIncoming(command, yargs) {\n    var out;\n    if (command === \"start\") {\n        out = yargs\n            .usage(\"Usage: $0 start [options]\")\n            .options(startOpts)\n            .example(\"$0 start -s app\", \"- Use the App directory to serve files\")\n            .example(\"$0 start -p www.bbc.co.uk\", \"- Proxy an existing website\")\n            .help()\n            .argv;\n    }\n    if (command === \"init\") {\n        out = yargs\n            .usage(\"Usage: $0 init\")\n            .example(\"$0 init\")\n            .help()\n            .argv;\n    }\n    if (command === \"reload\") {\n        out = yargs\n            .usage(\"Usage: $0 reload\")\n            .options(reloadOpts)\n            .example(\"$0 reload\")\n            .example(\"$0 reload --port 4000\")\n            .help()\n            .argv;\n    }\n    if (command === \"recipe\") {\n        out = yargs\n            .usage(\"Usage: $0 recipe <recipe-name>\")\n            .option(recipeOpts)\n            .example(\"$0 recipe ls\", \"list the recipes\")\n            .example(\"$0 recipe gulp.sass\", \"use the gulp.sass recipe\")\n            .help()\n            .argv;\n    }\n\n    if (out.help) {\n        return yargs.showHelp();\n    }\n\n    handleCli({cli: {flags: out, input: out._}});\n}\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/args.js":"\"use strict\";\n\n/**\n * The purpose of this function is\n * to handle back-backwards compatibility\n * @param {Object} args\n * @returns {{config: {}, cb: *}}\n */\nmodule.exports = function (args) {\n\n    var config = {};\n    var cb;\n\n    switch (args.length) {\n\n        case 1 :\n\n            if (isFilesArg(args[0])) {\n\n                config.files = args[0];\n\n            } else if (typeof args[0] === \"function\") {\n\n                cb = args[0];\n\n            } else {\n\n                config = args[0];\n\n            }\n\n            break;\n\n        case 2 :\n\n            // if second is a function, first MUST be config\n            if (typeof args[1] === \"function\") {\n\n                config = args[0] || {};\n                cb = args[1];\n\n            } else {\n\n                if (args[1] === null || args[1] === undefined) {\n\n                    config = args[0];\n\n                } else {\n\n                    // finally, second arg could be a plain object for config\n                    config = args[1] || {};\n\n                    if (!config.files) {\n                        config.files = args[0];\n                    }\n                }\n\n            }\n\n            break;\n\n        case 3 :\n\n            config = args[1] || {};\n\n            if (!config.files) {\n                config.files = args[0];\n            }\n\n            cb = args[2];\n    }\n\n    return {\n        config: config,\n        cb: cb\n    };\n};\n\n/**\n * Files args were only ever strings or arrays\n * @param arg\n * @returns {*|boolean}\n */\nfunction isFilesArg (arg) {\n    return Array.isArray(arg) || typeof arg === \"string\";\n}\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/default-config.js":"\"use strict\";\n/**\n * @module BrowserSync.options\n */\nmodule.exports = {\n\n    /**\n     * Browsersync includes a user-interface that is accessed via a separate port.\n     * The UI allows to controls all devices, push sync updates and much more.\n     * @property ui\n     * @type Object\n     * @param {Number} [port=3001]\n     * @param {Number} [weinre.port=8080]\n     * @since 2.0.0\n     * @default false\n     */\n    ui: {\n        port: 3001,\n        weinre: {\n            port: 8080\n        }\n    },\n\n    /**\n     * Browsersync can watch your files as you work. Changes you make will either\n     * be injected into the page (CSS & images) or will cause all browsers to do\n     * a full-page refresh.\n     * @property files\n     * @type Array|String\n     * @default false\n     */\n    files: false,\n\n    /**\n     * Specify which file events to respond to.\n     * Available events: `add`, `change`, `unlink`, `addDir`, `unlinkDir`\n     * @property watchEvents\n     * @type Array\n     * @default [\"change\"]\n     * @since 2.18.8\n     */\n    watchEvents: [\"change\"],\n\n    /**\n     * File watching options that get passed along to [Chokidar](https://github.com/paulmillr/chokidar).\n     * Check their docs for available options\n     * @property watchOptions\n     * @type Object\n     * @default undefined\n     * @since 2.6.0\n     */\n    watchOptions: {\n        ignoreInitial: true\n        /*\n         persistent: true,\n\n         ignored: '*.txt',\n         followSymlinks: true,\n         cwd: '.',\n\n         usePolling: true,\n         alwaysStat: false,\n         depth: undefined,\n         interval: 100,\n\n         ignorePermissionErrors: false,\n         atomic: true\n         */\n    },\n\n    /**\n     * Use the built-in static server for basic HTML/JS/CSS websites.\n     * @property server\n     * @type Object|Boolean\n     * @default false\n     */\n    server: false,\n\n    /**\n     * Proxy an EXISTING vhost. Browsersync will wrap your vhost with a proxy URL to view your site.\n     * @property proxy\n     * @type String|Object|Boolean\n     * @param {String} [target]\n     * @param {Boolean} [ws] - Enable websocket proxying\n     * @param {Function|Array} [middleware]\n     * @param {Function} [reqHeaders]\n     * @param {Array} [proxyReq]\n     * @param {Array} [proxyRes]\n     * @default false\n     */\n    proxy: false,\n\n    /**\n     * @property port\n     * @type Number\n     * @default 3000\n     */\n    port: 3000,\n\n    /**\n     * @property middleware\n     * @type Function|Array\n     * @default false\n     */\n    middleware: false,\n\n    /**\n     * Add additional directories from which static\n     * files should be served. Should only be used in `proxy` or `snippet`\n     * mode.\n     * @property serveStatic\n     * @type Array\n     * @default []\n     * @since 2.8.0\n     */\n    serveStatic: [],\n\n    /**\n     * Options that are passed to the serve-static middleware\n     * when you use the string[] syntax: eg: `serveStatic: ['./app']`. Please see\n     * [serve-static](https://github.com/expressjs/serve-static) for details\n     *\n     * @property serveStaticOptions\n     * @type Object\n     * @since 2.17.0\n     */\n\n    /**\n     * Enable https for localhost development. **Note** - this is not needed for proxy\n     * option as it will be inferred from your target url.\n     * @property https\n     * @type Boolean\n     * @default undefined\n     * @since 1.3.0\n     */\n\n    /**\n     * Override http module to allow using 3rd party server modules (such as http2)\n     * @property httpModule\n     * @type string\n     * @default undefined\n     * @since 2.18.0\n     */\n\n    /**\n     * Clicks, Scrolls & Form inputs on any device will be mirrored to all others.\n     * @property ghostMode\n     * @param {Boolean} [clicks=true]\n     * @param {Boolean} [scroll=true]\n     * @param {Boolean} [forms=true]\n     * @param {Boolean} [forms.submit=true]\n     * @param {Boolean} [forms.inputs=true]\n     * @param {Boolean} [forms.toggles=true]\n     * @type Object\n     */\n    ghostMode: {\n        clicks: true,\n        scroll: true,\n        forms: {\n            submit: true,\n            inputs: true,\n            toggles: true\n        }\n    },\n\n    /**\n     * Can be either \"info\", \"debug\", \"warn\", or \"silent\"\n     * @property logLevel\n     * @type String\n     * @default info\n     */\n    logLevel: \"info\",\n\n    /**\n     * Change the console logging prefix. Useful if you're creating your\n     * own project based on Browsersync\n     * @property logPrefix\n     * @type String\n     * @default BS\n     * @since 1.5.1\n     */\n    logPrefix: \"BS\",\n\n    /**\n     * @property logConnections\n     * @type Boolean\n     * @default false\n     */\n    logConnections: false,\n\n    /**\n     * @property logFileChanges\n     * @type Boolean\n     * @default true\n     */\n    logFileChanges: true,\n\n    /**\n     * Log the snippet to the console when you're in snippet mode (no proxy/server)\n     * @property logSnippet\n     * @type: Boolean\n     * @default true\n     * @since 1.5.2\n     */\n    logSnippet: true,\n\n    /**\n     * You can control how the snippet is injected\n     * onto each page via a custom regex + function.\n     * You can also provide patterns for certain urls\n     * that should be ignored from the snippet injection.\n     * @property snippetOptions\n     * @since 2.0.0\n     * @param {Boolean} [async] - should the script tags have the async attribute?\n     * @param {Array} [blacklist]\n     * @param {Array} [whitelist]\n     * @param {RegExp} [rule.match=/$/]\n     * @param {Function} [rule.fn=Function]\n     * @type Object\n     */\n    snippetOptions: {\n        async: true,\n        whitelist: [],\n        blacklist: [],\n        rule: {\n            match: /<body[^>]*>/i,\n            fn: function (snippet, match) {\n                return match + snippet;\n            }\n        }\n    },\n\n    /**\n     * Add additional HTML rewriting rules.\n     * @property rewriteRules\n     * @since 2.4.0\n     * @type Array\n     * @default false\n     */\n    rewriteRules: [],\n\n    /**\n     * @property tunnel\n     * @type String|Boolean\n     * @default null\n     */\n\n    /**\n     * Some features of Browsersync (such as `xip` & `tunnel`) require an internet connection, but if you're\n     * working offline, you can reduce start-up time by setting this option to `false`\n     * @property online\n     * @type Boolean\n     * @default undefined\n     */\n\n    /**\n     * Decide which URL to open automatically when Browsersync starts. Defaults to \"local\" if none set.\n     * Can be true, `local`, `external`, `ui`, `ui-external`, `tunnel` or `false`\n     * @property open\n     * @type Boolean|String\n     * @default true\n     */\n    open: \"local\",\n\n    /**\n     * @property browser\n     * @type String|Array\n     * @default default\n     */\n    browser: \"default\",\n\n    /**\n     * Add HTTP access control (CORS) headers to assets served by Browsersync.\n     * @property cors\n     * @type boolean\n     * @default false\n     * @since 2.16.0\n     */\n    cors: false,\n\n    /**\n     * Requires an internet connection - useful for services such as [Typekit](https://typekit.com/)\n     * as it allows you to configure domains such as `*.xip.io` in your kit settings\n     * @property xip\n     * @type Boolean\n     * @default false\n     */\n    xip: false,\n\n    hostnameSuffix: false,\n\n    /**\n     * Reload each browser when Browsersync is restarted.\n     * @property reloadOnRestart\n     * @type Boolean\n     * @default false\n     */\n    reloadOnRestart: false,\n\n    /**\n     * The small pop-over notifications in the browser are not always needed/wanted.\n     * @property notify\n     * @type Boolean\n     * @default true\n     */\n    notify: true,\n\n    /**\n     * @property scrollProportionally\n     * @type Boolean\n     * @default true\n     */\n    scrollProportionally: true,\n\n    /**\n     * @property scrollThrottle\n     * @type Number\n     * @default 0\n     */\n    scrollThrottle: 0,\n\n    /**\n     * Decide which technique should be used to restore\n     * scroll position following a reload.\n     * Can be `window.name` or `cookie`\n     * @property scrollRestoreTechnique\n     * @type String\n     * @default 'window.name'\n     */\n    scrollRestoreTechnique: \"window.name\",\n\n    /**\n     * Sync the scroll position of any element\n     * on the page. Add any amount of CSS selectors\n     * @property scrollElements\n     * @type Array\n     * @default []\n     * @since 2.9.0\n     */\n    scrollElements: [],\n\n    /**\n     * Sync the scroll position of any element\n     * on the page - where any scrolled element\n     * will cause all others to match scroll position.\n     * This is helpful when a breakpoint alters which element\n     * is actually scrolling\n     * @property scrollElementMapping\n     * @type Array\n     * @default []\n     * @since 2.9.0\n     */\n    scrollElementMapping: [],\n\n    /**\n     * Time, in milliseconds, to wait before\n     * instructing the browser to reload/inject following a\n     * file change event\n     * @property reloadDelay\n     * @type Number\n     * @default 0\n     */\n    reloadDelay: 0,\n\n    /**\n     * Wait for a specified window of event-silence before\n     * sending any reload events.\n     * @property reloadDebounce\n     * @type Number\n     * @default 0\n     * @since 2.6.0\n     */\n    reloadDebounce: 0,\n\n    /**\n     * Emit only the first event during sequential time windows\n     * of a specified duration.\n     * @property reloadThrottle\n     * @type Number\n     * @default 0\n     * @since 2.13.0\n     */\n    reloadThrottle: 0,\n\n    /**\n     * User provided plugins\n     * @property plugins\n     * @type Array\n     * @default []\n     * @since 2.6.0\n     */\n    plugins: [],\n\n    /**\n     * @property injectChanges\n     * @type Boolean\n     * @default true\n     */\n    injectChanges: true,\n\n    /**\n     * @property startPath\n     * @type String|Null\n     * @default null\n     */\n    startPath: null,\n\n    /**\n     * Whether to minify client script, or not.\n     * @property minify\n     * @type Boolean\n     * @default true\n     */\n    minify: true,\n\n    /**\n     * @property host\n     * @type String\n     * @default null\n     */\n    host: null,\n\n    /**\n     * Support environments where dynamic hostnames are not required\n     * (ie: electron)\n     * @property localOnly\n     * @type Boolean\n     * @default false\n     * @since 2.14.0\n     */\n    localOnly: false,\n\n    /**\n     * @property codeSync\n     * @type Boolean\n     * @default true\n     */\n    codeSync: true,\n\n    /**\n     * @property timestamps\n     * @type Boolean\n     * @default true\n     */\n    timestamps: true,\n\n    clientEvents: [\n        \"scroll\",\n        \"scroll:element\",\n        \"input:text\",\n        \"input:toggles\",\n        \"form:submit\",\n        \"form:reset\",\n        \"click\"\n    ],\n\n    /**\n     * Alter the script path for complete control over where the Browsersync\n     * Javascript is served from. Whatever you return from this function\n     * will be used as the script path.\n     * @property scriptPath\n     * @default undefined\n     * @since 1.5.0\n     * @type Function\n     */\n\n    /**\n     * Configure the Socket.IO path and namespace & domain to avoid collisions.\n     * @property socket\n     * @param {String} [path=\"/browser-sync/socket.io\"]\n     * @param {String} [clientPath=\"/browser-sync\"]\n     * @param {String|Function} [namespace=\"/browser-sync\"]\n     * @param {String|Function} [domain=undefined]\n     * @param {String|Function} [port=undefined]\n     * @param {Object} [clients.heartbeatTimeout=5000]\n     * @since 1.6.2\n     * @type Object\n     */\n    socket: {\n        socketIoOptions: {\n            log: false\n        },\n        socketIoClientConfig: {\n            reconnectionAttempts: 50\n        },\n        path: \"/browser-sync/socket.io\",\n        clientPath: \"/browser-sync\",\n        namespace: \"/browser-sync\",\n        clients: {\n            heartbeatTimeout: 5000\n        }\n    },\n\n    /**\n     * Configure the script domain\n     * @property script\n     * @param {String|Function} [domain=undefined]\n     * @since 2.14.0\n     * @type Object\n     */\n\n    tagNames: {\n        \"less\": \"link\",\n        \"scss\": \"link\",\n        \"css\":  \"link\",\n        \"jpg\":  \"img\",\n        \"jpeg\": \"img\",\n        \"png\":  \"img\",\n        \"svg\":  \"img\",\n        \"gif\":  \"img\",\n        \"js\":   \"script\"\n    },\n\n    injectFileTypes: [\"css\", \"png\", \"jpg\", \"jpeg\", \"svg\", \"gif\", \"webp\"],\n    excludedFileTypes: [\n        \"js\",\n        \"css\",\n        \"pdf\",\n        \"map\",\n        \"svg\",\n        \"ico\",\n        \"woff\",\n        \"json\",\n        \"eot\",\n        \"ttf\",\n        \"png\",\n        \"jpg\",\n        \"jpeg\",\n        \"webp\",\n        \"gif\",\n        \"mp4\",\n        \"mp3\",\n        \"3gp\",\n        \"ogg\",\n        \"ogv\",\n        \"webm\",\n        \"m4a\",\n        \"flv\",\n        \"wmv\",\n        \"avi\",\n        \"swf\",\n        \"scss\"\n    ]\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/file-event-handler.js":"var utils = require(\"./utils\");\n\n/**\n * Apply the operators that apply to the 'file:changed' event\n * @param {Rx.Observable} subject\n * @param options\n * @return {Rx.Observable<{type: string, files: Array<any>}>}\n */\nfunction fileChanges(subject, options) {\n    var operators = [\n        {\n            option: \"reloadThrottle\",\n            fnName: \"throttle\"\n        },\n        {\n            option: \"reloadDelay\",\n            fnName: \"delay\"\n        }\n    ];\n\n    var scheduler = options.getIn([\"debug\", \"scheduler\"]);\n\n    /**\n     * if the 'reloadDebounce' option was provided, create\n     * a stream buffered/debounced stream of events\n     */\n    var initial = (function() {\n        if (options.get(\"reloadDebounce\") > 0) {\n            return getAggregatedDebouncedStream(subject, options, scheduler);\n        }\n        return subject;\n    })();\n\n    return applyOperators(operators, initial, options, scheduler)\n        .map(function(xs) {\n\n            var items = [].concat(xs);\n            var paths = items.map(function (x) { return x.path });\n\n            if (utils.willCauseReload(paths, options.get(\"injectFileTypes\").toJS())) {\n                return {\n                    type: \"reload\",\n                    files: items\n                }\n            }\n            return {\n                type: \"inject\",\n                files: items\n            }\n        });\n}\nmodule.exports.fileChanges = fileChanges;\n\n/**\n * Apply the operators that apply to the 'browser:reload' event\n * @param {Rx.Observable} subject\n * @param options\n * @returns {Rx.Observable}\n */\nfunction applyReloadOperators (subject, options) {\n    var operators = [\n        {\n            option: \"reloadDebounce\",\n            fnName: \"debounce\"\n        },\n        {\n            option: \"reloadThrottle\",\n            fnName: \"throttle\"\n        },\n        {\n            option: \"reloadDelay\",\n            fnName: \"delay\"\n        }\n    ];\n\n    return applyOperators(operators, subject, options, options.getIn([\"debug\", \"scheduler\"]));\n}\nmodule.exports.applyReloadOperators = applyReloadOperators;\n\n/**\n * @param items\n * @param subject\n * @param options\n * @param scheduler\n */\nfunction applyOperators (items, subject, options, scheduler) {\n    return items.reduce(function(subject, item) {\n        var value = options.get(item.option);\n        if (value > 0) {\n            return subject[item.fnName].call(subject, value, scheduler);\n        }\n        return subject;\n    }, subject);\n}\n\n/**\n * @param subject\n * @param options\n * @param scheduler\n */\nfunction getAggregatedDebouncedStream (subject, options, scheduler) {\n    return subject\n        .filter(function(x) { return options.get(\"watchEvents\").indexOf(x.event) > -1 })\n        .buffer(subject.debounce(options.get(\"reloadDebounce\"), scheduler))\n        .map(function(buffered) {\n            return buffered.reduce(function (acc, item) {\n                if (!acc[item.path]) acc[item.path] = item;\n                if (acc[item.path]) acc[item.path] = item;\n                return acc;\n            }, {});\n        })\n        .map(function(group) {\n            return Object\n                .keys(group)\n                .map(function(key) {\n                    return group[key];\n                });\n        })\n        .filter(function (x) { return x.length })\n}\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/file-utils.js":"\"use strict\";\n\nvar _         = require(\"../lodash.custom\");\n\nvar fileUtils = {\n    /**\n     * React to file-change events that occur on \"core\" namespace only\n     * @param bs\n     * @param data\n     */\n    changedFile: function (bs, data) {\n        /**\n         * If the event property is undefined, infer that it's a 'change'\n         * event due the fact this handler is for emitter.emit(\"file:changed\")\n         */\n        if (_.isUndefined(data.event)) {\n            data.event = \"change\";\n        }\n        /**\n         * Chokidar always sends an 'event' property - which could be\n         * `add` `unlink` etc etc so we need to check for that and only\n         * respond to 'change', for now.\n         */\n        if (bs.options.get(\"watchEvents\").indexOf(data.event) > -1) {\n            if (!bs.paused && data.namespace === \"core\") {\n                bs.events.emit(\"file:reload\", fileUtils.getFileInfo(data, bs.options));\n            }\n        }\n    },\n    /**\n     * @param data\n     * @param options\n     * @returns {{assetFileName: *, fileExtension: String}}\n     */\n    getFileInfo: function (data, options) {\n\n        data.ext      = require(\"path\").extname(data.path).slice(1);\n        data.basename = require(\"path\").basename(data.path);\n\n        var obj = {\n            ext:           data.ext,\n            path:          data.path,\n            basename:      data.basename,\n            event:         data.event,\n            type:          \"inject\"\n        };\n\n        // RELOAD page\n        if (!_.includes(options.get(\"injectFileTypes\").toJS(), obj.ext)) {\n            obj.url  = obj.path;\n            obj.type = \"reload\";\n        }\n\n        obj.path = data.path;\n        obj.log  = data.log;\n\n        return obj;\n    }\n};\n\nmodule.exports = fileUtils;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/http-protocol.js":"\"use strict\";\n\nvar queryString = require(\"qs\");\nvar proto = exports;\n\n/**\n * Use BrowserSync options + querystring to create a\n * full HTTP/HTTTPS url.\n *\n * Eg. http://localhost:3000/__browser_sync__?method=reload\n * Eg. http://localhost:3000/__browser_sync__?method=reload&args=core.css\n * Eg. http://localhost:3000/__browser_sync__?method=reload&args=core.css&args=core.min\n *\n * @param args\n * @param url\n * @returns {string}\n */\nproto.getUrl = function (args, url) {\n    return [\n        url,\n        require(\"./config\").httpProtocol.path,\n        \"?\",\n        queryString.stringify(args)\n    ].join(\"\");\n};\n\n/**\n * Return a middleware for handling the requests\n * @param {BrowserSync} bs\n * @returns {Function}\n */\nproto.middleware = function (bs) {\n\n    return function (req, res) {\n\n        var params = queryString.parse(req.url.replace(/^.*\\?/, \"\"));\n        var output;\n\n        if (!Object.keys(params).length) {\n            output = [\n                \"Error: No Parameters were provided.\",\n                \"Example: http://localhost:3000/__browser_sync__?method=reload&args=core.css\"\n            ];\n            res.writeHead(500, {\"Content-Type\": \"text/plain\"});\n            res.end(output.join(\"\\n\"));\n            return;\n        }\n\n        try {\n\n            require(\"./public/\" + params.method)(bs.events).apply(null, [params.args]);\n\n            output = [\n                \"Called public API method `.%s()`\".replace(\"%s\", params.method),\n                \"With args: \" + JSON.stringify(params.args)\n            ];\n\n            res.end(output.join(\"\\n\"));\n\n        } catch (e) {\n\n            res.writeHead(404, {\"Content-Type\": \"text/plain\"});\n            res.write(\"Public API method `\" + params.method + \"` not found.\");\n            res.end();\n\n            return;\n        }\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/internal-events.js":"\"use strict\";\n\nvar utils     = require(\"./utils\");\nvar fileUtils = require(\"./file-utils\");\nvar Rx        = require(\"rx\");\nvar fromEvent = Rx.Observable.fromEvent;\nvar fileHandler = require(\"./file-event-handler\");\n\nmodule.exports = function (bs) {\n\n    var events = {\n        /**\n         * File reloads\n         * @param data\n         */\n        \"file:reload\": function (data) {\n            bs.io.sockets.emit(\"file:reload\", data);\n        },\n        /**\n         * Browser Reloads\n         */\n        \"browser:reload\": function () {\n            bs.io.sockets.emit(\"browser:reload\");\n        },\n        /**\n         * Browser Notify\n         * @param data\n         */\n        \"browser:notify\": function (data) {\n            bs.io.sockets.emit(\"browser:notify\", data);\n        },\n        /**\n         * Things that happened after the service is running\n         * @param data\n         */\n        \"service:running\": function (data) {\n\n            var mode = bs.options.get(\"mode\");\n            var open = bs.options.get(\"open\");\n\n            if (mode === \"proxy\" || mode === \"server\" || open === \"ui\" || open === \"ui-external\") {\n                utils.openBrowser(data.url, bs.options, bs);\n            }\n\n            // log about any file watching\n            if (bs.watchers) {\n                bs.events.emit(\"file:watching\", bs.watchers);\n            }\n        },\n        /**\n         * Option setting\n         * @param data\n         */\n        \"options:set\": function (data) {\n            if (bs.io) {\n                bs.io.sockets.emit(\"options:set\", data);\n            }\n        },\n        /**\n         * Plugin configuration setting\n         * @param data\n         */\n        \"plugins:configure\": function (data) {\n            if (data.active) {\n                bs.pluginManager.enablePlugin(data.name);\n            } else {\n                bs.pluginManager.disablePlugin(data.name);\n            }\n            bs.setOption(\"userPlugins\", bs.getUserPlugins());\n        },\n        \"plugins:opts\": function (data) {\n            if (bs.pluginManager.pluginOptions[data.name]) {\n                bs.pluginManager.pluginOptions[data.name] = data.opts;\n                bs.setOption(\"userPlugins\", bs.getUserPlugins());\n            }\n        }\n    };\n\n    Object.keys(events).forEach(function (event) {\n        bs.events.on(event, events[event]);\n    });\n\n    var reloader = fileHandler.applyReloadOperators(fromEvent(bs.events, \"_browser:reload\"), bs.options)\n        .subscribe(function() {\n            bs.events.emit(\"browser:reload\");\n        });\n\n    var coreNamespacedWatchers = fromEvent(bs.events, \"file:changed\")\n        .filter(function() { return bs.options.get(\"codeSync\") })\n        .filter(function(x) { return  x.namespace === \"core\" });\n\n    var handler = fileHandler.fileChanges(coreNamespacedWatchers, bs.options)\n        .subscribe(function (x) {\n            if (x.type === \"reload\") {\n                bs.events.emit(\"browser:reload\");\n            }\n            if (x.type === \"inject\") {\n                x.files.forEach(function(data) {\n                    if (!bs.paused && data.namespace === \"core\") {\n                        bs.events.emit(\"file:reload\", fileUtils.getFileInfo(data, bs.options));\n                    }\n                });\n            }\n        });\n\n    bs.registerCleanupTask(function() {\n        handler.dispose();\n        reloader.dispose();\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/options.js":"\"use strict\";\n\nvar _             = require(\"../lodash.custom\");\nvar Immutable     = require(\"immutable\");\nvar defaultConfig = require(\"./default-config\");\n\n/**\n * @param {Map} options\n * @returns {Map}\n */\nmodule.exports.update = function (options) {\n\n    return options.withMutations(function (item) {\n\n        setMode(item);\n        setScheme(item);\n        setStartPath(item);\n        setProxyWs(item);\n        setServerOpts(item);\n        setNamespace(item);\n        fixSnippetOptions(item);\n        fixRewriteRules(item);\n        setMiddleware(item);\n        setOpen(item);\n\n        if (item.get(\"uiPort\")) {\n            item.setIn([\"ui\", \"port\"], item.get(\"uiPort\"));\n        }\n    });\n};\n\n/**\n * Move top-level ws options to proxy.ws\n * This is to allow it to be set from the CLI\n * @param item\n */\nfunction setProxyWs(item) {\n    if (item.get(\"ws\") && item.get(\"mode\") === \"proxy\") {\n        item.setIn([\"proxy\", \"ws\"], true);\n    }\n}\n\n/**\n * @param item\n */\nfunction setOpen (item) {\n    var open = item.get(\"open\");\n    if (item.get(\"mode\") === \"snippet\") {\n        if (open !== \"ui\" && open !== \"ui-external\") {\n            item.set(\"open\", false);\n        }\n    }\n}\n\n/**\n * Set the running mode\n * @param item\n */\nfunction setMode (item) {\n    item.set(\"mode\", (function () {\n        if (item.get(\"server\")) {\n            return \"server\";\n        }\n        if (item.get(\"proxy\")) {\n            return \"proxy\";\n        }\n        return \"snippet\";\n    })());\n}\n\n/**\n * @param item\n */\nfunction setScheme (item) {\n\n    var scheme = \"http\";\n\n    if (item.getIn([\"server\", \"https\"])) {\n        scheme = \"https\";\n    }\n\n    if (item.get(\"https\")) {\n        scheme = \"https\";\n    }\n\n    if (item.getIn([\"proxy\", \"url\", \"protocol\"])) {\n        if (item.getIn([\"proxy\", \"url\", \"protocol\"]) === \"https:\") {\n            scheme = \"https\";\n        }\n    }\n\n    item.set(\"scheme\", scheme);\n}\n\n/**\n * @param item\n */\nfunction setStartPath (item) {\n\n    if (item.get(\"proxy\")) {\n        var path = item.getIn([\"proxy\", \"url\", \"path\"]);\n        if (path !== \"/\") {\n            item.set(\"startPath\", path);\n        }\n    }\n\n}\n\n/**\n * @param item\n */\nfunction setNamespace(item) {\n    var namespace = item.getIn([\"socket\", \"namespace\"]);\n\n    if (_.isFunction(namespace)) {\n        item.setIn([\"socket\", \"namespace\"], namespace(defaultConfig.socket.namespace));\n    }\n}\n\n/**\n * @param item\n */\nfunction setServerOpts(item) {\n\n    if (item.get(\"server\")) {\n\n        var indexarg = item.get(\"index\") || item.getIn([\"server\", \"index\"]) || \"index.html\";\n        var optPath  = [\"server\", \"serveStaticOptions\"];\n\n        if (item.get(\"directory\")) {\n            item.setIn([\"server\", \"directory\"], true);\n        }\n\n        if (!item.getIn(optPath)) {\n            item.setIn(optPath, Immutable.Map({\n                index: indexarg\n            }));\n        } else {\n            if (!item.hasIn(optPath.concat([\"index\"]))) {\n                item.setIn(optPath.concat([\"index\"]), indexarg);\n            }\n        }\n\n        // cli extensions\n        if (item.get(\"extensions\")) {\n            item.setIn(optPath.concat([\"extensions\"]), item.get(\"extensions\"));\n        }\n    }\n}\n\n/**\n * Back-compat fixes for rewriteRules being set to a boolean\n */\nfunction fixRewriteRules (item) {\n    return item.update(\"rewriteRules\", function (rr) {\n        return Immutable.List([]).concat(rr).filter(Boolean)\n    });\n}\n\nfunction fixSnippetOptions (item) {\n\n    var ignorePaths  = item.getIn([\"snippetOptions\", \"ignorePaths\"]);\n    var includePaths = item.getIn([\"snippetOptions\", \"whitelist\"]);\n\n    if (ignorePaths) {\n        if (_.isString(ignorePaths)) {\n            ignorePaths = [ignorePaths];\n        }\n        ignorePaths = ignorePaths.map(ensureSlash);\n        item.setIn([\"snippetOptions\", \"blacklist\"], Immutable.List(ignorePaths));\n    }\n    if (includePaths) {\n        includePaths = includePaths.map(ensureSlash);\n        item.setIn([\"snippetOptions\", \"whitelist\"], Immutable.List(includePaths));\n    }\n}\n\n/**\n * Enforce paths to begin with a forward slash\n */\nfunction ensureSlash (item) {\n    if (item[0] !== \"/\") {\n        return \"/\" + item;\n    }\n    return item;\n}\n\n/**\n *\n */\nfunction setMiddleware (item) {\n\n    var mw = getMiddlwares(item);\n\n    item.set(\"middleware\", mw);\n}\n\n/**\n * top-level option, or given as part of the proxy/server option\n * @param item\n * @returns {*}\n */\nfunction getMiddlwares (item) {\n\n    var mw       = item.get(\"middleware\");\n    var serverMw = item.getIn([\"server\", \"middleware\"]);\n    var proxyMw  = item.getIn([\"proxy\",  \"middleware\"]);\n\n    var list     = Immutable.List([]);\n\n    if (mw) {\n        return listMerge(list, mw);\n    }\n\n    if (serverMw) {\n        return listMerge(list, serverMw);\n    }\n\n    if (proxyMw) {\n        return listMerge(list, proxyMw);\n    }\n\n    return list;\n}\n\n/**\n * @param item\n * @returns {*}\n */\nfunction isList (item) {\n    return Immutable.List.isList(item);\n}\n\n/**\n * @param list\n * @param item\n * @returns {*}\n */\nfunction listMerge(list, item) {\n\n    if (_.isFunction(item)) {\n        list = list.push(item);\n    }\n\n    if (isList(item) && item.size) {\n        list = list.merge(item);\n    }\n\n    return list;\n}\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/cli/cli-info.js":"\"use strict\";\n\nvar config = require(\"../config\");\nvar logger = require(\"../logger\").logger;\n\nvar fs     = require(\"fs\");\nvar _      = require(\"../../lodash.custom\");\nvar path   = require(\"path\");\n\nvar info = {\n    /**\n     * Version info\n     * @param {Object} pjson\n     * @returns {String}\n     */\n    getVersion: function (pjson) {\n        console.log(pjson.version);\n        return pjson.version;\n    },\n    /**\n     * Retrieve the config file\n     * @returns {*}\n     * @private\n     * @param filePath\n     */\n    getConfigFile: function (filePath) {\n        return require(path.resolve(filePath));\n    },\n    /**\n     * Generate an example Config file.\n     */\n    makeConfig: function (cwd, cb) {\n\n        var opts = require(path.join(__dirname, \"..\", config.configFile));\n        var userOpts = {};\n\n        var ignore = [\"excludedFileTypes\", \"injectFileTypes\", \"snippetOptions\"];\n\n        Object.keys(opts).forEach(function (key) {\n            if (!_.includes(ignore, key)) {\n                userOpts[key] = opts[key];\n            }\n        });\n\n        var file = fs.readFileSync(path.join(__dirname, config.template), \"utf8\");\n        file = file.replace(\"//OPTS\", JSON.stringify(userOpts, null, 4));\n\n        fs.writeFile(path.resolve(cwd, config.userFile), file, function () {\n            logger.info(\"Config file created {magenta:%s}\", config.userFile);\n            logger.info(\n              \"To use it, in the same directory run: \" +\n              \"{cyan:browser-sync start --config bs-config.js}\"\n            );\n            cb();\n        });\n    }\n};\n\nmodule.exports = info;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/cli/cli-options.js":"\"use strict\";\n\nvar path = require(\"path\");\nvar url = require(\"url\");\nvar _    = require(\"../../lodash.custom\");\nvar Immutable = require(\"immutable\");\nvar isList = Immutable.List.isList;\nvar isMap = Immutable.Map.isMap;\nvar defaultConfig = require(\"../default-config\");\nvar immDefs = Immutable.fromJS(defaultConfig);\n\nvar opts = exports;\n\n/**\n * @type {{wrapPattern: Function}}\n */\nopts.utils = {\n\n    /**\n     * Transform a string arg such as \"*.html, css/*.css\" into array\n     * @param string\n     * @returns {Array}\n     */\n    explodeFilesArg: function (string) {\n        return string.split(\",\").map(function (item) {\n            return item.trim();\n        });\n    },\n    /**\n     * @param pattern\n     * @returns {*|string}\n     * @private\n     */\n    wrapPattern: function (pattern) {\n        var prefix = \"!\";\n        var suffix = \"/**\";\n        var lastChar = pattern.charAt(pattern.length - 1);\n        var extName = path.extname(pattern);\n\n        // If there's a file ext, don't append any suffix\n        if (extName.length) {\n            suffix = \"\";\n        } else {\n\n            if (lastChar === \"/\") {\n                suffix = \"**\";\n            }\n\n            if (lastChar === \"*\") {\n                suffix = \"\";\n            }\n        }\n\n        return [prefix, pattern, suffix].join(\"\");\n    }\n};\n\nopts.callbacks = {\n\n    /**\n     * Merge server options\n     * @param {String|Boolean|Object} value\n     * @param [argv]\n     * @returns {*}\n     */\n    server: function (value, argv) {\n\n        if (value === false) {\n            if (!argv || !argv.server) {\n                return false;\n            }\n        }\n\n        var obj = {\n            baseDir: \"./\"\n        };\n\n        if (_.isString(value) || isList(value)) {\n            obj.baseDir = value;\n        } else {\n            if (value && value !== true) {\n                if (value.get(\"baseDir\")) {\n                    return value;\n                }\n            }\n        }\n\n        if (argv) {\n\n            if (argv.index) {\n                obj.index = argv.index;\n            }\n\n            if (argv.directory) {\n                obj.directory = true;\n            }\n        }\n\n        return Immutable.fromJS(obj);\n    },\n    /**\n     * @param value\n     * @param argv\n     * @returns {*}\n     */\n    proxy: function (value) {\n\n        var mw;\n        var target;\n\n        if (!value || value === true) {\n            return false;\n        }\n\n        if (typeof value !== \"string\") {\n            target = value.get(\"target\");\n            mw     = value.get(\"middleware\");\n        } else {\n            target = value;\n            value = Immutable.Map({});\n        }\n\n        if (!target.match(/^(https?):\\/\\//)) {\n            target = \"http://\" + target;\n        }\n\n        var parsedUrl = url.parse(target);\n\n        if (!parsedUrl.port) {\n            parsedUrl.port = 80;\n        }\n\n        var out = {\n            target: parsedUrl.protocol + \"//\" + parsedUrl.host,\n            url: Immutable.Map(parsedUrl)\n        };\n\n        if (mw) {\n            out.middleware = mw;\n        }\n\n        return value.mergeDeep(out);\n    },\n    /**\n     * @param value\n     * @private\n     */\n    ports: function (value) {\n\n        var segs;\n        var obj = {};\n\n        if (typeof value === \"string\") {\n\n            if (~value.indexOf(\",\")) {\n                segs = value.split(\",\");\n                obj.min = parseInt(segs[0], 10);\n                obj.max = parseInt(segs[1], 10);\n            } else {\n                obj.min = parseInt(value, 10);\n                obj.max = null;\n            }\n\n        } else {\n\n            obj.min = value.get(\"min\");\n            obj.max = value.get(\"max\") || null;\n        }\n\n        return Immutable.Map(obj);\n    },\n    /**\n     * @param value\n     * @param argv\n     * @returns {*}\n     */\n    ghostMode: function (value, argv) {\n\n        var trueAll = {\n            clicks: true,\n            scroll: true,\n            forms: {\n                submit: true,\n                inputs: true,\n                toggles: true\n            }\n        };\n\n        var falseAll = {\n            clicks: false,\n            scroll: false,\n            forms: {\n                submit: false,\n                inputs: false,\n                toggles: false\n            }\n        };\n\n        if (value === false || value === \"false\" || argv && argv.ghost === false) {\n            return Immutable.fromJS(falseAll);\n        }\n\n        if (value === true || value === \"true\" || argv && argv.ghost === true) {\n            return Immutable.fromJS(trueAll);\n        }\n\n        if (value.get(\"forms\") === false) {\n            return value.withMutations(function (map) {\n                map.set(\"forms\", Immutable.fromJS({\n                    submit: false,\n                    inputs: false,\n                    toggles: false\n                }));\n            });\n        }\n\n        if (value.get(\"forms\") === true) {\n            return value.withMutations(function (map) {\n                map.set(\"forms\", Immutable.fromJS({\n                    submit: true,\n                    inputs: true,\n                    toggles: true\n                }));\n            });\n        }\n\n        return value;\n    },\n    /**\n     * @param value\n     * @returns {*}\n     */\n    files: function (value) {\n\n        var namespaces = {core: {}};\n\n        namespaces.core.globs = [];\n        namespaces.core.objs  = [];\n\n        var processed = opts.makeFilesArg(value);\n\n        if (processed.globs.length) {\n            namespaces.core.globs = processed.globs;\n        }\n\n        if (processed.objs.length) {\n            namespaces.core.objs = processed.objs;\n        }\n\n        return Immutable.fromJS(namespaces);\n    },\n    /**\n     * @param value\n     */\n    extensions: function (value) {\n        if (_.isString(value)) {\n            var split = opts.utils.explodeFilesArg(value);\n            if (split.length) {\n                return Immutable.List(split);\n            }\n        }\n        if (Immutable.List.isList(value)) {\n            return value;\n        }\n        return value;\n    }\n};\n\n/**\n * @param {Object} values\n * @param {Object} [argv]\n * @returns {Map}\n */\nopts.merge = function (values, argv) {\n    return immDefs\n        .mergeDeep(values)\n        .withMutations(function (item) {\n            item.map(function (value, key) {\n                if (opts.callbacks[key]) {\n                    item.set(key, opts.callbacks[key](value, argv));\n                }\n            });\n        });\n};\n\n/**\n * @param value\n * @returns {{globs: Array, objs: Array}}\n */\nopts.makeFilesArg = function (value) {\n\n    var globs = [];\n    var objs  = [];\n\n    if (_.isString(value)) {\n        globs = globs.concat(\n            opts.utils.explodeFilesArg(value)\n        );\n    }\n\n    if (isList(value) && value.size) {\n        value.forEach(function (value) {\n            if (_.isString(value)) {\n                globs.push(value);\n            } else {\n                if (isMap(value)) {\n                    objs.push(value);\n                }\n            }\n        });\n    }\n\n    return {\n        globs: globs,\n        objs: objs\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/cli/cli-template.js":"\n/*\n |--------------------------------------------------------------------------\n | Browser-sync config file\n |--------------------------------------------------------------------------\n |\n | For up-to-date information about the options:\n |   http://www.browsersync.io/docs/options/\n |\n | There are more options than you see here, these are just the ones that are\n | set internally. See the website for more info.\n |\n |\n */\nmodule.exports = //OPTS;","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/cli/command.init.js":"\"use strict\";\n\nvar info          = require(\"./cli-info\");\n\n/**\n * $ browser-sync init\n *\n * This command will generate a configuration\n * file in the current directory\n *\n * @param opts\n */\nmodule.exports = function (opts) {\n    info.makeConfig(process.cwd(), opts.cb);\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/cli/command.recipe.js":"\"use strict\";\nvar logger = require(\"../logger\").logger;\n\n/**\n * $ browser-sync recipe <name> <options>\n *\n * This command will copy a recipe into either the current directory\n * or one given with the --output flag\n *\n * @param opts\n * @returns {Function}\n */\nmodule.exports = function (opts) {\n\n    var path      = require(\"path\");\n    var fs        = require(\"fs-extra\");\n    var input     = opts.cli.input.slice(1);\n    var resolved  = require.resolve(\"bs-recipes\");\n    var dir       = path.dirname(resolved);\n\n    var logRecipes = function () {\n        var dirs = fs.readdirSync(path.join(dir, \"recipes\"));\n        logger.info(\"Install one of the following with {cyan:browser-sync recipe <name>\\n\");\n        dirs.forEach(function (name) {\n            console.log(\"    \" + name);\n        });\n    };\n\n    if (!input.length) {\n        logger.info(\"No recipe name provided!\");\n        logRecipes();\n        return opts.cb();\n    }\n\n    if (opts.cli.input[1] === \"ls\") {\n        logRecipes();\n        return opts.cb();\n    }\n\n    input         = input[0];\n    var flags     = opts.cli.flags;\n    var output    = flags.output ? path.resolve(flags.output) : path.join(process.cwd(), input);\n    var targetDir = path.join(dir, \"recipes\", input);\n\n    if (fs.existsSync(output)) {\n        return opts.cb(new Error(\"Target folder exists remove it first and then try again\"));\n    }\n\n    if (fs.existsSync(targetDir)) {\n        fs.copy(targetDir, output, function (err) {\n            if (err) {\n                opts.cb(err);\n            } else {\n                logger.info(\"Recipe copied into {cyan:%s}\", output);\n                logger.info(\"Next, inside that folder, run {cyan:npm i && npm start}\");\n                opts.cb(null);\n            }\n        });\n    } else {\n        logger.info(\"Recipe {cyan:%s} not found. The following are available though\", input);\n        logRecipes();\n        opts.cb();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/cli/command.reload.js":"\"use strict\";\n\n/**\n * $ browser-sync reload <options>\n *\n * This commands starts the Browsersync servers\n * & Optionally UI.\n *\n * @param opts\n * @returns {Function}\n */\nmodule.exports = function (opts) {\n\n    var flags = opts.cli.flags;\n    if (!flags.url) {\n        flags.url = \"http://localhost:\" + (flags.port || 3000);\n    }\n    var proto  = require(\"../http-protocol\");\n    var scheme = flags.url.match(/^https/) ? \"https\" : \"http\";\n    var args   = {method: \"reload\"};\n\n    if (flags.files) {\n        args.args = flags.files;\n    }\n\n    var url    = proto.getUrl(args, flags.url);\n\n    if (scheme === \"https\") {\n        process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\";\n    }\n\n    require(scheme).get(url, function (res) {\n        res.on(\"data\", function () {\n            if (res.statusCode === 200) {\n                opts.cb(null, res);\n            }\n        });\n    }).on(\"error\", function (err) {\n        if (err.code === \"ECONNREFUSED\") {\n            err.message = \"Browsersync not running at \" + flags.url;\n        }\n        return opts.cb(err);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/cli/command.start.js":"\"use strict\";\n\nvar path  = require(\"path\");\nvar fs    = require(\"fs\");\nvar _     = require(\"../../lodash.custom\");\nvar utils = require(\"../utils\");\nvar opts  = require(\"./cli-options\").utils;\n\n/**\n * $ browser-sync start <options>\n *\n * This commands starts the Browsersync servers\n * & Optionally UI.\n *\n * @param opts\n * @returns {Function}\n */\nmodule.exports = function (opts) {\n\n    var flags    = preprocessFlags(opts.cli.flags);\n    var maybepkg = path.resolve(process.cwd(), \"package.json\");\n    var input    = flags;\n\n    if (flags.config) {\n        var maybeconf = path.resolve(process.cwd(), flags.config);\n        if (fs.existsSync(maybeconf)) {\n            var conf = require(maybeconf);\n            input = _.merge({}, conf, flags);\n        } else {\n            utils.fail(true, new Error(\"Configuration file '\" + flags.config + \"' not found\"), opts.cb);\n        }\n    } else {\n        if (fs.existsSync(maybepkg)) {\n            var pkg = require(maybepkg);\n            if (pkg[\"browser-sync\"]) {\n                console.log(\"> Configuration obtained from package.json\");\n                input = _.merge({}, pkg[\"browser-sync\"], flags);\n            }\n        }\n    }\n\n    return require(\"../../\")\n        .create(\"cli\")\n        .init(input, opts.cb);\n};\n\n/**\n * @param flags\n * @returns {*}\n */\nfunction preprocessFlags (flags) {\n    return [\n        stripUndefined,\n        legacyFilesArgs\n    ].reduce(function (flags, fn) {\n        return fn.call(null, flags);\n    }, flags);\n}\n\n/**\n * Incoming undefined values are problematic as\n * they interfere with Immutable.Map.mergeDeep\n * @param subject\n * @returns {*}\n */\nfunction stripUndefined (subject) {\n    return Object.keys(subject).reduce(function (acc, key) {\n        var value = subject[key];\n        if (typeof value === \"undefined\") {\n            return acc;\n        }\n        acc[key] = value;\n        return acc;\n    }, {});\n}\n\n/**\n * @param flags\n * @returns {*}\n */\nfunction legacyFilesArgs(flags) {\n    if (flags.files && flags.files.length) {\n        flags.files = flags.files.reduce(function (acc, item) {\n            return acc.concat(opts.explodeFilesArg(item));\n        }, []);\n    }\n    return flags;\n}\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/public/exit.js":"\"use strict\";\n\n/**\n * @param {BrowserSync} browserSync\n * @returns {Function}\n */\nmodule.exports = function (browserSync) {\n\n    function exit() {\n        if (browserSync.active) {\n            browserSync.events.emit(\"service:exit\");\n            browserSync.cleanup();\n        }\n    }\n\n    return exit;\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/public/init.js":"\"use strict\";\n\nvar _         = require(\"../../lodash.custom\");\nvar merge     = require(\"../cli/cli-options\").merge;\n\n/**\n * @param {BrowserSync} browserSync\n * @param {String} [name] - instance name\n * @param {Object} pjson\n * @returns {Function}\n */\nmodule.exports = function (browserSync, name, pjson) {\n\n    return function () {\n\n        /**\n         * Handle new + old signatures for init.\n         */\n        var args = require(\"../args\")(_.toArray(arguments));\n\n        /**\n         * If the current instance is already running, just return an error\n         */\n        if (browserSync.active) {\n            return args.cb(new Error(\"Instance: \" + name + \" is already running!\"));\n        }\n\n        args.config.version = pjson.version;\n\n        return browserSync.init(merge(args.config), args.cb);\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/public/notify.js":"\"use strict\";\n\n/**\n * @param {BrowserSync} browserSync\n * @returns {Function}\n */\nmodule.exports = function (browserSync) {\n\n    return function (msg, timeout) {\n\n        if (msg) {\n            browserSync.events.emit(\"browser:notify\", {\n                message: msg,\n                timeout: timeout || 2000,\n                override: true\n            });\n        }\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/public/pause.js":"\"use strict\";\n\n/**\n * @param {BrowserSync} browserSync\n * @returns {Function}\n */\nmodule.exports = function (browserSync) {\n\n    return function () {\n        browserSync.paused = true;\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/public/reload.js":"\"use strict\";\n\nvar utils         = require(\"../utils\");\nvar publicUtils   = require(\"./public-utils\");\nvar _             = require(\"../../lodash.custom\");\nvar defaultConfig = require(\"../default-config\");\nvar stream        = require(\"./stream\");\n\n/**\n * @param emitter\n * @returns {Function}\n */\nmodule.exports = function (emitter) {\n\n    /**\n     * Inform browsers about file changes.\n     *\n     * eg: reload(\"core.css\")\n     */\n    function browserSyncReload (opts) {\n\n        /**\n         * BACKWARDS COMPATIBILITY:\n         * Passing an object as the only arg to the `reload`\n         * method with at *least* the key-value pair of {stream: true},\n         * was only ever used for streams support - so it's safe to check\n         * for that signature here and defer to the\n         * dedicated `.stream()` method instead.\n         */\n        if (_.isObject(opts)) {\n            if (!Array.isArray(opts) && Object.keys(opts).length) {\n                if (opts.stream === true) {\n                    return stream(emitter)(opts);\n                }\n            }\n        }\n\n        /**\n         * Handle single string paths such as\n         * reload(\"core.css\")\n         */\n        if (typeof opts === \"string\" && opts !== \"undefined\") {\n            return publicUtils.emitChangeEvent(emitter, opts, true);\n        }\n\n        /**\n         * Handle an array of file paths such as\n         * reload([\"core.css, \"ie.css\"])\n         */\n        if (Array.isArray(opts)) {\n            return opts.forEach(function (filepath) {\n                publicUtils.emitChangeEvent(emitter, filepath, true);\n            });\n        }\n\n        /**\n         * At this point the argument given was neither an object,\n         * array or string so we simply perform a reload. This is to\n         * allow the following syntax to work as expected\n         *\n         * reload();\n         */\n        return publicUtils.emitBrowserReload(emitter);\n    }\n\n    return browserSyncReload;\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/public/stream.js":"\"use strict\";\n\nvar path       = require(\"path\");\nvar micromatch = require(\"micromatch\");\nvar utils      = require(\"./public-utils\");\n\n/**\n * @param emitter\n * @returns {Function}\n */\nmodule.exports = function (emitter) {\n\n    /**\n     * Return a transform/through stream that listens to file\n     * paths and fires internal Browsersync events.\n     * @param {{once: boolean, match: string|array}} [opts]\n     * @returns {Stream.Transform}\n     */\n    function browserSyncThroughStream (opts) {\n\n        opts = opts || {};\n        var emitted = false;\n        var Transform = require(\"stream\").Transform;\n        var reload = new Transform({objectMode: true});\n        var changed = [];\n\n        reload._transform = function (file, encoding, next) {\n\n            var stream = this;\n\n            /**\n             * End is always called to send the current file down\n             * stream. Browsersync never acts upon a stream,\n             * we only `listen` to it.\n             */\n            function end () {\n                stream.push(file); // always send the file down-stream\n                next();\n            }\n\n            /**\n             * If {match: <pattern>} was provided, test the\n             * current filepath against it\n             */\n            if (opts.match) {\n                if (!micromatch(file.path, opts.match, {dot: true}).length) {\n                    return end();\n                }\n            }\n\n            /**\n             * if {once: true} provided, emit the reload event for the\n             * first file only\n             */\n            if (opts.once === true && !emitted) {\n\n                utils.emitBrowserReload(emitter);\n\n                emitted = true;\n\n            } else { // handle multiple\n\n                if (opts.once === true && emitted) {\n\n                } else {\n\n                    if (file.path) {\n\n                        emitted = true;\n                        utils.emitChangeEvent(emitter, file.path, false);\n                        changed.push(path.basename(file.path));\n                    }\n                }\n            }\n\n            end();\n        };\n\n        /**\n         * When this current operation has finished, emit the\n         * steam:changed event so that any loggers can pick up it\n         * @param next\n         * @private\n         */\n        reload._flush = function (next) {\n\n            if (changed.length) {\n                utils.emitStreamChangedEvent(emitter, changed);\n            }\n\n            next();\n        };\n\n        return reload;\n    }\n\n    return browserSyncThroughStream;\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/public/resume.js":"\"use strict\";\n\n/**\n * @param {BrowserSync} browserSync\n * @returns {Function}\n */\nmodule.exports = function (browserSync) {\n\n    return function () {\n        browserSync.paused = false;\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/server/proxy-server.js":"\"use strict\";\n\nvar httpProxy  = require(\"http-proxy\");\nvar utils      = require(\"./utils\");\nvar proxyUtils = require(\"./proxy-utils\");\nvar Immutable  = require(\"immutable\");\nvar Map        = require(\"immutable\").Map;\nvar List       = require(\"immutable\").List;\n\n/**\n * Default options that are passed along to http-proxy\n */\nvar defaultHttpProxyOptions = Map({\n    /**\n     * This ensures targets are more likely to\n     * accept each request\n     */\n    changeOrigin: true,\n    /**\n     * This handles redirects\n     */\n    autoRewrite: true,\n    /**\n     * This allows our self-signed certs to be used for development\n     */\n    secure: false,\n    ws: true\n});\n\nvar defaultCookieOptions = Map({\n    stripDomain: true\n});\n\nvar ProxyOption = Immutable.Record({\n    route: \"\",\n    target: \"\",\n    rewriteRules: true,\n    /**\n     * Functions to be called on proxy request\n     * with args [proxyReq, req, res, options]\n     */\n    proxyReq:     List([]),\n    /**\n     * Functions to be called on proxy response\n     * with args [proxyRes, req, res]\n     */\n    proxyRes:     List([]),\n    /**\n     * Functions to be called on proxy response\n     * with args [proxyReq, req, socket, options, head]\n     */\n    proxyReqWs:   List([]),\n    errHandler:   undefined,\n    url:          Map({}),\n    proxyOptions: Map(defaultHttpProxyOptions),\n    cookies:      Map(defaultCookieOptions),\n    ws:           false,\n    middleware:   List([]),\n    reqHeaders:   undefined\n});\n\n/**\n * @param {BrowserSync} bs\n * @param {String} scripts\n * @returns {*}\n */\nmodule.exports = function createProxyServer (bs) {\n\n    var opt         = new ProxyOption().mergeDeep(bs.options.get(\"proxy\"));\n    var proxy       = httpProxy.createProxyServer(opt.get(\"proxyOptions\").set(\"target\", opt.get(\"target\")).toJS());\n    var target      = opt.get(\"target\");\n    var proxyReq    = getProxyReqFunctions(opt.get(\"proxyReq\"), opt, bs);\n    var proxyRes    = getProxyResFunctions(opt.get(\"proxyRes\"), opt);\n    var proxyResWs  = opt.get(\"proxyReqWs\");\n    bs.options      = bs.options.update(\"middleware\", function (mw) {\n        return mw.concat({\n            id: \"Browsersync Proxy\",\n            route: opt.get(\"route\"),\n            handle: function (req, res) {\n                proxy.web(req, res, {\n                    target: target\n                });\n            }\n        });\n    });\n\n    var app  = utils.getBaseApp(bs);\n\n    /**\n     * @type {*|{server, app}}\n     */\n    var browserSyncServer = utils.getServer(app, bs.options);\n    browserSyncServer.proxy = proxy;\n\n    if (opt.get(\"ws\")) {\n        // debug(`+ ws upgrade for: ${x.get(\"target\")}`);\n        browserSyncServer.server.on(\"upgrade\", function (req, socket, head) {\n            proxy.ws(req, socket, head);\n        });\n    }\n\n    /**\n     * Add any user provided functions for proxyReq, proxyReqWs and proxyRes\n     */\n    applyFns(\"proxyReq\",   proxyReq);\n    applyFns(\"proxyRes\",   proxyRes);\n    applyFns(\"proxyReqWs\", proxyResWs);\n\n    /**\n     * Handle Proxy errors\n     */\n    proxy.on(\"error\", function (err) {\n        if (typeof opt.get(\"errHandler\") === \"function\") {\n            opt.get(\"errHandler\").call(null, err);\n        }\n    });\n\n    /**\n     * Apply functions to proxy events\n     * @param {string} name - the name of the http-proxy event\n     * @param {Array} fns - functions to call on each event\n     */\n    function applyFns (name, fns) {\n        if (!List.isList(fns)) fns = [fns];\n        proxy.on(name, function () {\n            var args = arguments;\n            fns.forEach(function(fn) {\n                if (typeof fn === \"function\") {\n                    fn.apply(null, args);\n                }\n            });\n        });\n    }\n\n    return browserSyncServer;\n};\n\n/**\n * @param resFns\n * @returns {*}\n */\nfunction getProxyResFunctions (resFns, opt) {\n    if (opt.getIn([\"cookies\", \"stripDomain\"])) {\n        return resFns.push(proxyUtils.checkCookies);\n    }\n    return resFns;\n}\n\n/**\n * @param reqFns\n * @returns {*}\n */\nfunction getProxyReqFunctions (reqFns, opt, bs) {\n\n    var reqHeaders = opt.getIn([\"reqHeaders\"]);\n\n    if (!reqHeaders) {\n        return reqFns;\n    }\n\n    /**\n     * Back-compat for old `reqHeaders` option here a\n     * function was given that returned an object\n     * where key:value was header-name:header-value\n     * This didn't really work as it clobbered all other headers,\n     * but it remains for the unlucky few who used it.\n     */\n    if (typeof reqHeaders === \"function\") {\n        var output = reqHeaders.call(bs, opt.toJS());\n        if (Object.keys(output).length) {\n            return reqFns.concat(function (proxyReq) {\n                Object.keys(output).forEach(function (key) {\n                    proxyReq.setHeader(key, output[key]);\n                });\n            });\n        }\n    }\n\n    /**\n     * Now, if {key:value} given, set the each header\n     *\n     * eg: reqHeaders: {\n     *     'is-dev': 'true'\n     * }\n     */\n    if (Map.isMap(reqHeaders)) {\n        return reqFns.concat(function (proxyReq) {\n            reqHeaders.forEach(function (value, key) {\n                proxyReq.setHeader(key, value);\n            });\n        });\n    }\n\n    return reqFns;\n}\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/server/proxy-utils.js":"var url = require(\"url\");\n\nmodule.exports.rewriteLinks = function (userServer) {\n\n    var host   = userServer.hostname;\n    var string = host;\n    var port   = userServer.port;\n\n    if (host && port) {\n        if (parseInt(port, 10) !== 80) {\n            string = host + \":\" + port;\n        }\n    }\n\n    return {\n        match: new RegExp(\"https?:\\\\\\\\/\\\\\\\\/\" + string + \"|('|\\\")\\\\\\/\\\\\\/\" + string + \"|https?://\" + string + \"(\\/)?|('|\\\")(https?://|/|\\\\.)?\" + string + \"(\\/)?(.*?)(?=[ ,'\\\"\\\\s])\", \"g\"),\n        //match: new RegExp(\"https?:\\\\\\\\/\\\\\\\\/\" + string + \"|https?://\" + string + \"(\\/)?|('|\\\")(https?://|/|\\\\.)?\" + string + \"(\\/)?(.*?)(?=[ ,'\\\"\\\\s])\", \"g\"),\n        //match: new RegExp(\"https?:\\\\\\\\?/\\\\\\\\?/\" + string + \"(\\/)?|('|\\\")(https?://|\\\\\\\\?/|\\\\.)?\" + string + \"(\\/)?(.*?)(?=[ ,'\\\"\\\\s])\", \"g\"),\n        //match: new RegExp('https?://' + string + '(\\/)?|(\\'|\")(https?://|/|\\\\.)?' + string + '(\\/)?(.*?)(?=[ ,\\'\"\\\\s])', 'g'),\n        //match: new RegExp(\"https?:\\\\\\\\/\\\\\\\\/\" + string, \"g\"),\n        fn:    function (req, res, match) {\n\n            var proxyUrl = req.headers[\"host\"];\n\n            /**\n             * Reject subdomains\n             */\n            if (match[0] === \".\") {\n                return match;\n            }\n\n            var captured = match[0] === \"'\" || match[0] === \"\\\"\" ? match[0] : \"\";\n\n            /**\n             * allow http https\n             * @type {string}\n             */\n            var pre = \"//\";\n\n            if (match[0] === \"'\" || match[0] === \"\\\"\") {\n                match = match.slice(1);\n            }\n\n            /**\n             * parse the url\n             * @type {number|*}\n             */\n            var out = url.parse(match);\n\n            /**\n             * If host not set, just do a simple replace\n             */\n            if (!out.host) {\n                string = string.replace(/^(\\/)/, \"\");\n                return captured + match.replace(string, proxyUrl);\n            }\n\n            /**\n             * Only add trailing slash if one was\n             * present in the original match\n             */\n            if (out.path === \"/\") {\n                if (match.slice(-1) === \"/\") {\n                    out.path = \"/\";\n                } else {\n                    out.path = \"\";\n                }\n            }\n\n            /**\n             * Finally append all of parsed url\n             */\n            return [\n                captured,\n                pre,\n                proxyUrl,\n                out.path || \"\",\n                out.hash || \"\"\n            ].join(\"\");\n        }\n    };\n};\n\n/**\n * Remove 'domain' from any cookies\n * @param {Object} res\n */\nmodule.exports.checkCookies = function checkCookies (res) {\n    if (typeof(res.headers[\"set-cookie\"]) !== \"undefined\") {\n        res.headers[\"set-cookie\"] = res.headers[\"set-cookie\"].map(function (item) {\n            return rewriteCookies(item);\n        });\n    }\n};\n\n/**\n * Remove the domain from any cookies.\n * @param rawCookie\n * @returns {string}\n */\nfunction rewriteCookies (rawCookie) {\n\n    var objCookie = (function () {\n        // simple parse function (does not remove quotes)\n        var obj = {};\n        var pairs = rawCookie.split(/; */);\n\n        pairs.forEach( function( pair ) {\n            var eqIndex = pair.indexOf(\"=\");\n\n            // skip things that don't look like key=value\n            if (eqIndex < 0) {\n                return;\n            }\n\n            var key = pair.substr(0, eqIndex).trim();\n            obj[key] = pair.substr(eqIndex + 1, pair.length).trim();\n        });\n\n        return obj;\n    })();\n\n    var pairs = Object.keys(objCookie)\n        .filter(function (item) {\n            return item !== \"domain\";\n        })\n        .map(function (key) {\n            return key + \"=\" + objCookie[key];\n        });\n\n    if (rawCookie.match(/httponly/i)) {\n        pairs.push(\"HttpOnly\");\n    }\n\n    return pairs.join(\"; \");\n}\n\nmodule.exports.rewriteCookies = rewriteCookies;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/server/snippet-server.js":"\"use strict\";\n\nvar connect = require(\"connect\");\nvar serverUtils = require(\"./utils.js\");\n\n/**\n * Create a server for the snippet\n * @param {BrowserSync} bs\n * @param scripts\n * @returns {*}\n */\nmodule.exports = function createSnippetServer (bs, scripts) {\n\n    var app = serverUtils.getBaseApp(bs, bs.options, scripts);\n    return serverUtils.getServer(app, bs.options);\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/node_modules/browser-sync/lib/server/static-server.js":"\"use strict\";\n\nvar connect      = require(\"connect\");\nvar serverUtils  = require(\"./utils.js\");\nvar resolve      = require(\"path\").resolve;\nvar utils        = require(\"../utils.js\");\nvar serveStatic  = require(\"serve-static\");\nvar serveIndex   = require(\"serve-index\");\n\n/**\n * @param {BrowserSync} bs\n * @param scripts\n * @returns {*}\n */\nmodule.exports = function createServer (bs) {\n\n    var options            = bs.options;\n    var server             = options.get(\"server\");\n    var basedirs           = utils.arrayify(server.get(\"baseDir\"));\n    var serveStaticOptions = server.get(\"serveStaticOptions\").toJS(); // passed to 3rd party\n\n    var _serveStatic = 0;\n    var _routes = 0;\n    bs.options = bs.options\n        /**\n         * Add directory Middleware if given in server.directory\n         */\n        .update(\"middleware\", function (mw) {\n            if (!server.get(\"directory\")) {\n                return mw;\n            }\n\n            return mw.concat({\n                route: \"\",\n                handle: serveIndex(resolve(basedirs[0]), {icons:true}),\n                id: \"Browsersync Server Directory Middleware\"\n            });\n        })\n        /**\n         * Add middleware for server.baseDir Option\n         */\n        .update(\"middleware\", function (mw) {\n            return mw.concat(basedirs.map(function (root) {\n                return {\n                    route: \"\",\n                    id: \"Browsersync Server ServeStatic Middleware - \" + _serveStatic++,\n                    handle: serveStatic(resolve(root), serveStaticOptions)\n                }\n            }));\n        })\n        /**\n         * Add middleware for server.routes\n         */\n        .update(\"middleware\", function (mw) {\n\n            if (!server.get(\"routes\")) {\n                return mw;\n            }\n\n            return mw.concat(server.get(\"routes\").map(function (root, urlPath) {\n                // strip trailing slash\n                if (urlPath[urlPath.length - 1] === \"/\") {\n                    urlPath = urlPath.slice(0, -1);\n                }\n                return {\n                    route: urlPath,\n                    id: \"Browsersync Server Routes Middleware - \" + _routes++,\n                    handle: serveStatic(resolve(root))\n                }\n            }));\n        });\n\n    var app = serverUtils.getBaseApp(bs);\n\n    /**\n     * Finally, return the server + App\n     */\n    return serverUtils.getServer(app, bs.options);\n};\n"}
{"/home/travis/build/npmtest/node-npmtest-browser-sync/test.js":"/* istanbul instrument in package npmtest_browser_sync */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-browser-sync/lib.npmtest_browser_sync.js":"/* istanbul instrument in package npmtest_browser_sync */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_browser_sync = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_browser_sync = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-browser-sync/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-browser-sync && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_browser_sync */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_browser_sync\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_browser_sync.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_browser_sync.rollup.js'] =\n            local.assetsDict['/assets.npmtest_browser_sync.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_browser_sync.__dirname +\n                    '/lib.npmtest_browser_sync.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/index.js":"#! /usr/bin/env node\n\"use strict\";\n\n/**\n * @module BrowserSync\n */\nvar pjson         = require(\"./package.json\");\nvar BrowserSync   = require(\"./lib/browser-sync\");\nvar publicUtils   = require(\"./lib/public/public-utils\");\nvar events        = require(\"events\");\nvar PassThrough   = require(\"stream\").PassThrough;\nvar logger        = require(\"eazy-logger\").Logger({\n    useLevelPrefixes: true\n});\n\nvar singleton        = false;\nvar singletonPlugins = [];\nvar instances        = [];\n\n/**\n * @type {boolean|EventEmitter}\n */\nvar singletonEmitter = false;\n\nmodule.exports         = initSingleton;\n\n/**\n * Create a Browsersync instance\n * @method create\n * @param {String} name an identifier that can used for retrieval later\n */\nmodule.exports.create    = create;\n\n/**\n * Get a single instance by name. This is useful if you have your\n * build scripts in separate files\n * @method get\n * @param {String} name\n * @returns {Object|Boolean}\n */\nmodule.exports.get = function (name) {\n    var instance = getSingle(name);\n    if (instance) {\n        return instance;\n    }\n    throw new Error(\"An instance with the name `%s` was not found.\".replace(\"%s\", name));\n};\n\n/**\n * Check if an instance has been created.\n * @method has\n * @param {String} name\n * @returns {Boolean}\n */\nmodule.exports.has = function (name) {\n    var instance = getSingle(name);\n    if (instance) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Start the Browsersync service. This will launch a server, proxy or start the snippet\n * mode depending on your use-case.\n * @method init\n * @param {Object} [config] This is the main configuration for your Browsersync instance and can contain any of the [available options]({{site.links.options}})\n *  If you do not pass a config an argument for configuration, Browsersync will still run; but it will be in the `snippet` mode\n * @param {Function} [cb] If you pass a callback function, it will be called when Browsersync has completed all setup tasks and is ready to use. This\n * is useful when you need to wait for information (for example: urls, port etc) or perform other tasks synchronously.\n * @returns {BrowserSync}\n */\nmodule.exports.init    = initSingleton;\n\n/**\n * Register a plugin. Must implement at least a 'plugin' method that returns a\n * callable function.\n *\n * @method use\n * @param {String} name The name of the plugin\n * @param {Object} module The object to be `required`.\n * @param {Function} [cb] A callback function that will return any errors.\n */\nmodule.exports.use     = function () {\n    var args = Array.prototype.slice.call(arguments);\n    singletonPlugins.push({\n        args: args\n    });\n};\n\n/**\n * The `reload` method will inform all browsers about changed files and will either cause the browser to refresh, or inject the files where possible.\n *\n * @method reload\n * @param {String|Array|Object} [arg] The file or files to be reloaded.\n * @returns {*}\n */\nmodule.exports.reload  = noop(\"reload\");\n\n/**\n * The `stream` method returns a transform stream and can act once or on many files.\n *\n * @method stream\n * @param {Object} [opts] Configuration for the stream method\n * @since 2.6.0\n * @returns {*}\n */\nmodule.exports.stream  = noop(\"stream\");\n\n/**\n * Helper method for browser notifications\n *\n * @method notify\n * @param {String|HTML} msg Can be a simple message such as 'Connected' or HTML\n * @param {Number} [timeout] How long the message will remain in the browser. @since 1.3.0\n */\nmodule.exports.notify  = noop(\"notify\");\n\n/**\n * This method will close any running server, stop file watching & exit the current process.\n *\n * @method exit\n */\nmodule.exports.exit    = noop(\"exit\");\n\n/**\n * Stand alone file-watcher. Use this along with Browsersync to create your own, minimal build system\n * @method watch\n * @param {string} patterns Glob patterns for files to watch\n * @param {object} [opts] Options to be passed to Chokidar - check what's available in [their docs](https://github.com/paulmillr/chokidar#getting-started)\n * @param {function} [fn] Callback function for each event.\n * @since 2.6.0\n */\nmodule.exports.watch   = noop(\"watch\");\n\n/**\n * Method to pause file change events\n *\n * @method pause\n */\nmodule.exports.pause   = noop(\"pause\");\n\n/**\n * Method to resume paused watchers\n *\n * @method resume\n */\nmodule.exports.resume  = noop(\"resume\");\n\n/**\n * Add properties fo\n */\nObject.defineProperties(module.exports, {\n    /**\n     * The internal Event Emitter used by the running Browsersync instance (if there is one).\n     * You can use this to emit your own events, such as changed files, logging etc.\n     *\n     * @property emitter\n     */\n    \"emitter\": {\n        get: function () {\n            if (!singletonEmitter) {\n                singletonEmitter = newEmitter();\n                return singletonEmitter;\n            }\n            return singletonEmitter;\n        }\n    },\n    /**\n     * A simple true/false flag that you can use to determine if there's a currently-running Browsersync instance.\n     *\n     * @property active\n     */\n    \"active\": {\n        get: getSingletonValue.bind(null, \"active\")\n    },\n    /**\n     * A simple true/false flag to determine if the current instance is paused\n     *\n     * @property paused\n     */\n    \"paused\": {\n        get: getSingletonValue.bind(null, \"paused\")\n    }\n});\n\n/**\n * Event emitter factory\n * @returns {EventEmitter}\n */\nfunction newEmitter() {\n    var emitter = new events.EventEmitter();\n    emitter.setMaxListeners(20);\n    return emitter;\n}\n\n/**\n * Get the singleton's emitter, or a new one.\n * @returns {EventEmitter}\n */\nfunction getSingletonEmitter() {\n    if (singletonEmitter) {\n        return singletonEmitter;\n    }\n    singletonEmitter = newEmitter();\n    return singletonEmitter;\n}\n\n/**\n * Helper to allow methods to be called on the module export\n * before there's a running instance\n * @param {String} name\n * @returns {Function}\n */\nfunction noop(name) {\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n        if (singleton) {\n            return singleton[name].apply(singleton, args);\n        } else {\n            if (publicUtils.isStreamArg(name, args)) {\n                return new PassThrough({objectMode: true});\n            }\n        }\n    };\n}\n\n/**\n * Create a single instance when module export is used directly via browserSync({});\n * This is mostly for back-compatibility, for also for the nicer api.\n * This will never be removed to ensure we never break user-land, but\n * we should discourage it's use.\n * @returns {*}\n */\nfunction initSingleton() {\n    var instance;\n    if (instances.length) {\n        instance = instances.filter(function (item) {\n            return item.name === \"singleton\";\n        });\n        if (instance.length) {\n            logger.error(\"{yellow:You tried to start Browsersync twice!} To create multiple instances, use {cyan:browserSync.create().init()\");\n            return instance;\n        }\n    }\n    var args = Array.prototype.slice.call(arguments);\n    singleton = create(\"singleton\", getSingletonEmitter());\n\n    if (singletonPlugins.length) {\n        singletonPlugins.forEach(function (obj) {\n            singleton.instance.registerPlugin.apply(singleton.instance, obj.args);\n        });\n    }\n\n    singleton.init.apply(null, args);\n    return singleton;\n}\n\n/**\n * @param {String} prop\n * @returns {Object|Boolean}\n */\nfunction getSingletonValue(prop) {\n    var single = getSingle(\"singleton\");\n    if (single) {\n        return single[prop];\n    }\n    return false;\n}\n\n/**\n * Get a single instance by name\n * @param {String} name\n * @returns {Object|Boolean}\n */\nfunction getSingle(name) {\n    if (instances.length) {\n        var match = instances.filter(function (item) {\n            return item.name === name;\n        });\n        if (match.length) {\n            return match[0];\n        }\n    }\n    return false;\n}\n\n/**\n * Create an instance of Browsersync\n * @param {String} [name]\n * @param {EventEmitter} [emitter]\n * @returns {{init: *, exit: (exit|exports), notify: *, reload: *, cleanup: *, emitter: (Browsersync.events|*), use: *}}\n */\nfunction create(name, emitter) {\n\n    name    = name    || new Date().getTime();\n    emitter = emitter || newEmitter();\n\n    var browserSync = new BrowserSync(emitter);\n\n    var instance = {\n        name:      name,\n        instance:  browserSync,\n        exit:      require(\"./lib/public/exit\")(browserSync),\n        notify:    require(\"./lib/public/notify\")(browserSync),\n        pause:     require(\"./lib/public/pause\")(browserSync),\n        resume:    require(\"./lib/public/resume\")(browserSync),\n        reload:    require(\"./lib/public/reload\")(emitter),\n        stream:    require(\"./lib/public/stream\")(emitter),\n        cleanup:   browserSync.cleanup.bind(browserSync),\n        use:       browserSync.registerPlugin.bind(browserSync),\n        getOption: browserSync.getOption.bind(browserSync),\n        emitter:   browserSync.events,\n        watch:     require(\"./lib/file-watcher\").watch\n    };\n\n    browserSync.publicInstance = instance;\n    instance.init = require(\"./lib/public/init\")(browserSync, name, pjson);\n\n    Object.defineProperty(instance, \"active\", {\n        get: function () {\n            return browserSync.active;\n        }\n    });\n\n    Object.defineProperty(instance, \"paused\", {\n        get: function () {\n            return browserSync.paused;\n        }\n    });\n\n    /**\n     * Access to client-side socket for emitting events\n     *\n     * @property sockets\n     */\n    Object.defineProperty(instance, \"sockets\", {\n        get: function () {\n            if (!browserSync.active) {\n                return {\n                    emit: function () {},\n                    on: function () {}\n                };\n            } else {\n                return browserSync.io.sockets;\n            }\n        }\n    });\n\n    instances.push(instance);\n\n    return instance;\n}\n\n/**\n * Reset the state of the module.\n * (should only be needed for test environments)\n */\nmodule.exports.reset = function () {\n    instances.forEach(function (item) {\n        item.cleanup();\n    });\n    instances        = [];\n    singletonPlugins = [];\n    singletonEmitter = false;\n    singleton        = false;\n};\n\n/**\n * @type {Array}\n */\nmodule.exports.instances = instances;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/browser-sync.js":"\"use strict\";\n\nvar hooks           = require(\"./hooks\");\nvar asyncTasks      = require(\"./async-tasks\");\nvar config          = require(\"./config\");\nvar connectUtils    = require(\"./connect-utils\");\nvar utils           = require(\"./utils\");\nvar logger          = require(\"./logger\");\n\nvar eachSeries      = utils.eachSeries;\nvar _               = require(\"../lodash.custom\");\nvar EE              = require(\"easy-extender\");\n\n/**\n * Required internal plugins.\n * Any of these can be overridden by deliberately\n * causing a name-clash.\n */\nvar defaultPlugins = {\n    \"logger\":        logger,\n    \"socket\":        require(\"./sockets\"),\n    \"file:watcher\":  require(\"./file-watcher\"),\n    \"server\":        require(\"./server\"),\n    \"tunnel\":        require(\"./tunnel\"),\n    \"client:script\": require(\"browser-sync-client\"),\n    \"UI\":            require(\"browser-sync-ui\")\n};\n\n/**\n * @constructor\n */\nvar BrowserSync = function (emitter) {\n\n    var bs      = this;\n\n    bs.cwd      = process.cwd();\n    bs.active   = false;\n    bs.paused   = false;\n    bs.config   = config;\n    bs.utils    = utils;\n    bs.events   = bs.emitter = emitter;\n\n    bs._userPlugins   = [];\n    bs._reloadQueue   = [];\n    bs._cleanupTasks  = [];\n    bs._browserReload = false;\n\n    // Plugin management\n    bs.pluginManager = new EE(defaultPlugins, hooks);\n};\n\n/**\n * Call a user-options provided callback\n * @param name\n */\nBrowserSync.prototype.callback = function (name) {\n\n    var bs  = this;\n    var cb  = bs.options.getIn([\"callbacks\", name]);\n\n    if (_.isFunction(cb)) {\n        cb.apply(bs.publicInstance, _.toArray(arguments).slice(1));\n    }\n};\n\n/**\n * @param {Map} options\n * @param {Function} cb\n * @returns {BrowserSync}\n */\nBrowserSync.prototype.init = function (options, cb) {\n\n    /**\n     * Safer access to `this`\n     * @type {BrowserSync}\n     */\n    var bs = this;\n\n    /**\n     * Set user-provided callback, or assign a noop\n     * @type {Function}\n     */\n    bs.cb  = cb || utils.defaultCallback;\n\n    /**\n     * Verify provided config.\n     * Some options are not compatible and will cause us to\n     * end the process.\n     */\n    if (!utils.verifyConfig(options, bs.cb)) {\n        return;\n    }\n\n    /**\n     * Save a reference to the original options\n     * @type {Map}\n     * @private\n     */\n    bs._options = options;\n\n    /**\n     * Set additional options that depend on what the\n     * user may of provided\n     * @type {Map}\n     */\n    bs.options  = require(\"./options\").update(options);\n\n    /**\n     * Kick off default plugins.\n     */\n    bs.pluginManager.init();\n\n    /**\n     * Create a base logger & debugger.\n     */\n    bs.logger   = bs.pluginManager.get(\"logger\")(bs.events, bs);\n    bs.debugger = bs.logger.clone({useLevelPrefixes: true});\n    bs.debug    = bs.debugger.debug;\n\n    /**\n     * Run each setup task in sequence\n     */\n    eachSeries(\n        asyncTasks,\n        taskRunner(bs),\n        tasksComplete(bs)\n    );\n\n    return this;\n};\n\n/**\n * Run 1 setup task.\n * Each task is a pure function.\n * They can return options or instance properties to set,\n * but they cannot set them directly.\n * @param {BrowserSync} bs\n * @returns {Function}\n */\nfunction taskRunner (bs) {\n\n    return function (item, cb) {\n\n        bs.debug(\"-> {yellow:Starting Step: \" + item.step);\n\n        /**\n         * Execute the current task.\n         */\n        item.fn(bs, executeTask);\n\n        function executeTask(err, out) {\n\n            /**\n             * Exit early if any task returned an error.\n             */\n            if (err) {\n                return cb(err);\n            }\n\n            /**\n             * Act on return values (such as options to be set,\n             * or instance properties to be set\n             */\n            if (out) {\n                handleOut(bs, out);\n            }\n\n            bs.debug(\"+  {green:Step Complete: \" + item.step);\n\n            cb();\n        }\n    };\n}\n\n/**\n * @param bs\n * @param out\n */\nfunction handleOut (bs, out) {\n    /**\n     * Set a single/many option.\n     */\n    if (out.options) {\n        setOptions(bs, out.options);\n    }\n\n    /**\n     * Any options returned that require path access?\n     */\n    if (out.optionsIn) {\n        out.optionsIn.forEach(function (item) {\n            bs.setOptionIn(item.path, item.value);\n        });\n    }\n\n    /**\n     * Any instance properties returned?\n     */\n    if (out.instance) {\n        Object.keys(out.instance).forEach(function (key) {\n            bs[key] = out.instance[key];\n        });\n    }\n}\n\n/**\n * Update the options Map\n * @param bs\n * @param options\n */\nfunction setOptions (bs, options) {\n\n    /**\n     * If multiple options were set, act on the immutable map\n     * in an efficient way\n     */\n    if (Object.keys(options).length > 1) {\n        bs.setMany(function (item) {\n            Object.keys(options).forEach(function (key) {\n                item.set(key, options[key]);\n                return item;\n            });\n        });\n    } else {\n        Object.keys(options).forEach(function (key) {\n            bs.setOption(key, options[key]);\n        });\n    }\n}\n\n/**\n * At this point, ALL async tasks have completed\n * @param {BrowserSync} bs\n * @returns {Function}\n */\nfunction tasksComplete (bs) {\n\n    return function (err) {\n\n        if (err) {\n            bs.logger.setOnce(\"useLevelPrefixes\", true).error(err.message);\n        }\n\n        /**\n         * Set active flag\n         */\n        bs.active = true;\n\n        /**\n         * @deprecated\n         */\n        bs.events.emit(\"init\", bs);\n\n        /**\n         * This is no-longer needed as the Callback now only resolves\n         * when everything (including slow things, like the tunnel) is ready.\n         * It's here purely for backwards compatibility.\n         * @deprecated\n         */\n        bs.events.emit(\"service:running\", {\n            options: bs.options,\n            baseDir: bs.options.getIn([\"server\", \"baseDir\"]),\n            type:    bs.options.get(\"mode\"),\n            port:    bs.options.get(\"port\"),\n            url:     bs.options.getIn([\"urls\", \"local\"]),\n            urls:    bs.options.get(\"urls\").toJS(),\n            tunnel:  bs.options.getIn([\"urls\", \"tunnel\"])\n        });\n\n        /**\n         * Call any option-provided callbacks\n         */\n        bs.callback(\"ready\", null, bs);\n\n        /**\n         * Finally, call the user-provided callback given as last arg\n         */\n        bs.cb(null, bs);\n    };\n}\n\n/**\n * @param module\n * @param opts\n * @param cb\n */\nBrowserSync.prototype.registerPlugin = function (module, opts, cb) {\n\n    var bs = this;\n\n    bs.pluginManager.registerPlugin(module, opts, cb);\n\n    if (module[\"plugin:name\"]) {\n        bs._userPlugins.push(module);\n    }\n};\n\n/**\n * Get a plugin by name\n * @param name\n */\nBrowserSync.prototype.getUserPlugin = function (name) {\n\n    var bs = this;\n\n    var items = bs.getUserPlugins(function (item) {\n        return item[\"plugin:name\"] === name;\n    });\n\n    if (items && items.length) {\n        return items[0];\n    }\n\n    return false;\n};\n\n/**\n * @param {Function} [filter]\n */\nBrowserSync.prototype.getUserPlugins = function (filter) {\n\n    var bs = this;\n\n    filter = filter || function () {\n        return true;\n    };\n\n    /**\n     * Transform Plugins option\n     */\n    bs.userPlugins = bs._userPlugins.filter(filter).map(function (plugin) {\n        return {\n            name: plugin[\"plugin:name\"],\n            active: plugin._enabled,\n            opts: bs.pluginManager.pluginOptions[plugin[\"plugin:name\"]]\n        };\n    });\n\n    return bs.userPlugins;\n};\n\n/**\n * Get middleware\n * @returns {*}\n */\nBrowserSync.prototype.getMiddleware = function (type) {\n\n    var types = {\n        \"connector\": connectUtils.socketConnector(this.options),\n        \"socket-js\": require(\"./snippet\").utils.getSocketScript()\n    };\n\n    if (type in types) {\n        return function (req, res) {\n            res.setHeader(\"Content-Type\", \"text/javascript\");\n            res.end(types[type]);\n        };\n    }\n};\n\n/**\n * Shortcut for pushing a file-serving middleware\n * onto the stack\n * @param {String} path\n * @param {{type: string, content: string}} props\n */\nvar _serveFileCount = 0;\nBrowserSync.prototype.serveFile = function (path, props) {\n\n    var bs = this;\n    var mode = bs.options.get(\"mode\");\n    var entry = {\n        handle: function (req, res) {\n            res.setHeader(\"Content-Type\", props.type);\n            res.end(props.content);\n        },\n        id: \"Browsersync - \" + _serveFileCount++,\n        route: path\n    };\n\n    bs._addMiddlewareToStack(entry);\n};\n\n/**\n * Add middlewares on the fly\n * @param {{route: string, handle: function, id?: string}}\n */\nBrowserSync.prototype._addMiddlewareToStack = function (entry) {\n    var bs = this;\n    if (bs.options.get(\"mode\") === \"proxy\") {\n        bs.app.stack.splice(bs.app.stack.length-1, 0, entry);\n    } else {\n        bs.app.stack.push(entry);\n    }\n};\n\nvar _addMiddlewareCount = 0;\nBrowserSync.prototype.addMiddleware = function (route, handle, opts) {\n\n    var bs   = this;\n\n    if (!bs.app) {\n        return;\n    }\n\n    opts = opts || {};\n\n    if (!opts.id) {\n        opts.id = \"bs-mw-\" + _addMiddlewareCount++;\n    }\n\n    if (route === \"*\") {\n        route = \"\";\n    }\n\n    var entry = {\n        id: opts.id,\n        route: route,\n        handle: handle\n    };\n\n    if (opts.override) {\n        entry.override = true;\n    }\n\n    bs.options = bs.options.update(\"middleware\", function (mw) {\n        if (bs.options.get(\"mode\") === \"proxy\") {\n            return mw.insert(mw.size-1, entry);\n        }\n        return mw.concat(entry);\n    });\n\n    bs.resetMiddlewareStack();\n};\n\n/**\n * Remove middlewares on the fly\n * @param {String} id\n * @returns {Server}\n */\nBrowserSync.prototype.removeMiddleware = function (id) {\n\n    var bs = this;\n\n    if (!bs.app) {\n        return;\n    }\n\n    bs.options = bs.options.update(\"middleware\", function (mw) {\n        return mw.filter(function (mw) {\n            return mw.id !== id;\n        });\n    });\n\n    bs.resetMiddlewareStack();\n};\n\n/**\n * Middleware for socket connection (external usage)\n * @param opts\n * @returns {*}\n */\nBrowserSync.prototype.getSocketConnector = function (opts) {\n\n    var bs = this;\n\n    return function (req, res) {\n        res.setHeader(\"Content-Type\", \"text/javascript\");\n        res.end(bs.getExternalSocketConnector(opts));\n    };\n};\n\n/**\n * Socket connector as a string\n * @param {Object} opts\n * @returns {*}\n */\nBrowserSync.prototype.getExternalSocketConnector = function (opts) {\n\n    var bs = this;\n\n    return connectUtils.socketConnector(\n        bs.options.withMutations(function (item) {\n            item.set(\"socket\", item.get(\"socket\").merge(opts));\n            if (!bs.options.getIn([\"proxy\", \"ws\"])) {\n                item.set(\"mode\", \"snippet\");\n            }\n        })\n    );\n};\n\n/**\n * Socket io as string (for embedding)\n * @returns {*}\n */\nBrowserSync.prototype.getSocketIoScript = function () {\n\n    return require(\"./snippet\").utils.getSocketScript();\n};\n\n/**\n * Callback helper\n * @param name\n */\nBrowserSync.prototype.getOption = function (name) {\n\n    this.debug(\"Getting option: {magenta:%s\", name);\n    return this.options.get(name);\n};\n\n/**\n * Callback helper\n * @param path\n */\nBrowserSync.prototype.getOptionIn = function (path) {\n\n    this.debug(\"Getting option via path: {magenta:%s\", path);\n    return this.options.getIn(path);\n};\n\n/**\n * @returns {BrowserSync.options}\n */\nBrowserSync.prototype.getOptions = function () {\n    return this.options;\n};\n\n/**\n * @returns {BrowserSync.options}\n */\nBrowserSync.prototype.getLogger = logger.getLogger;\n\n/**\n * @param {String} name\n * @param {*} value\n * @returns {BrowserSync.options|*}\n */\nBrowserSync.prototype.setOption = function (name, value, opts) {\n\n    var bs = this;\n\n    opts = opts || {};\n\n    bs.debug(\"Setting Option: {cyan:%s} - {magenta:%s\", name, value.toString());\n\n    bs.options = bs.options.set(name, value);\n\n    if (!opts.silent) {\n        bs.events.emit(\"options:set\", {path: name, value: value, options: bs.options});\n    }\n    return this.options;\n};\n\n/**\n * @param path\n * @param value\n * @param opts\n * @returns {Map|*|BrowserSync.options}\n */\nBrowserSync.prototype.setOptionIn = function (path, value, opts) {\n\n    var bs = this;\n\n    opts = opts || {};\n\n    bs.debug(\"Setting Option: {cyan:%s} - {magenta:%s\", path.join(\".\"), value.toString());\n    bs.options = bs.options.setIn(path, value);\n    if (!opts.silent) {\n        bs.events.emit(\"options:set\", {path: path, value: value, options: bs.options});\n    }\n    return bs.options;\n};\n\n/**\n * Set multiple options with mutations\n * @param fn\n * @param opts\n * @returns {Map|*}\n */\nBrowserSync.prototype.setMany = function (fn, opts) {\n\n    var bs = this;\n\n    opts = opts || {};\n\n    bs.debug(\"Setting multiple Options\");\n    bs.options = bs.options.withMutations(fn);\n    if (!opts.silent) {\n        bs.events.emit(\"options:set\", {options: bs.options.toJS()});\n    }\n    return this.options;\n};\n\nBrowserSync.prototype.addRewriteRule = function (rule) {\n    var bs = this;\n\n    bs.options = bs.options.update(\"rewriteRules\", function (rules) {\n        return rules.concat(rule);\n    });\n\n    bs.resetMiddlewareStack();\n};\n\nBrowserSync.prototype.removeRewriteRule = function (id) {\n    var bs = this;\n    bs.options = bs.options.update(\"rewriteRules\", function (rules) {\n        return rules.filter(function (rule) {\n            return rule.id !== id;\n        });\n    });\n\n    bs.resetMiddlewareStack();\n};\n\nBrowserSync.prototype.setRewriteRules = function (rules) {\n    var bs = this;\n    bs.options = bs.options.update(\"rewriteRules\", function (_) {\n        return rules;\n    });\n\n    bs.resetMiddlewareStack();\n};\n\n/**\n * Add a new rewrite rule to the stack\n * @param {Object} rule\n */\nBrowserSync.prototype.resetMiddlewareStack = function () {\n\n    var bs = this;\n    var middlewares = require(\"./server/utils\").getMiddlewares(bs, bs.options);\n\n    bs.app.stack = middlewares;\n};\n\n/**\n * @param fn\n */\nBrowserSync.prototype.registerCleanupTask = function (fn) {\n\n    this._cleanupTasks.push(fn);\n};\n\n/**\n * Instance Cleanup\n */\nBrowserSync.prototype.cleanup = function (cb) {\n\n    var bs = this;\n    if (!bs.active) {\n        return;\n    }\n\n    // Remove all event listeners\n    if (bs.events) {\n        bs.debug(\"Removing event listeners...\");\n        bs.events.removeAllListeners();\n    }\n\n    // Close any core file watchers\n    if (bs.watchers) {\n        Object.keys(bs.watchers).forEach(function (key) {\n            bs.watchers[key].watchers.forEach(function (watcher) {\n                watcher.close();\n            });\n        });\n    }\n\n    // Run any additional clean up tasks\n    bs._cleanupTasks.forEach(function (fn) {\n        if (_.isFunction(fn)) {\n            fn(bs);\n        }\n    });\n\n    // Reset the flag\n    bs.debug(\"Setting {magenta:active: false\");\n    bs.active = false;\n    bs.paused = false;\n\n    bs.pluginManager.plugins        = {};\n    bs.pluginManager.pluginOptions  = {};\n    bs.pluginManager.defaultPlugins = defaultPlugins;\n\n    bs._userPlugins                = [];\n    bs.userPlugins                 = [];\n    bs._reloadTimer                = undefined;\n    bs._reloadQueue                = [];\n    bs._cleanupTasks               = [];\n\n    if (_.isFunction(cb)) {\n        cb(null, bs);\n    }\n};\n\nmodule.exports = BrowserSync;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/hooks.js":"\"use strict\";\n\nvar _            = require(\"../lodash.custom\");\nvar Immutable    = require(\"immutable\");\nvar snippetUtils = require(\"./snippet\").utils;\n\nmodule.exports = {\n\n    /**\n     *\n     * @this {BrowserSync}\n     * @returns {String}\n     */\n    \"client:js\": function (hooks, data) {\n\n        var js  = snippetUtils.getClientJs(data.port, data.options);\n\n        return hooks.reduce(function (joined, hook) {\n            return joined + hook;\n        }, js);\n    },\n    /**\n     * @this {BrowserSync}\n     * @returns {Array}\n     */\n    \"client:events\": function (hooks, clientEvents) {\n\n        hooks.forEach(function (hook) {\n\n            var result = hook(this);\n\n            if (Array.isArray(result)) {\n                clientEvents = _.union(clientEvents, result);\n            } else {\n                clientEvents.push(result);\n            }\n        }, this);\n\n        return clientEvents;\n    },\n    /**\n     * @returns {Array}\n     */\n    \"server:middleware\": function (hooks, initial) {\n\n        initial = initial || [];\n\n        _.each(hooks, function (hook) {\n\n            var result = hook(this);\n\n            if (Array.isArray(result)) {\n                result.forEach(function (res) {\n                    if (_.isFunction(res)) {\n                        initial = initial.push(res);\n                    }\n                });\n\n            } else {\n                if (_.isFunction(result)) {\n                    initial = initial.push(result);\n                }\n            }\n        }, this);\n\n        return initial;\n    },\n    /**\n     * @param {Array} hooks\n     * @param {Map|List} initial\n     * @param pluginOptions\n     * @returns {any}\n     */\n    \"files:watch\": function (hooks, initial, pluginOptions) {\n\n        var opts;\n\n        if (pluginOptions) {\n            opts = Immutable.fromJS(pluginOptions);\n            opts.forEach(function (value, key) {\n                if (!value) {\n                    return;\n                }\n                var files = value.get(\"files\");\n                if (files) {\n                    var fileArg = require(\"./cli/cli-options\").makeFilesArg(files);\n                    if (fileArg) {\n                        initial = initial.set(key, Immutable.fromJS(fileArg));\n                    }\n                }\n            });\n        }\n\n        return initial;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lodash.custom.js":"/**\n * @license\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash include=\"isUndefined,isFunction,toArray,includes,union,each,isString,merge,isObject,set\" exports=\"node\"`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.13.1';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used to compose bitmasks for comparison styles. */\n  var UNORDERED_COMPARE_FLAG = 1,\n      PARTIAL_COMPARE_FLAG = 2;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(\\.|\\[\\])(?:\\4|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n  /** Used to compose unicode capture groups. */\n  var rsAstral = '[' + rsAstralRange + ']',\n      rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseInt = parseInt;\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = checkGlobal(typeof global == 'object' && global);\n\n  /** Detect free variable `self`. */\n  var freeSelf = checkGlobal(typeof self == 'object' && self);\n\n  /** Detect `this` as the global object. */\n  var thisGlobal = checkGlobal(typeof this == 'object' && this);\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || thisGlobal || Function('return this')();\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Adds the key-value `pair` to `map`.\n   *\n   * @private\n   * @param {Object} map The map to modify.\n   * @param {Array} pair The key-value pair to add.\n   * @returns {Object} Returns `map`.\n   */\n  function addMapEntry(map, pair) {\n    // Don't return `Map#set` because it doesn't return the map instance in IE 11.\n    map.set(pair[0], pair[1]);\n    return map;\n  }\n\n  /**\n   * Adds `value` to `set`.\n   *\n   * @private\n   * @param {Object} set The set to modify.\n   * @param {*} value The value to add.\n   * @returns {Object} Returns `set`.\n   */\n  function addSetEntry(set, value) {\n    set.add(value);\n    return set;\n  }\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    var length = args.length;\n    switch (length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to search.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array ? array.length : 0;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to search.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array ? array.length : 0,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    if (value !== value) {\n      return indexOfNaN(array, fromIndex);\n    }\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a cache value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Checks if `value` is a global object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {null|Object} Returns `value` if it's a global object, else `null`.\n   */\n  function checkGlobal(value) {\n    return (value && value.Object === Object) ? value : null;\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n   */\n  function indexOfNaN(array, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var other = array[index];\n      if (other !== other) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if `value` is a host object in IE < 9.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n   */\n  function isHostObject(value) {\n    // Many host objects are `Object` objects that can coerce to strings\n    // despite having improperly defined `toString` methods.\n    var result = false;\n    if (value != null && typeof value.toString != 'function') {\n      try {\n        result = !!(value + '');\n      } catch (e) {}\n    }\n    return result;\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return string.match(reComplexSymbol);\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype,\n      objectProto = Object.prototype;\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = root['__core-js_shared__'];\n\n  /** Used to detect methods masquerading as native. */\n  var maskSrcKey = (function() {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n    return uid ? ('Symbol(src)_1.' + uid) : '';\n  }());\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = Function.prototype.toString;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /** Used to infer the `Object` constructor. */\n  var objectCtorString = funcToString.call(Object);\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var objectToString = objectProto.toString;\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp('^' +\n    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n    .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n  );\n\n  /** Built-in value references. */\n  var Buffer = moduleExports ? root.Buffer : undefined,\n      Reflect = root.Reflect,\n      Symbol = root.Symbol,\n      Uint8Array = root.Uint8Array,\n      enumerate = Reflect ? Reflect.enumerate : undefined,\n      getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined,\n      objectCreate = Object.create,\n      propertyIsEnumerable = objectProto.propertyIsEnumerable,\n      splice = arrayProto.splice;\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeGetPrototype = Object.getPrototypeOf,\n      nativeKeys = Object.keys,\n      nativeMax = Math.max;\n\n  /* Built-in method references that are verified to be native. */\n  var DataView = getNative(root, 'DataView'),\n      Map = getNative(root, 'Map'),\n      Promise = getNative(root, 'Promise'),\n      Set = getNative(root, 'Set'),\n      WeakMap = getNative(root, 'WeakMap'),\n      nativeCreate = getNative(Object, 'create');\n\n  /** Used to lookup unminified function names. */\n  var realNames = {};\n\n  /** Used to detect maps, sets, and weakmaps. */\n  var dataViewCtorString = toSource(DataView),\n      mapCtorString = toSource(Map),\n      promiseCtorString = toSource(Promise),\n      setCtorString = toSource(Set),\n      weakMapCtorString = toSource(WeakMap);\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = Symbol ? Symbol.prototype : undefined,\n      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n      symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a `lodash` object which wraps `value` to enable implicit method\n   * chain sequences. Methods that operate on and return arrays, collections,\n   * and functions can be chained together. Methods that retrieve a single value\n   * or may return a primitive value will automatically end the chain sequence\n   * and return the unwrapped value. Otherwise, the value must be unwrapped\n   * with `_#value`.\n   *\n   * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n   * enabled using `_.chain`.\n   *\n   * The execution of chained methods is lazy, that is, it's deferred until\n   * `_#value` is implicitly or explicitly called.\n   *\n   * Lazy evaluation allows several methods to support shortcut fusion.\n   * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n   * the creation of intermediate arrays and can greatly reduce the number of\n   * iteratee executions. Sections of a chain sequence qualify for shortcut\n   * fusion if the section is applied to an array of at least `200` elements\n   * and any iteratees accept only one argument. The heuristic for whether a\n   * section qualifies for shortcut fusion is subject to change.\n   *\n   * Chaining is supported in custom builds as long as the `_#value` method is\n   * directly or indirectly included in the build.\n   *\n   * In addition to lodash methods, wrappers have `Array` and `String` methods.\n   *\n   * The wrapper `Array` methods are:\n   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n   *\n   * The wrapper `String` methods are:\n   * `replace` and `split`\n   *\n   * The wrapper methods that support shortcut fusion are:\n   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n   *\n   * The chainable wrapper methods are:\n   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n   * `zipObject`, `zipObjectDeep`, and `zipWith`\n   *\n   * The wrapper methods that are **not** chainable by default are:\n   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `divide`, `each`,\n   * `eachRight`, `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`,\n   * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`,\n   * `floor`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,\n   * `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`,\n   * `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`,\n   * `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`,\n   * `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,\n   * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`,\n   * `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n   * `upperFirst`, `value`, and `words`\n   *\n   * @name _\n   * @constructor\n   * @category Seq\n   * @param {*} value The value to wrap in a `lodash` instance.\n   * @returns {Object} Returns the new `lodash` wrapper instance.\n   * @example\n   *\n   * function square(n) {\n   *   return n * n;\n   * }\n   *\n   * var wrapped = _([1, 2, 3]);\n   *\n   * // Returns an unwrapped value.\n   * wrapped.reduce(_.add);\n   * // => 6\n   *\n   * // Returns a wrapped value.\n   * var squares = wrapped.map(square);\n   *\n   * _.isArray(squares);\n   * // => false\n   *\n   * _.isArray(squares.value());\n   * // => true\n   */\n  function lodash() {\n    // No operation performed.\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Hash(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n  function hashClear() {\n    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  }\n\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function hashDelete(key) {\n    return this.has(key) && delete this.__data__[key];\n  }\n\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function hashGet(key) {\n    var data = this.__data__;\n    if (nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n    return hasOwnProperty.call(data, key) ? data[key] : undefined;\n  }\n\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function hashHas(key) {\n    var data = this.__data__;\n    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n  }\n\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n  function hashSet(key, value) {\n    var data = this.__data__;\n    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n    return this;\n  }\n\n  // Add methods to `Hash`.\n  Hash.prototype.clear = hashClear;\n  Hash.prototype['delete'] = hashDelete;\n  Hash.prototype.get = hashGet;\n  Hash.prototype.has = hashHas;\n  Hash.prototype.set = hashSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function ListCache(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n  function listCacheClear() {\n    this.__data__ = [];\n  }\n\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n    return true;\n  }\n\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    return index < 0 ? undefined : data[index][1];\n  }\n\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1;\n  }\n\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n    return this;\n  }\n\n  // Add methods to `ListCache`.\n  ListCache.prototype.clear = listCacheClear;\n  ListCache.prototype['delete'] = listCacheDelete;\n  ListCache.prototype.get = listCacheGet;\n  ListCache.prototype.has = listCacheHas;\n  ListCache.prototype.set = listCacheSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function MapCache(entries) {\n    var index = -1,\n        length = entries ? entries.length : 0;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n  function mapCacheClear() {\n    this.__data__ = {\n      'hash': new Hash,\n      'map': new (Map || ListCache),\n      'string': new Hash\n    };\n  }\n\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function mapCacheDelete(key) {\n    return getMapData(this, key)['delete'](key);\n  }\n\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key);\n  }\n\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key);\n  }\n\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n  function mapCacheSet(key, value) {\n    getMapData(this, key).set(key, value);\n    return this;\n  }\n\n  // Add methods to `MapCache`.\n  MapCache.prototype.clear = mapCacheClear;\n  MapCache.prototype['delete'] = mapCacheDelete;\n  MapCache.prototype.get = mapCacheGet;\n  MapCache.prototype.has = mapCacheHas;\n  MapCache.prototype.set = mapCacheSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   *\n   * Creates an array cache object to store unique values.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [values] The values to cache.\n   */\n  function SetCache(values) {\n    var index = -1,\n        length = values ? values.length : 0;\n\n    this.__data__ = new MapCache;\n    while (++index < length) {\n      this.add(values[index]);\n    }\n  }\n\n  /**\n   * Adds `value` to the array cache.\n   *\n   * @private\n   * @name add\n   * @memberOf SetCache\n   * @alias push\n   * @param {*} value The value to cache.\n   * @returns {Object} Returns the cache instance.\n   */\n  function setCacheAdd(value) {\n    this.__data__.set(value, HASH_UNDEFINED);\n    return this;\n  }\n\n  /**\n   * Checks if `value` is in the array cache.\n   *\n   * @private\n   * @name has\n   * @memberOf SetCache\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `true` if `value` is found, else `false`.\n   */\n  function setCacheHas(value) {\n    return this.__data__.has(value);\n  }\n\n  // Add methods to `SetCache`.\n  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n  SetCache.prototype.has = setCacheHas;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a stack cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Stack(entries) {\n    this.__data__ = new ListCache(entries);\n  }\n\n  /**\n   * Removes all key-value entries from the stack.\n   *\n   * @private\n   * @name clear\n   * @memberOf Stack\n   */\n  function stackClear() {\n    this.__data__ = new ListCache;\n  }\n\n  /**\n   * Removes `key` and its value from the stack.\n   *\n   * @private\n   * @name delete\n   * @memberOf Stack\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function stackDelete(key) {\n    return this.__data__['delete'](key);\n  }\n\n  /**\n   * Gets the stack value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Stack\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function stackGet(key) {\n    return this.__data__.get(key);\n  }\n\n  /**\n   * Checks if a stack value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Stack\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function stackHas(key) {\n    return this.__data__.has(key);\n  }\n\n  /**\n   * Sets the stack `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Stack\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the stack cache instance.\n   */\n  function stackSet(key, value) {\n    var cache = this.__data__;\n    if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {\n      cache = this.__data__ = new MapCache(cache.__data__);\n    }\n    cache.set(key, value);\n    return this;\n  }\n\n  // Add methods to `Stack`.\n  Stack.prototype.clear = stackClear;\n  Stack.prototype['delete'] = stackDelete;\n  Stack.prototype.get = stackGet;\n  Stack.prototype.has = stackHas;\n  Stack.prototype.set = stackSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * This function is like `assignValue` except that it doesn't assign\n   * `undefined` values.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignMergeValue(object, key, value) {\n    if ((value !== undefined && !eq(object[key], value)) ||\n        (typeof key == 'number' && value === undefined && !(key in object))) {\n      object[key] = value;\n    }\n  }\n\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignValue(object, key, value) {\n    var objValue = object[key];\n    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n        (value === undefined && !(key in object))) {\n      object[key] = value;\n    }\n  }\n\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function assocIndexOf(array, key) {\n    var length = array.length;\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.assign` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssign(object, source) {\n    return object && copyObject(source, keys(source), object);\n  }\n\n  /**\n   * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n   * traversed objects.\n   *\n   * @private\n   * @param {*} value The value to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @param {boolean} [isFull] Specify a clone including symbols.\n   * @param {Function} [customizer] The function to customize cloning.\n   * @param {string} [key] The key of `value`.\n   * @param {Object} [object] The parent object of `value`.\n   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n   * @returns {*} Returns the cloned value.\n   */\n  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n    var result;\n    if (customizer) {\n      result = object ? customizer(value, key, object, stack) : customizer(value);\n    }\n    if (result !== undefined) {\n      return result;\n    }\n    if (!isObject(value)) {\n      return value;\n    }\n    var isArr = isArray(value);\n    if (isArr) {\n      result = initCloneArray(value);\n      if (!isDeep) {\n        return copyArray(value, result);\n      }\n    } else {\n      var tag = getTag(value),\n          isFunc = tag == funcTag || tag == genTag;\n\n      if (isBuffer(value)) {\n        return cloneBuffer(value, isDeep);\n      }\n      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n        if (isHostObject(value)) {\n          return object ? value : {};\n        }\n        result = initCloneObject(isFunc ? {} : value);\n        if (!isDeep) {\n          return copySymbols(value, baseAssign(result, value));\n        }\n      } else {\n        if (!cloneableTags[tag]) {\n          return object ? value : {};\n        }\n        result = initCloneByTag(value, tag, baseClone, isDeep);\n      }\n    }\n    // Check for circular references and return its corresponding clone.\n    stack || (stack = new Stack);\n    var stacked = stack.get(value);\n    if (stacked) {\n      return stacked;\n    }\n    stack.set(value, result);\n\n    if (!isArr) {\n      var props = isFull ? getAllKeys(value) : keys(value);\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    arrayEach(props || value, function(subValue, key) {\n      if (props) {\n        key = subValue;\n        subValue = value[key];\n      }\n      assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.create` without support for assigning\n   * properties to the created object.\n   *\n   * @private\n   * @param {Object} prototype The object to inherit from.\n   * @returns {Object} Returns the new object.\n   */\n  function baseCreate(proto) {\n    return isObject(proto) ? objectCreate(proto) : {};\n  }\n\n  /**\n   * The base implementation of `_.forEach` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   */\n  var baseEach = createBaseEach(baseForOwn);\n\n  /**\n   * The base implementation of `_.flatten` with support for restricting flattening.\n   *\n   * @private\n   * @param {Array} array The array to flatten.\n   * @param {number} depth The maximum recursion depth.\n   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n   * @param {Array} [result=[]] The initial result value.\n   * @returns {Array} Returns the new flattened array.\n   */\n  function baseFlatten(array, depth, predicate, isStrict, result) {\n    var index = -1,\n        length = array.length;\n\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n\n    while (++index < length) {\n      var value = array[index];\n      if (depth > 0 && predicate(value)) {\n        if (depth > 1) {\n          // Recursively flatten arrays (susceptible to call stack limits).\n          baseFlatten(value, depth - 1, predicate, isStrict, result);\n        } else {\n          arrayPush(result, value);\n        }\n      } else if (!isStrict) {\n        result[result.length] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `baseForOwn` which iterates over `object`\n   * properties returned by `keysFunc` and invokes `iteratee` for each property.\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @returns {Object} Returns `object`.\n   */\n  var baseFor = createBaseFor();\n\n  /**\n   * The base implementation of `_.forOwn` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Object} Returns `object`.\n   */\n  function baseForOwn(object, iteratee) {\n    return object && baseFor(object, iteratee, keys);\n  }\n\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n  function baseGet(object, path) {\n    path = isKey(path, object) ? [path] : castPath(path);\n\n    var index = 0,\n        length = path.length;\n\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])];\n    }\n    return (index && index == length) ? object : undefined;\n  }\n\n  /**\n   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n   * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @param {Function} symbolsFunc The function to get the symbols of `object`.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n  }\n\n  /**\n   * The base implementation of `_.has` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHas(object, key) {\n    // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,\n    // that are composed entirely of index properties, return `false` for\n    // `hasOwnProperty` checks of them.\n    return object != null &&\n      (hasOwnProperty.call(object, key) ||\n        (typeof object == 'object' && key in object && getPrototype(object) === null));\n  }\n\n  /**\n   * The base implementation of `_.hasIn` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object);\n  }\n\n  /**\n   * The base implementation of `_.isEqual` which supports partial comparisons\n   * and tracks traversed objects.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {boolean} [bitmask] The bitmask of comparison flags.\n   *  The bitmask may be composed of the following flags:\n   *     1 - Unordered comparison\n   *     2 - Partial comparison\n   * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   */\n  function baseIsEqual(value, other, customizer, bitmask, stack) {\n    if (value === other) {\n      return true;\n    }\n    if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n      return value !== value && other !== other;\n    }\n    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n  }\n\n  /**\n   * A specialized version of `baseIsEqual` for arrays and objects which performs\n   * deep comparisons and tracks traversed objects enabling objects with circular\n   * references to be compared.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n   *  for more details.\n   * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n    var objIsArr = isArray(object),\n        othIsArr = isArray(other),\n        objTag = arrayTag,\n        othTag = arrayTag;\n\n    if (!objIsArr) {\n      objTag = getTag(object);\n      objTag = objTag == argsTag ? objectTag : objTag;\n    }\n    if (!othIsArr) {\n      othTag = getTag(other);\n      othTag = othTag == argsTag ? objectTag : othTag;\n    }\n    var objIsObj = objTag == objectTag && !isHostObject(object),\n        othIsObj = othTag == objectTag && !isHostObject(other),\n        isSameTag = objTag == othTag;\n\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack);\n      return (objIsArr || isTypedArray(object))\n        ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n        : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n    }\n    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n            othUnwrapped = othIsWrapped ? other.value() : other;\n\n        stack || (stack = new Stack);\n        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n      }\n    }\n    if (!isSameTag) {\n      return false;\n    }\n    stack || (stack = new Stack);\n    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n  }\n\n  /**\n   * The base implementation of `_.isMatch` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property values to match.\n   * @param {Array} matchData The property names, values, and compare flags to match.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n   */\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n        length = index,\n        noCustomizer = !customizer;\n\n    if (object == null) {\n      return !length;\n    }\n    object = Object(object);\n    while (index--) {\n      var data = matchData[index];\n      if ((noCustomizer && data[2])\n            ? data[1] !== object[data[0]]\n            : !(data[0] in object)\n          ) {\n        return false;\n      }\n    }\n    while (++index < length) {\n      data = matchData[index];\n      var key = data[0],\n          objValue = object[key],\n          srcValue = data[1];\n\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false;\n        }\n      } else {\n        var stack = new Stack;\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack);\n        }\n        if (!(result === undefined\n              ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n              : result\n            )) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false;\n    }\n    var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n\n  /**\n   * The base implementation of `_.iteratee`.\n   *\n   * @private\n   * @param {*} [value=_.identity] The value to convert to an iteratee.\n   * @returns {Function} Returns the iteratee.\n   */\n  function baseIteratee(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == 'function') {\n      return value;\n    }\n    if (value == null) {\n      return identity;\n    }\n    if (typeof value == 'object') {\n      return isArray(value)\n        ? baseMatchesProperty(value[0], value[1])\n        : baseMatches(value);\n    }\n    return property(value);\n  }\n\n  /**\n   * The base implementation of `_.keys` which doesn't skip the constructor\n   * property of prototypes or treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeys(object) {\n    return nativeKeys(Object(object));\n  }\n\n  /**\n   * The base implementation of `_.keysIn` which doesn't skip the constructor\n   * property of prototypes or treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeysIn(object) {\n    object = object == null ? object : Object(object);\n\n    var result = [];\n    for (var key in object) {\n      result.push(key);\n    }\n    return result;\n  }\n\n  // Fallback for IE < 9 with es6-shim.\n  if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {\n    baseKeysIn = function(object) {\n      return iteratorToArray(enumerate(object));\n    };\n  }\n\n  /**\n   * The base implementation of `_.matches` which doesn't clone `source`.\n   *\n   * @private\n   * @param {Object} source The object of property values to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatches(source) {\n    var matchData = getMatchData(source);\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n    return function(object) {\n      return object === source || baseIsMatch(object, source, matchData);\n    };\n  }\n\n  /**\n   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n   *\n   * @private\n   * @param {string} path The path of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue);\n    }\n    return function(object) {\n      var objValue = get(object, path);\n      return (objValue === undefined && objValue === srcValue)\n        ? hasIn(object, path)\n        : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n    };\n  }\n\n  /**\n   * The base implementation of `_.merge` without support for multiple sources.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @param {number} srcIndex The index of `source`.\n   * @param {Function} [customizer] The function to customize merged values.\n   * @param {Object} [stack] Tracks traversed source values and their merged\n   *  counterparts.\n   */\n  function baseMerge(object, source, srcIndex, customizer, stack) {\n    if (object === source) {\n      return;\n    }\n    if (!(isArray(source) || isTypedArray(source))) {\n      var props = keysIn(source);\n    }\n    arrayEach(props || source, function(srcValue, key) {\n      if (props) {\n        key = srcValue;\n        srcValue = source[key];\n      }\n      if (isObject(srcValue)) {\n        stack || (stack = new Stack);\n        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n      }\n      else {\n        var newValue = customizer\n          ? customizer(object[key], srcValue, (key + ''), object, source, stack)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = srcValue;\n        }\n        assignMergeValue(object, key, newValue);\n      }\n    });\n  }\n\n  /**\n   * A specialized version of `baseMerge` for arrays and objects which performs\n   * deep merges and tracks traversed objects enabling objects with circular\n   * references to be merged.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @param {string} key The key of the value to merge.\n   * @param {number} srcIndex The index of `source`.\n   * @param {Function} mergeFunc The function to merge values.\n   * @param {Function} [customizer] The function to customize assigned values.\n   * @param {Object} [stack] Tracks traversed source values and their merged\n   *  counterparts.\n   */\n  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n    var objValue = object[key],\n        srcValue = source[key],\n        stacked = stack.get(srcValue);\n\n    if (stacked) {\n      assignMergeValue(object, key, stacked);\n      return;\n    }\n    var newValue = customizer\n      ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n      : undefined;\n\n    var isCommon = newValue === undefined;\n\n    if (isCommon) {\n      newValue = srcValue;\n      if (isArray(srcValue) || isTypedArray(srcValue)) {\n        if (isArray(objValue)) {\n          newValue = objValue;\n        }\n        else if (isArrayLikeObject(objValue)) {\n          newValue = copyArray(objValue);\n        }\n        else {\n          isCommon = false;\n          newValue = baseClone(srcValue, true);\n        }\n      }\n      else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n        if (isArguments(objValue)) {\n          newValue = toPlainObject(objValue);\n        }\n        else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {\n          isCommon = false;\n          newValue = baseClone(srcValue, true);\n        }\n        else {\n          newValue = objValue;\n        }\n      }\n      else {\n        isCommon = false;\n      }\n    }\n    stack.set(srcValue, newValue);\n\n    if (isCommon) {\n      // Recursively merge objects and arrays (susceptible to call stack limits).\n      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    }\n    stack['delete'](srcValue);\n    assignMergeValue(object, key, newValue);\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * A specialized version of `baseProperty` which supports deep paths.\n   *\n   * @private\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyDeep(path) {\n    return function(object) {\n      return baseGet(object, path);\n    };\n  }\n\n  /**\n   * The base implementation of `_.set`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @param {Function} [customizer] The function to customize path creation.\n   * @returns {Object} Returns `object`.\n   */\n  function baseSet(object, path, value, customizer) {\n    path = isKey(path, object) ? [path] : castPath(path);\n\n    var index = -1,\n        length = path.length,\n        lastIndex = length - 1,\n        nested = object;\n\n    while (nested != null && ++index < length) {\n      var key = toKey(path[index]);\n      if (isObject(nested)) {\n        var newValue = value;\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = objValue == null\n              ? (isIndex(path[index + 1]) ? [] : {})\n              : objValue;\n          }\n        }\n        assignValue(nested, key, newValue);\n      }\n      nested = nested[key];\n    }\n    return object;\n  }\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n  }\n\n  /**\n   * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new duplicate free array.\n   */\n  function baseUniq(array, iteratee, comparator) {\n    var index = -1,\n        includes = arrayIncludes,\n        length = array.length,\n        isCommon = true,\n        result = [],\n        seen = result;\n\n    if (comparator) {\n      isCommon = false;\n      includes = arrayIncludesWith;\n    }\n    else if (length >= LARGE_ARRAY_SIZE) {\n      var set = iteratee ? null : createSet(array);\n      if (set) {\n        return setToArray(set);\n      }\n      isCommon = false;\n      includes = cacheHas;\n      seen = new SetCache;\n    }\n    else {\n      seen = iteratee ? [] : result;\n    }\n    outer:\n    while (++index < length) {\n      var value = array[index],\n          computed = iteratee ? iteratee(value) : value;\n\n      value = (comparator || value !== 0) ? value : 0;\n      if (isCommon && computed === computed) {\n        var seenIndex = seen.length;\n        while (seenIndex--) {\n          if (seen[seenIndex] === computed) {\n            continue outer;\n          }\n        }\n        if (iteratee) {\n          seen.push(computed);\n        }\n        result.push(value);\n      }\n      else if (!includes(seen, computed, comparator)) {\n        if (seen !== result) {\n          seen.push(computed);\n        }\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {Array} Returns the cast property path array.\n   */\n  function castPath(value) {\n    return isArray(value) ? value : stringToPath(value);\n  }\n\n  /**\n   * Creates a clone of  `buffer`.\n   *\n   * @private\n   * @param {Buffer} buffer The buffer to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Buffer} Returns the cloned buffer.\n   */\n  function cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n      return buffer.slice();\n    }\n    var result = new buffer.constructor(buffer.length);\n    buffer.copy(result);\n    return result;\n  }\n\n  /**\n   * Creates a clone of `arrayBuffer`.\n   *\n   * @private\n   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n   * @returns {ArrayBuffer} Returns the cloned array buffer.\n   */\n  function cloneArrayBuffer(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n    return result;\n  }\n\n  /**\n   * Creates a clone of `dataView`.\n   *\n   * @private\n   * @param {Object} dataView The data view to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned data view.\n   */\n  function cloneDataView(dataView, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n  }\n\n  /**\n   * Creates a clone of `map`.\n   *\n   * @private\n   * @param {Object} map The map to clone.\n   * @param {Function} cloneFunc The function to clone values.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned map.\n   */\n  function cloneMap(map, isDeep, cloneFunc) {\n    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n    return arrayReduce(array, addMapEntry, new map.constructor);\n  }\n\n  /**\n   * Creates a clone of `regexp`.\n   *\n   * @private\n   * @param {Object} regexp The regexp to clone.\n   * @returns {Object} Returns the cloned regexp.\n   */\n  function cloneRegExp(regexp) {\n    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n    result.lastIndex = regexp.lastIndex;\n    return result;\n  }\n\n  /**\n   * Creates a clone of `set`.\n   *\n   * @private\n   * @param {Object} set The set to clone.\n   * @param {Function} cloneFunc The function to clone values.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned set.\n   */\n  function cloneSet(set, isDeep, cloneFunc) {\n    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n    return arrayReduce(array, addSetEntry, new set.constructor);\n  }\n\n  /**\n   * Creates a clone of the `symbol` object.\n   *\n   * @private\n   * @param {Object} symbol The symbol object to clone.\n   * @returns {Object} Returns the cloned symbol object.\n   */\n  function cloneSymbol(symbol) {\n    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n  }\n\n  /**\n   * Creates a clone of `typedArray`.\n   *\n   * @private\n   * @param {Object} typedArray The typed array to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned typed array.\n   */\n  function cloneTypedArray(typedArray, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n  }\n\n  /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */\n  function copyArray(source, array) {\n    var index = -1,\n        length = source.length;\n\n    array || (array = Array(length));\n    while (++index < length) {\n      array[index] = source[index];\n    }\n    return array;\n  }\n\n  /**\n   * Copies properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy properties from.\n   * @param {Array} props The property identifiers to copy.\n   * @param {Object} [object={}] The object to copy properties to.\n   * @param {Function} [customizer] The function to customize copied values.\n   * @returns {Object} Returns `object`.\n   */\n  function copyObject(source, props, object, customizer) {\n    object || (object = {});\n\n    var index = -1,\n        length = props.length;\n\n    while (++index < length) {\n      var key = props[index];\n\n      var newValue = customizer\n        ? customizer(object[key], source[key], key, object, source)\n        : source[key];\n\n      assignValue(object, key, newValue);\n    }\n    return object;\n  }\n\n  /**\n   * Copies own symbol properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbols(source, object) {\n    return copyObject(source, getSymbols(source), object);\n  }\n\n  /**\n   * Creates a function like `_.assign`.\n   *\n   * @private\n   * @param {Function} assigner The function to assign values.\n   * @returns {Function} Returns the new assigner function.\n   */\n  function createAssigner(assigner) {\n    return rest(function(object, sources) {\n      var index = -1,\n          length = sources.length,\n          customizer = length > 1 ? sources[length - 1] : undefined,\n          guard = length > 2 ? sources[2] : undefined;\n\n      customizer = (assigner.length > 3 && typeof customizer == 'function')\n        ? (length--, customizer)\n        : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        customizer = length < 3 ? undefined : customizer;\n        length = 1;\n      }\n      object = Object(object);\n      while (++index < length) {\n        var source = sources[index];\n        if (source) {\n          assigner(object, source, index, customizer);\n        }\n      }\n      return object;\n    });\n  }\n\n  /**\n   * Creates a `baseEach` or `baseEachRight` function.\n   *\n   * @private\n   * @param {Function} eachFunc The function to iterate over a collection.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseEach(eachFunc, fromRight) {\n    return function(collection, iteratee) {\n      if (collection == null) {\n        return collection;\n      }\n      if (!isArrayLike(collection)) {\n        return eachFunc(collection, iteratee);\n      }\n      var length = collection.length,\n          index = fromRight ? length : -1,\n          iterable = Object(collection);\n\n      while ((fromRight ? index-- : ++index < length)) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break;\n        }\n      }\n      return collection;\n    };\n  }\n\n  /**\n   * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseFor(fromRight) {\n    return function(object, iteratee, keysFunc) {\n      var index = -1,\n          iterable = Object(object),\n          props = keysFunc(object),\n          length = props.length;\n\n      while (length--) {\n        var key = props[fromRight ? length : ++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break;\n        }\n      }\n      return object;\n    };\n  }\n\n  /**\n   * Creates a set of `values`.\n   *\n   * @private\n   * @param {Array} values The values to add to the set.\n   * @returns {Object} Returns the new set.\n   */\n  var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n    return new Set(values);\n  };\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for arrays with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Array} array The array to compare.\n   * @param {Array} other The other array to compare.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n   *  for more details.\n   * @param {Object} stack Tracks traversed `array` and `other` objects.\n   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n   */\n  function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n        arrLength = array.length,\n        othLength = other.length;\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n      return false;\n    }\n    // Assume cyclic values are equal.\n    var stacked = stack.get(array);\n    if (stacked) {\n      return stacked == other;\n    }\n    var index = -1,\n        result = true,\n        seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n    stack.set(array, other);\n\n    // Ignore non-index properties.\n    while (++index < arrLength) {\n      var arrValue = array[index],\n          othValue = other[index];\n\n      if (customizer) {\n        var compared = isPartial\n          ? customizer(othValue, arrValue, index, other, array, stack)\n          : customizer(arrValue, othValue, index, array, other, stack);\n      }\n      if (compared !== undefined) {\n        if (compared) {\n          continue;\n        }\n        result = false;\n        break;\n      }\n      // Recursively compare arrays (susceptible to call stack limits).\n      if (seen) {\n        if (!arraySome(other, function(othValue, othIndex) {\n              if (!seen.has(othIndex) &&\n                  (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n                return seen.add(othIndex);\n              }\n            })) {\n          result = false;\n          break;\n        }\n      } else if (!(\n            arrValue === othValue ||\n              equalFunc(arrValue, othValue, customizer, bitmask, stack)\n          )) {\n        result = false;\n        break;\n      }\n    }\n    stack['delete'](array);\n    return result;\n  }\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for comparing objects of\n   * the same `toStringTag`.\n   *\n   * **Note:** This function only supports comparing values with tags of\n   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {string} tag The `toStringTag` of the objects to compare.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n   *  for more details.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n    switch (tag) {\n      case dataViewTag:\n        if ((object.byteLength != other.byteLength) ||\n            (object.byteOffset != other.byteOffset)) {\n          return false;\n        }\n        object = object.buffer;\n        other = other.buffer;\n\n      case arrayBufferTag:\n        if ((object.byteLength != other.byteLength) ||\n            !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n          return false;\n        }\n        return true;\n\n      case boolTag:\n      case dateTag:\n        // Coerce dates and booleans to numbers, dates to milliseconds and\n        // booleans to `1` or `0` treating invalid dates coerced to `NaN` as\n        // not equal.\n        return +object == +other;\n\n      case errorTag:\n        return object.name == other.name && object.message == other.message;\n\n      case numberTag:\n        // Treat `NaN` vs. `NaN` as equal.\n        return (object != +object) ? other != +other : object == +other;\n\n      case regexpTag:\n      case stringTag:\n        // Coerce regexes to strings and treat strings, primitives and objects,\n        // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring\n        // for more details.\n        return object == (other + '');\n\n      case mapTag:\n        var convert = mapToArray;\n\n      case setTag:\n        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n        convert || (convert = setToArray);\n\n        if (object.size != other.size && !isPartial) {\n          return false;\n        }\n        // Assume cyclic values are equal.\n        var stacked = stack.get(object);\n        if (stacked) {\n          return stacked == other;\n        }\n        bitmask |= UNORDERED_COMPARE_FLAG;\n        stack.set(object, other);\n\n        // Recursively compare objects (susceptible to call stack limits).\n        return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n\n      case symbolTag:\n        if (symbolValueOf) {\n          return symbolValueOf.call(object) == symbolValueOf.call(other);\n        }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for objects with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n   *  for more details.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n    var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n        objProps = keys(object),\n        objLength = objProps.length,\n        othProps = keys(other),\n        othLength = othProps.length;\n\n    if (objLength != othLength && !isPartial) {\n      return false;\n    }\n    var index = objLength;\n    while (index--) {\n      var key = objProps[index];\n      if (!(isPartial ? key in other : baseHas(other, key))) {\n        return false;\n      }\n    }\n    // Assume cyclic values are equal.\n    var stacked = stack.get(object);\n    if (stacked) {\n      return stacked == other;\n    }\n    var result = true;\n    stack.set(object, other);\n\n    var skipCtor = isPartial;\n    while (++index < objLength) {\n      key = objProps[index];\n      var objValue = object[key],\n          othValue = other[key];\n\n      if (customizer) {\n        var compared = isPartial\n          ? customizer(othValue, objValue, key, other, object, stack)\n          : customizer(objValue, othValue, key, object, other, stack);\n      }\n      // Recursively compare objects (susceptible to call stack limits).\n      if (!(compared === undefined\n            ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n            : compared\n          )) {\n        result = false;\n        break;\n      }\n      skipCtor || (skipCtor = key == 'constructor');\n    }\n    if (result && !skipCtor) {\n      var objCtor = object.constructor,\n          othCtor = other.constructor;\n\n      // Non `Object` object instances with different constructors are not equal.\n      if (objCtor != othCtor &&\n          ('constructor' in object && 'constructor' in other) &&\n          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n            typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n        result = false;\n      }\n    }\n    stack['delete'](object);\n    return result;\n  }\n\n  /**\n   * Creates an array of own enumerable property names and symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols);\n  }\n\n  /**\n   * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n   * this function returns the custom method, otherwise it returns `baseIteratee`.\n   * If arguments are provided, the chosen function is invoked with them and\n   * its result is returned.\n   *\n   * @private\n   * @param {*} [value] The value to convert to an iteratee.\n   * @param {number} [arity] The arity of the created iteratee.\n   * @returns {Function} Returns the chosen function or its result.\n   */\n  function getIteratee() {\n    var result = lodash.iteratee || iteratee;\n    result = result === iteratee ? baseIteratee : result;\n    return arguments.length ? result(arguments[0], arguments[1]) : result;\n  }\n\n  /**\n   * Gets the \"length\" property value of `object`.\n   *\n   * **Note:** This function is used to avoid a\n   * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects\n   * Safari on at least iOS 8.1-8.3 ARM64.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {*} Returns the \"length\" value.\n   */\n  var getLength = baseProperty('length');\n\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return isKeyable(key)\n      ? data[typeof key == 'string' ? 'string' : 'hash']\n      : data.map;\n  }\n\n  /**\n   * Gets the property names, values, and compare flags of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the match data of `object`.\n   */\n  function getMatchData(object) {\n    var result = keys(object),\n        length = result.length;\n\n    while (length--) {\n      var key = result[length],\n          value = object[key];\n\n      result[length] = [key, value, isStrictComparable(value)];\n    }\n    return result;\n  }\n\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n  function getNative(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n  }\n\n  /**\n   * Gets the `[[Prototype]]` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {null|Object} Returns the `[[Prototype]]`.\n   */\n  function getPrototype(value) {\n    return nativeGetPrototype(Object(value));\n  }\n\n  /**\n   * Creates an array of the own enumerable symbol properties of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n  function getSymbols(object) {\n    // Coerce `object` to an object to avoid non-object errors in V8.\n    // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.\n    return getOwnPropertySymbols(Object(object));\n  }\n\n  // Fallback for IE < 11.\n  if (!getOwnPropertySymbols) {\n    getSymbols = stubArray;\n  }\n\n  /**\n   * Gets the `toStringTag` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function getTag(value) {\n    return objectToString.call(value);\n  }\n\n  // Fallback for data views, maps, sets, and weak maps in IE 11,\n  // for data views in Edge, and promises in Node.js.\n  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n      (Map && getTag(new Map) != mapTag) ||\n      (Promise && getTag(Promise.resolve()) != promiseTag) ||\n      (Set && getTag(new Set) != setTag) ||\n      (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n    getTag = function(value) {\n      var result = objectToString.call(value),\n          Ctor = result == objectTag ? value.constructor : undefined,\n          ctorString = Ctor ? toSource(Ctor) : undefined;\n\n      if (ctorString) {\n        switch (ctorString) {\n          case dataViewCtorString: return dataViewTag;\n          case mapCtorString: return mapTag;\n          case promiseCtorString: return promiseTag;\n          case setCtorString: return setTag;\n          case weakMapCtorString: return weakMapTag;\n        }\n      }\n      return result;\n    };\n  }\n\n  /**\n   * Checks if `path` exists on `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @param {Function} hasFunc The function to check properties.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   */\n  function hasPath(object, path, hasFunc) {\n    path = isKey(path, object) ? [path] : castPath(path);\n\n    var result,\n        index = -1,\n        length = path.length;\n\n    while (++index < length) {\n      var key = toKey(path[index]);\n      if (!(result = object != null && hasFunc(object, key))) {\n        break;\n      }\n      object = object[key];\n    }\n    if (result) {\n      return result;\n    }\n    var length = object ? object.length : 0;\n    return !!length && isLength(length) && isIndex(key, length) &&\n      (isArray(object) || isString(object) || isArguments(object));\n  }\n\n  /**\n   * Initializes an array clone.\n   *\n   * @private\n   * @param {Array} array The array to clone.\n   * @returns {Array} Returns the initialized clone.\n   */\n  function initCloneArray(array) {\n    var length = array.length,\n        result = array.constructor(length);\n\n    // Add properties assigned by `RegExp#exec`.\n    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n      result.index = array.index;\n      result.input = array.input;\n    }\n    return result;\n  }\n\n  /**\n   * Initializes an object clone.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneObject(object) {\n    return (typeof object.constructor == 'function' && !isPrototype(object))\n      ? baseCreate(getPrototype(object))\n      : {};\n  }\n\n  /**\n   * Initializes an object clone based on its `toStringTag`.\n   *\n   * **Note:** This function only supports cloning values with tags of\n   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @param {string} tag The `toStringTag` of the object to clone.\n   * @param {Function} cloneFunc The function to clone values.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneByTag(object, tag, cloneFunc, isDeep) {\n    var Ctor = object.constructor;\n    switch (tag) {\n      case arrayBufferTag:\n        return cloneArrayBuffer(object);\n\n      case boolTag:\n      case dateTag:\n        return new Ctor(+object);\n\n      case dataViewTag:\n        return cloneDataView(object, isDeep);\n\n      case float32Tag: case float64Tag:\n      case int8Tag: case int16Tag: case int32Tag:\n      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n        return cloneTypedArray(object, isDeep);\n\n      case mapTag:\n        return cloneMap(object, isDeep, cloneFunc);\n\n      case numberTag:\n      case stringTag:\n        return new Ctor(object);\n\n      case regexpTag:\n        return cloneRegExp(object);\n\n      case setTag:\n        return cloneSet(object, isDeep, cloneFunc);\n\n      case symbolTag:\n        return cloneSymbol(object);\n    }\n  }\n\n  /**\n   * Creates an array of index keys for `object` values of arrays,\n   * `arguments` objects, and strings, otherwise `null` is returned.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array|null} Returns index keys, else `null`.\n   */\n  function indexKeys(object) {\n    var length = object ? object.length : undefined;\n    if (isLength(length) &&\n        (isArray(object) || isString(object) || isArguments(object))) {\n      return baseTimes(length, String);\n    }\n    return null;\n  }\n\n  /**\n   * Checks if `value` is a flattenable `arguments` object or array.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n   */\n  function isFlattenable(value) {\n    return isArray(value) || isArguments(value);\n  }\n\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n  function isIndex(value, length) {\n    length = length == null ? MAX_SAFE_INTEGER : length;\n    return !!length &&\n      (typeof value == 'number' || reIsUint.test(value)) &&\n      (value > -1 && value % 1 == 0 && value < length);\n  }\n\n  /**\n   * Checks if the given arguments are from an iteratee call.\n   *\n   * @private\n   * @param {*} value The potential iteratee value argument.\n   * @param {*} index The potential iteratee index or key argument.\n   * @param {*} object The potential iteratee object argument.\n   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n   *  else `false`.\n   */\n  function isIterateeCall(value, index, object) {\n    if (!isObject(object)) {\n      return false;\n    }\n    var type = typeof index;\n    if (type == 'number'\n          ? (isArrayLike(object) && isIndex(index, object.length))\n          : (type == 'string' && index in object)\n        ) {\n      return eq(object[index], value);\n    }\n    return false;\n  }\n\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n  function isKey(value, object) {\n    if (isArray(value)) {\n      return false;\n    }\n    var type = typeof value;\n    if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n        value == null || isSymbol(value)) {\n      return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n      (object != null && value in Object(object));\n  }\n\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n  function isKeyable(value) {\n    var type = typeof value;\n    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n      ? (value !== '__proto__')\n      : (value === null);\n  }\n\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n  function isMasked(func) {\n    return !!maskSrcKey && (maskSrcKey in func);\n  }\n\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n    return value === proto;\n  }\n\n  /**\n   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` if suitable for strict\n   *  equality comparisons, else `false`.\n   */\n  function isStrictComparable(value) {\n    return value === value && !isObject(value);\n  }\n\n  /**\n   * A specialized version of `matchesProperty` for source values suitable\n   * for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function matchesStrictComparable(key, srcValue) {\n    return function(object) {\n      if (object == null) {\n        return false;\n      }\n      return object[key] === srcValue &&\n        (srcValue !== undefined || (key in Object(object)));\n    };\n  }\n\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n  var stringToPath = memoize(function(string) {\n    var result = [];\n    toString(string).replace(rePropName, function(match, number, quote, string) {\n      result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n    });\n    return result;\n  });\n\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value;\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n  }\n\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to process.\n   * @returns {string} Returns the source code.\n   */\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n      try {\n        return (func + '');\n      } catch (e) {}\n    }\n    return '';\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates an array of unique values, in order, from all given arrays using\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {...Array} [arrays] The arrays to inspect.\n   * @returns {Array} Returns the new array of combined values.\n   * @example\n   *\n   * _.union([2], [1, 2]);\n   * // => [2, 1]\n   */\n  var union = rest(function(arrays) {\n    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n  });\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Iterates over elements of `collection` and invokes `iteratee` for each element.\n   * The iteratee is invoked with three arguments: (value, index|key, collection).\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n   * property are iterated like arrays. To avoid this behavior use `_.forIn`\n   * or `_.forOwn` for object iteration.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @alias each\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   * @see _.forEachRight\n   * @example\n   *\n   * _([1, 2]).forEach(function(value) {\n   *   console.log(value);\n   * });\n   * // => Logs `1` then `2`.\n   *\n   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n   *   console.log(key);\n   * });\n   * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n   */\n  function forEach(collection, iteratee) {\n    var func = isArray(collection) ? arrayEach : baseEach;\n    return func(collection, getIteratee(iteratee, 3));\n  }\n\n  /**\n   * Checks if `value` is in `collection`. If `collection` is a string, it's\n   * checked for a substring of `value`, otherwise\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n   * is used for equality comparisons. If `fromIndex` is negative, it's used as\n   * the offset from the end of `collection`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object|string} collection The collection to search.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n   * @returns {boolean} Returns `true` if `value` is found, else `false`.\n   * @example\n   *\n   * _.includes([1, 2, 3], 1);\n   * // => true\n   *\n   * _.includes([1, 2, 3], 1, 2);\n   * // => false\n   *\n   * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n   * // => true\n   *\n   * _.includes('pebbles', 'eb');\n   * // => true\n   */\n  function includes(collection, value, fromIndex, guard) {\n    collection = isArrayLike(collection) ? collection : values(collection);\n    fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n    var length = collection.length;\n    if (fromIndex < 0) {\n      fromIndex = nativeMax(length + fromIndex, 0);\n    }\n    return isString(collection)\n      ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n      : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function() {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result);\n      return result;\n    };\n    memoized.cache = new (memoize.Cache || MapCache);\n    return memoized;\n  }\n\n  // Assign cache to `_.memoize`.\n  memoize.Cache = MapCache;\n\n  /**\n   * Creates a function that invokes `func` with the `this` binding of the\n   * created function and arguments from `start` and beyond provided as\n   * an array.\n   *\n   * **Note:** This method is based on the\n   * [rest parameter](https://mdn.io/rest_parameters).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Function\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @returns {Function} Returns the new function.\n   * @example\n   *\n   * var say = _.rest(function(what, names) {\n   *   return what + ' ' + _.initial(names).join(', ') +\n   *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n   * });\n   *\n   * say('hello', 'fred', 'barney', 'pebbles');\n   * // => 'hello fred, barney, & pebbles'\n   */\n  function rest(func, start) {\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);\n    return function() {\n      var args = arguments,\n          index = -1,\n          length = nativeMax(args.length - start, 0),\n          array = Array(length);\n\n      while (++index < length) {\n        array[index] = args[start + index];\n      }\n      switch (start) {\n        case 0: return func.call(this, array);\n        case 1: return func.call(this, args[0], array);\n        case 2: return func.call(this, args[0], args[1], array);\n      }\n      var otherArgs = Array(start + 1);\n      index = -1;\n      while (++index < start) {\n        otherArgs[index] = args[index];\n      }\n      otherArgs[start] = array;\n      return apply(func, this, otherArgs);\n    };\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'user': 'fred' };\n   * var other = { 'user': 'fred' };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n  function eq(value, other) {\n    return value === other || (value !== value && other !== other);\n  }\n\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n  function isArguments(value) {\n    // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.\n    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n      (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n  }\n\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @type {Function}\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n  var isArray = Array.isArray;\n\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n  function isArrayLike(value) {\n    return value != null && isLength(getLength(value)) && !isFunction(value);\n  }\n\n  /**\n   * This method is like `_.isArrayLike` except that it also checks if `value`\n   * is an object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array-like object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArrayLikeObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLikeObject(document.body.children);\n   * // => true\n   *\n   * _.isArrayLikeObject('abc');\n   * // => false\n   *\n   * _.isArrayLikeObject(_.noop);\n   * // => false\n   */\n  function isArrayLikeObject(value) {\n    return isObjectLike(value) && isArrayLike(value);\n  }\n\n  /**\n   * Checks if `value` is a buffer.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n   * @example\n   *\n   * _.isBuffer(new Buffer(2));\n   * // => true\n   *\n   * _.isBuffer(new Uint8Array(2));\n   * // => false\n   */\n  var isBuffer = !Buffer ? stubFalse : function(value) {\n    return value instanceof Buffer;\n  };\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n  function isFunction(value) {\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 8 which returns 'object' for typed array and weak map constructors,\n    // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n    var tag = isObject(value) ? objectToString.call(value) : '';\n    return tag == funcTag || tag == genTag;\n  }\n\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This function is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length,\n   *  else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n  function isLength(value) {\n    return typeof value == 'number' &&\n      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n  }\n\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n  function isObject(value) {\n    var type = typeof value;\n    return !!value && (type == 'object' || type == 'function');\n  }\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return !!value && typeof value == 'object';\n  }\n\n  /**\n   * Checks if `value` is a plain object, that is, an object created by the\n   * `Object` constructor or one with a `[[Prototype]]` of `null`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.8.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a plain object,\n   *  else `false`.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * _.isPlainObject(new Foo);\n   * // => false\n   *\n   * _.isPlainObject([1, 2, 3]);\n   * // => false\n   *\n   * _.isPlainObject({ 'x': 0, 'y': 0 });\n   * // => true\n   *\n   * _.isPlainObject(Object.create(null));\n   * // => true\n   */\n  function isPlainObject(value) {\n    if (!isObjectLike(value) ||\n        objectToString.call(value) != objectTag || isHostObject(value)) {\n      return false;\n    }\n    var proto = getPrototype(value);\n    if (proto === null) {\n      return true;\n    }\n    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n    return (typeof Ctor == 'function' &&\n      Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n  }\n\n  /**\n   * Checks if `value` is classified as a `String` primitive or object.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isString('abc');\n   * // => true\n   *\n   * _.isString(1);\n   * // => false\n   */\n  function isString(value) {\n    return typeof value == 'string' ||\n      (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n  }\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol(value) {\n    return typeof value == 'symbol' ||\n      (isObjectLike(value) && objectToString.call(value) == symbolTag);\n  }\n\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified,\n   *  else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n  function isTypedArray(value) {\n    return isObjectLike(value) &&\n      isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n  }\n\n  /**\n   * Checks if `value` is `undefined`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n   * @example\n   *\n   * _.isUndefined(void 0);\n   * // => true\n   *\n   * _.isUndefined(null);\n   * // => false\n   */\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  /**\n   * Converts `value` to an array.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {Array} Returns the converted array.\n   * @example\n   *\n   * _.toArray({ 'a': 1, 'b': 2 });\n   * // => [1, 2]\n   *\n   * _.toArray('abc');\n   * // => ['a', 'b', 'c']\n   *\n   * _.toArray(1);\n   * // => []\n   *\n   * _.toArray(null);\n   * // => []\n   */\n  function toArray(value) {\n    if (!value) {\n      return [];\n    }\n    if (isArrayLike(value)) {\n      return isString(value) ? stringToArray(value) : copyArray(value);\n    }\n    if (iteratorSymbol && value[iteratorSymbol]) {\n      return iteratorToArray(value[iteratorSymbol]());\n    }\n    var tag = getTag(value),\n        func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n    return func(value);\n  }\n\n  /**\n   * Converts `value` to a finite number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.12.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted number.\n   * @example\n   *\n   * _.toFinite(3.2);\n   * // => 3.2\n   *\n   * _.toFinite(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toFinite(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toFinite('3.2');\n   * // => 3.2\n   */\n  function toFinite(value) {\n    if (!value) {\n      return value === 0 ? value : 0;\n    }\n    value = toNumber(value);\n    if (value === INFINITY || value === -INFINITY) {\n      var sign = (value < 0 ? -1 : 1);\n      return sign * MAX_INTEGER;\n    }\n    return value === value ? value : 0;\n  }\n\n  /**\n   * Converts `value` to an integer.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted integer.\n   * @example\n   *\n   * _.toInteger(3.2);\n   * // => 3\n   *\n   * _.toInteger(Number.MIN_VALUE);\n   * // => 0\n   *\n   * _.toInteger(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toInteger('3.2');\n   * // => 3\n   */\n  function toInteger(value) {\n    var result = toFinite(value),\n        remainder = result % 1;\n\n    return result === result ? (remainder ? result - remainder : result) : 0;\n  }\n\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value;\n    }\n    if (isSymbol(value)) {\n      return NAN;\n    }\n    if (isObject(value)) {\n      var other = isFunction(value.valueOf) ? value.valueOf() : value;\n      value = isObject(other) ? (other + '') : other;\n    }\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value;\n    }\n    value = value.replace(reTrim, '');\n    var isBinary = reIsBinary.test(value);\n    return (isBinary || reIsOctal.test(value))\n      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n      : (reIsBadHex.test(value) ? NAN : +value);\n  }\n\n  /**\n   * Converts `value` to a plain object flattening inherited enumerable string\n   * keyed properties of `value` to own properties of the plain object.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {Object} Returns the converted plain object.\n   * @example\n   *\n   * function Foo() {\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.assign({ 'a': 1 }, new Foo);\n   * // => { 'a': 1, 'b': 2 }\n   *\n   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n   * // => { 'a': 1, 'b': 2, 'c': 3 }\n   */\n  function toPlainObject(value) {\n    return copyObject(value, keysIn(value));\n  }\n\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n  function toString(value) {\n    return value == null ? '' : baseToString(value);\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is used in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path);\n    return result === undefined ? defaultValue : result;\n  }\n\n  /**\n   * Checks if `path` is a direct or inherited property of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.hasIn(object, 'a');\n   * // => true\n   *\n   * _.hasIn(object, 'a.b');\n   * // => true\n   *\n   * _.hasIn(object, ['a', 'b']);\n   * // => true\n   *\n   * _.hasIn(object, 'b');\n   * // => false\n   */\n  function hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n  }\n\n  /**\n   * Creates an array of the own enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects. See the\n   * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n   * for more details.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keys(new Foo);\n   * // => ['a', 'b'] (iteration order is not guaranteed)\n   *\n   * _.keys('hi');\n   * // => ['0', '1']\n   */\n  function keys(object) {\n    var isProto = isPrototype(object);\n    if (!(isProto || isArrayLike(object))) {\n      return baseKeys(object);\n    }\n    var indexes = indexKeys(object),\n        skipIndexes = !!indexes,\n        result = indexes || [],\n        length = result.length;\n\n    for (var key in object) {\n      if (baseHas(object, key) &&\n          !(skipIndexes && (key == 'length' || isIndex(key, length))) &&\n          !(isProto && key == 'constructor')) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Creates an array of the own and inherited enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keysIn(new Foo);\n   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n   */\n  function keysIn(object) {\n    var index = -1,\n        isProto = isPrototype(object),\n        props = baseKeysIn(object),\n        propsLength = props.length,\n        indexes = indexKeys(object),\n        skipIndexes = !!indexes,\n        result = indexes || [],\n        length = result.length;\n\n    while (++index < propsLength) {\n      var key = props[index];\n      if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&\n          !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * This method is like `_.assign` except that it recursively merges own and\n   * inherited enumerable string keyed properties of source objects into the\n   * destination object. Source properties that resolve to `undefined` are\n   * skipped if a destination value exists. Array and plain object properties\n   * are merged recursively. Other objects and value types are overridden by\n   * assignment. Source objects are applied from left to right. Subsequent\n   * sources overwrite property assignments of previous sources.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.5.0\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * var users = {\n   *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n   * };\n   *\n   * var ages = {\n   *   'data': [{ 'age': 36 }, { 'age': 40 }]\n   * };\n   *\n   * _.merge(users, ages);\n   * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n   */\n  var merge = createAssigner(function(object, source, srcIndex) {\n    baseMerge(object, source, srcIndex);\n  });\n\n  /**\n   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n   * it's created. Arrays are created for missing index properties while objects\n   * are created for all other missing properties. Use `_.setWith` to customize\n   * `path` creation.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.set(object, 'a[0].b.c', 4);\n   * console.log(object.a[0].b.c);\n   * // => 4\n   *\n   * _.set(object, ['x', '0', 'y', 'z'], 5);\n   * console.log(object.x[0].y.z);\n   * // => 5\n   */\n  function set(object, path, value) {\n    return object == null ? object : baseSet(object, path, value);\n  }\n\n  /**\n   * Creates an array of the own enumerable string keyed property values of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property values.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.values(new Foo);\n   * // => [1, 2] (iteration order is not guaranteed)\n   *\n   * _.values('hi');\n   * // => ['h', 'i']\n   */\n  function values(object) {\n    return object ? baseValues(object, keys(object)) : [];\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * This method returns the first argument given to it.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'user': 'fred' };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n  function identity(value) {\n    return value;\n  }\n\n  /**\n   * Creates a function that invokes `func` with the arguments of the created\n   * function. If `func` is a property name, the created function returns the\n   * property value for a given element. If `func` is an array or object, the\n   * created function returns `true` for elements that contain the equivalent\n   * source properties, otherwise it returns `false`.\n   *\n   * @static\n   * @since 4.0.0\n   * @memberOf _\n   * @category Util\n   * @param {*} [func=_.identity] The value to convert to a callback.\n   * @returns {Function} Returns the callback.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': true },\n   *   { 'user': 'fred',   'age': 40, 'active': false }\n   * ];\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n   * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.filter(users, _.iteratee(['user', 'fred']));\n   * // => [{ 'user': 'fred', 'age': 40 }]\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.map(users, _.iteratee('user'));\n   * // => ['barney', 'fred']\n   *\n   * // Create custom iteratee shorthands.\n   * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n   *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n   *     return func.test(string);\n   *   };\n   * });\n   *\n   * _.filter(['abc', 'def'], /ef/);\n   * // => ['def']\n   */\n  function iteratee(func) {\n    return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));\n  }\n\n  /**\n   * A method that returns `undefined`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.3.0\n   * @category Util\n   * @example\n   *\n   * _.times(2, _.noop);\n   * // => [undefined, undefined]\n   */\n  function noop() {\n    // No operation performed.\n  }\n\n  /**\n   * Creates a function that returns the value at `path` of a given object.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   * @example\n   *\n   * var objects = [\n   *   { 'a': { 'b': 2 } },\n   *   { 'a': { 'b': 1 } }\n   * ];\n   *\n   * _.map(objects, _.property('a.b'));\n   * // => [2, 1]\n   *\n   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n   * // => [1, 2]\n   */\n  function property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n  }\n\n  /**\n   * A method that returns a new empty array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {Array} Returns the new empty array.\n   * @example\n   *\n   * var arrays = _.times(2, _.stubArray);\n   *\n   * console.log(arrays);\n   * // => [[], []]\n   *\n   * console.log(arrays[0] === arrays[1]);\n   * // => false\n   */\n  function stubArray() {\n    return [];\n  }\n\n  /**\n   * A method that returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n  function stubFalse() {\n    return false;\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  // Add methods that return wrapped values in chain sequences.\n  lodash.iteratee = iteratee;\n  lodash.keys = keys;\n  lodash.keysIn = keysIn;\n  lodash.memoize = memoize;\n  lodash.merge = merge;\n  lodash.property = property;\n  lodash.rest = rest;\n  lodash.set = set;\n  lodash.toArray = toArray;\n  lodash.toPlainObject = toPlainObject;\n  lodash.union = union;\n  lodash.values = values;\n\n  /*------------------------------------------------------------------------*/\n\n  // Add methods that return unwrapped values in chain sequences.\n  lodash.eq = eq;\n  lodash.forEach = forEach;\n  lodash.get = get;\n  lodash.hasIn = hasIn;\n  lodash.identity = identity;\n  lodash.includes = includes;\n  lodash.isArguments = isArguments;\n  lodash.isArray = isArray;\n  lodash.isArrayLike = isArrayLike;\n  lodash.isArrayLikeObject = isArrayLikeObject;\n  lodash.isBuffer = isBuffer;\n  lodash.isFunction = isFunction;\n  lodash.isLength = isLength;\n  lodash.isObject = isObject;\n  lodash.isObjectLike = isObjectLike;\n  lodash.isPlainObject = isPlainObject;\n  lodash.isString = isString;\n  lodash.isSymbol = isSymbol;\n  lodash.isTypedArray = isTypedArray;\n  lodash.isUndefined = isUndefined;\n  lodash.stubArray = stubArray;\n  lodash.stubFalse = stubFalse;\n  lodash.noop = noop;\n  lodash.toFinite = toFinite;\n  lodash.toInteger = toInteger;\n  lodash.toNumber = toNumber;\n  lodash.toString = toString;\n\n  // Add aliases.\n  lodash.each = forEach;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * The semantic version number.\n   *\n   * @static\n   * @memberOf _\n   * @type {string}\n   */\n  lodash.VERSION = VERSION;\n\n  /*--------------------------------------------------------------------------*/\n\n  if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = lodash)._ = lodash;\n    // Export for CommonJS support.\n    freeExports._ = lodash;\n  }\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/snippet.js":"\"use strict\";\n\nvar connectUtils = require(\"./connect-utils\");\nvar config       = require(\"./config\");\n\nvar lrSnippet    = require(\"resp-modifier\");\nvar path         = require(\"path\");\nvar _            = require(\"../lodash.custom\");\nvar utils        = require(\"./utils\");\nvar fs           = require(\"fs\");\n\n/**\n * Utils for snippet injection\n */\nvar snippetUtils = {\n    /**\n     * @param {String} url\n     * @param {Array} excludeList\n     * @returns {boolean}\n     */\n    isExcluded: function (url, excludeList) {\n\n        var extension = path.extname(url);\n\n        if (extension) {\n\n            if (~url.indexOf(\"?\")) {\n                return true;\n            }\n            extension = extension.slice(1);\n            return _.includes(excludeList, extension);\n        }\n        return false;\n    },\n    /**\n     * @param {String} snippet\n     * @param {Object} options\n     * @returns {{match: RegExp, fn: Function}}\n     */\n    getRegex: function (snippet, options) {\n\n        var fn = options.getIn([\"rule\", \"fn\"]);\n\n        return {\n            match: options.getIn([\"rule\", \"match\"]),\n            fn: function (req, res, match) {\n                return fn.apply(null, [snippet, match]);\n            },\n            once: true,\n            id: \"bs-snippet\"\n        };\n    },\n    getSnippetMiddleware: function (snippet, options, rewriteRules) {\n        return lrSnippet.create(snippetUtils.getRules(snippet, options, rewriteRules));\n    },\n    getRules: function (snippet, options, rewriteRules) {\n\n        var rules = [snippetUtils.getRegex(snippet, options)];\n\n        if (rewriteRules) {\n            rules = rules.concat(rewriteRules);\n        }\n\n        return {\n            rules: rules,\n            blacklist: utils.arrayify(options.get(\"blacklist\")),\n            whitelist: utils.arrayify(options.get(\"whitelist\"))\n        };\n    },\n    /**\n     * @param {Object} req\n     * @param {Array} [excludeList]\n     * @returns {Object}\n     */\n    isOldIe: function (excludeList) {\n        return function (req, res, next) {\n            var ua = req.headers[\"user-agent\"];\n            var match = /MSIE (\\d)\\.\\d/.exec(ua);\n            if (match) {\n                if (parseInt(match[1], 10) < 9) {\n                    if (!snippetUtils.isExcluded(req.url, excludeList)) {\n                        req.headers[\"accept\"] = \"text/html\";\n                    }\n                }\n            }\n            next();\n        }\n    },\n    /**\n     * @param {Number} port\n     * @param {BrowserSync.options} options\n     * @returns {String}\n     */\n    getClientJs: function (port, options) {\n        var socket = snippetUtils.getSocketScript();\n        var noConflictJs = \"window.___browserSync___oldSocketIo = window.io;\";\n        return noConflictJs + socket + \";\" + connectUtils.socketConnector(options);\n    },\n    /**\n     * @returns {String}\n     */\n    getSocketScript: function () {\n        return fs.readFileSync(path.join(__dirname, config.socketIoScript), \"utf-8\");\n    }\n};\nmodule.exports.utils = snippetUtils;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/connect-utils.js":"\"use strict\";\n\nvar _             = require(\"../lodash.custom\");\nvar fs            = require(\"fs\");\nvar config        = require(\"./config\");\n\nfunction getPath(options, relative, port) {\n    if (options.get(\"mode\") === \"snippet\") {\n        return options.get(\"scheme\") + \"://HOST:\" + port + relative;\n    } else {\n        return \"//HOST:\" + port + relative;\n    }\n}\n\nvar connectUtils = {\n    /**\n     * @param {Immutable.Map} options\n     * @returns {String}\n     */\n    scriptTags: function (options) {\n\n        var scriptPath     = this.clientScript(options);\n        var async          = options.getIn([\"snippetOptions\", \"async\"]);\n        var scriptDomain   = options.getIn([\"script\", \"domain\"]);\n\n        /**\n         * Generate the [src] attribute based on user options\n         */\n        var scriptSrc = (function () {\n\n            if (options.get(\"localOnly\")) {\n                return [\n                    options.get(\"scheme\"),\n                    \"://localhost:\",\n                    options.get(\"port\"),\n                    scriptPath\n                ].join(\"\");\n            }\n\n            /**\n             * First, was \"scriptPath\" set? if so the user wanted full control over the\n             * script tag output\n             *\n             */\n            if (_.isFunction(options.get(\"scriptPath\"))) {\n                return options.get(\"scriptPath\").apply(null, getScriptArgs(options, scriptPath));\n            }\n\n            /**\n             * Next, if \"script.domain\" was given, allow that + the path to the JS file\n             * eg:\n             *  script.domain=localhost:3000\n             * -> localhost:3000/browser-sync/browser-sync-client.js\n             */\n            if (scriptDomain) {\n                if (_.isFunction(scriptDomain)) {\n                    return scriptDomain.call(null, options) + scriptPath;\n                }\n                if (scriptDomain.match(/\\{port\\}/)) {\n                    return scriptDomain.replace(\"{port}\", options.get(\"port\")) + scriptPath;\n                }\n                return scriptDomain + scriptPath;\n            }\n\n            /**\n             * Now if server or proxy, use dynamic script\n             * eg:\n             *  browser-sync start --server\n             * ->\n             *  \"HOST:3000/browser-sync/browser-sync-client.js\".replace(\"HOST\", location.hostname)\n             */\n            if (options.get(\"server\") || options.get(\"proxy\")) {\n                return scriptPath;\n            }\n\n            /**\n             * Final use case is snippet mode\n             * -> \"http://HOST:3000/browser-sync/browser-sync-client.js\".replace(\"HOST\", location.hostname)\n             * -> \"//HOST:3000/browser-sync/browser-sync-client.js\".replace(\"HOST\", location.hostname)\"\n             */\n            return getPath(options, scriptPath, options.get(\"port\"));\n        })();\n\n        /**\n         * Decide which template shall be used to generate the script tags\n         */\n        var template = (function () {\n            if (scriptDomain || options.get(\"localOnly\")) {\n                return config.templates.scriptTagSimple;\n            }\n            return config.templates.scriptTag;\n        })();\n\n        /**\n         * Finally read the template file from disk and replace\n         * the dynamic values.\n         */\n        return fs.readFileSync(template, \"utf8\")\n            .replace(\"%script%\", scriptSrc)\n            .replace(\"%async%\", async ? \"async\" : \"\");\n    },\n    /**\n     * @param {Map} options\n     * @returns {String}\n     */\n    socketConnector: function (options) {\n\n        var socket        = options.get(\"socket\");\n        var template      = fs.readFileSync(config.templates.connector, \"utf-8\");\n        var url           = connectUtils.getConnectionUrl(options);\n\n        /**\n         * ***Backwards compatibility***. While `socket.path` is technically a\n         * socketIoClientConfig property, it's been documented previously\n         * as a top-level option, so must stay.\n         */\n        var clientConfig  = socket\n            .get(\"socketIoClientConfig\")\n            .merge({\n                path: socket.get(\"path\")\n            });\n\n        template = template\n            .replace(\"%config%\", JSON.stringify(clientConfig.toJS()))\n            .replace(\"%url%\",  url);\n\n        return template;\n    },\n    /**\n     * @param {Object} socketOpts\n     * @param {Map} options\n     * @returns {String|Function}\n     */\n    getNamespace: function (socketOpts, options) {\n\n        var namespace = socketOpts.namespace;\n\n        if (typeof namespace === \"function\") {\n            return namespace(options);\n        }\n\n        if (!namespace.match(/^\\//)) {\n            namespace = \"/\" + namespace;\n        }\n\n        return namespace;\n    },\n    /**\n     * @param {Map} options\n     * @returns {string}\n     */\n    getConnectionUrl: function (options) {\n\n        var socketOpts       = options.get(\"socket\").toJS();\n        var namespace        = connectUtils.getNamespace(socketOpts, options);\n\n        var protocol         = \"\";\n        var withHostnamePort = \"'{protocol}' + location.hostname + ':{port}{ns}'\";\n        var withHost         = \"'{protocol}' + location.host + '{ns}'\";\n        var withDomain       = \"'{domain}{ns}'\";\n        var port             = options.get(\"port\");\n\n        // default use-case is server/proxy\n        var string           = withHost;\n\n        if (options.get(\"mode\") !== \"server\") {\n            protocol = options.get(\"scheme\") + \"://\";\n            string   = withHostnamePort;\n        }\n\n        if (options.get(\"mode\") === \"proxy\" && options.getIn([\"proxy\", \"ws\"])) {\n            port = options.getIn([\"socket\", \"port\"]);\n        }\n\n        /**\n         * Ensure socket.domain is always a string (for noop replacements later)\n         */\n        socketOpts.domain = (function () {\n            if (options.get(\"localOnly\")) {\n                string = withDomain;\n                return [\n                    options.get(\"scheme\"),\n                    \"://localhost:\",\n                    options.get(\"port\")\n                ].join(\"\");\n            }\n            if (socketOpts.domain) {\n                string = withDomain;\n                /**\n                 * User provided a function\n                 */\n                if (_.isFunction(socketOpts.domain)) {\n                    return socketOpts.domain.call(null, options);\n                }\n                /**\n                 * User provided a string\n                 */\n                if (_.isString(socketOpts.domain)) {\n                    return socketOpts.domain;\n                }\n            }\n            return \"\";\n        })();\n\n        return string\n            .replace(\"{protocol}\", protocol)\n            .replace(\"{port}\",     port)\n            .replace(\"{domain}\",   socketOpts.domain.replace(\"{port}\", port))\n            .replace(\"{ns}\",       namespace);\n    },\n    /**\n     * @param {Object} [options]\n     * @param {Boolean} [both]\n     */\n    clientScript: function (options, both) {\n\n        var prefix    = options.getIn([\"socket\", \"clientPath\"]);\n        var script    = prefix + \"/browser-sync-client.js\";\n        var versioned = prefix + \"/browser-sync-client.js?v=\" + options.get(\"version\");\n\n        if (both) {\n            return {\n                path: script,\n                versioned: versioned\n            };\n        }\n\n        return versioned;\n    }\n};\n\n/**\n * @param options\n * @returns {*[]}\n */\nfunction getScriptArgs (options, scriptPath) {\n    var abspath = options.get(\"scheme\") + \"://HOST:\" + options.get(\"port\") + scriptPath;\n    return [\n        scriptPath,\n        options.get(\"port\"),\n        options.set(\"absolute\", abspath)\n    ];\n}\n\nmodule.exports = connectUtils;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/config.js":"\"use strict\";\n\nvar path = require(\"path\");\n/**\n * @type {{controlPanel: {jsFile: string, baseDir: *}, socketIoScript: string, configFile: string, client: {shims: string}}}\n */\nmodule.exports = {\n    controlPanel: {\n        jsFile: \"/js/app.js\",\n        baseDir: path.join(__dirname, \"control-panel\")\n    },\n    templates: {\n        scriptTag: path.join(__dirname, \"templates/script-tags.tmpl\"),\n        scriptTagSimple: path.join(__dirname, \"templates/script-tags-simple.tmpl\"),\n        connector: path.join(__dirname, \"templates/connector.tmpl\")\n    },\n    socketIoScript: \"/public/socket.io.min.1.6.0.js\",\n    configFile: \"default-config.js\",\n    userFile: \"bs-config.js\",\n    template: \"cli-template.js\",\n    httpProtocol: {\n        path: \"/__browser_sync__\"\n    },\n    client: {\n        shims: \"/client/client-shims.js\"\n    },\n    errors: {\n        \"server+proxy\": \"Invalid config. You cannot specify both server & proxy options.\",\n        \"proxy+https\":  \"Invalid config. You set https: true, but your proxy target doesn't reflect this.\"\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/utils.js":"\"use strict\";\n\nvar _             = require(\"../lodash.custom\");\nvar devIp         = require(\"dev-ip\")();\nvar Immutable     = require(\"immutable\");\nvar portScanner   = require(\"portscanner\");\nvar path          = require(\"path\");\nvar List          = require(\"immutable\").List;\nvar UAParser      = require(\"ua-parser-js\");\nvar parser        = new UAParser();\n\nvar utils = {\n    /**\n     * @param {Object} options\n     * @returns {String|boolean} - the IP address\n     * @param devIp\n     */\n    getHostIp: function (options, devIp) {\n\n        if (options) {\n            var host = options.get(\"host\");\n            if (host && host !== \"localhost\") {\n                return host;\n            }\n            if (options.get(\"detect\") === false || !devIp.length) {\n                return false;\n            }\n        }\n\n        return devIp.length ? devIp[0] : false;\n    },\n    /**\n     * Set URL Options\n     */\n    getUrlOptions: function (options) {\n\n        var scheme = options.get(\"scheme\");\n\n        var port   = options.get(\"port\");\n        var urls   = {};\n\n        if (options.get(\"online\") === false) {\n            urls.local = utils.getUrl(scheme + \"://localhost:\" + port, options);\n            return Immutable.fromJS(urls);\n        }\n\n        var external  = utils.xip(utils.getHostIp(options, devIp), options);\n        var localhost = \"localhost\";\n\n        if (options.get(\"xip\")) {\n            localhost = \"127.0.0.1\";\n        }\n\n        localhost = utils.xip(localhost, options);\n\n        return Immutable.fromJS(utils.getUrls(external, localhost, scheme, options));\n    },\n    /**\n     * Append a start path if given in options\n     * @param {String} url\n     * @param {Object} options\n     * @returns {String}\n     */\n    getUrl: function (url, options) {\n\n        var prefix = \"/\";\n        var startPath = options.get(\"startPath\");\n\n        if (startPath) {\n            if (startPath.charAt(0) === \"/\") {\n                prefix = \"\";\n            }\n            url = url + prefix + startPath;\n        }\n\n        return url;\n    },\n    /**\n     * @param {String} external\n     * @param {String} local\n     * @param {String} scheme\n     * @param {Object} options\n     * @returns {{local: string, external: string}}\n     */\n    getUrls: function (external, local, scheme, options) {\n\n        var urls = {\n            local: utils.getUrl(utils._makeUrl(scheme, local, options.get(\"port\")), options)\n        };\n\n        if (external !== local) {\n            urls.external = utils.getUrl(utils._makeUrl(scheme, external, options.get(\"port\")), options);\n        }\n\n        return urls;\n    },\n    /**\n     * @param {String} scheme\n     * @param {String} host\n     * @param {Number} port\n     * @returns {String}\n     * @private\n     */\n    _makeUrl: function (scheme, host, port) {\n        return scheme + \"://\" + host + \":\" + port;\n    },\n    /**\n     * Get ports\n     * @param {Object} options\n     * @param {Function} cb\n     */\n    getPorts: function (options, cb) {\n\n        var port  = options.get(\"port\");\n        var ports = options.get(\"ports\"); // backwards compatibility\n        var max;\n\n        if (ports) {\n            port = ports.get(\"min\");\n            max  = ports.get(\"max\") || null;\n        }\n\n        utils.getPort(port, max, cb);\n    },\n    getPort: function (port, max, cb) {\n        portScanner.findAPortNotInUse(port, max, {\n            host: \"localhost\",\n            timeout: 1000\n        }, cb);\n    },\n    /**\n     * @param {String} ua\n     * @returns {Object}\n     */\n    getUaString: function (ua) {\n        return parser.setUA(ua).getBrowser();\n    },\n    /**\n     * Open the page in browser\n     * @param {String} url\n     * @param {Object} options\n     * @param {BrowserSync} bs\n     */\n    openBrowser: function (url, options, bs) {\n\n        var open    = options.get(\"open\");\n        var browser = options.get(\"browser\");\n\n        if (_.isString(open)) {\n            if (options.getIn([\"urls\", open])) {\n                url = options.getIn([\"urls\", open]);\n            }\n        }\n\n        if (open) {\n            if (browser !== \"default\") {\n                if (utils.isList(browser)) {\n                    browser.forEach(function (browser) {\n                        utils.open(url, browser, bs);\n                    });\n                } else {\n                    utils.open(url, browser, bs); // single\n                }\n            } else {\n                utils.open(url, null, bs);\n            }\n        }\n    },\n    /**\n     * Wrapper for opn module\n     * @param url\n     * @param name\n     * @param bs\n     */\n    open: function (url, name, bs) {\n        var options = (function () {\n            if (_.isString(name)) {\n                return {app: name};\n            }\n            if (Immutable.Map.isMap(name)) {\n                return name.toJS();\n            }\n            return {};\n        })();\n        var opn = require(\"opn\");\n        opn(url, options).catch(function() {\n            bs.events.emit(\"browser:error\");\n        });\n    },\n    /**\n     * @param {Boolean} kill\n     * @param {String|Error} [errMessage]\n     * @param {Function} [cb]\n     */\n    fail: function (kill, errMessage, cb) {\n        if (kill) {\n            if (_.isFunction(cb)) {\n                if (errMessage.message) { // Is this an error object?\n                    cb(errMessage);\n                } else {\n                    cb(new Error(errMessage));\n                }\n            }\n            process.exit(1);\n        }\n    },\n    /**\n     * Add support for xip.io urls\n     * @param {String} host\n     * @param {Object} options\n     * @returns {String}\n     */\n    xip: function (host, options) {\n        var suffix = options.get(\"hostnameSuffix\");\n        if (options.get(\"xip\")) {\n            return host + \".xip.io\";\n        }\n        if (suffix) {\n            return host + suffix;\n        }\n        return host;\n    },\n    /**\n     * Determine if an array of file paths will cause a full page reload.\n     * @param {Array} needles - filepath such as [\"core.css\", \"index.html\"]\n     * @param {Array} haystack\n     * @returns {Boolean}\n     */\n    willCauseReload: function (needles, haystack) {\n        return needles.some(function (needle) {\n            return !_.includes(haystack, path.extname(needle).replace(\".\", \"\"));\n        });\n    },\n    isList: Immutable.List.isList,\n    isMap: Immutable.List.isMap,\n    /**\n     * @param {Map} options\n     * @returns {Array}\n     */\n    getConfigErrors: function (options) {\n\n        var messages = require(\"./config\").errors;\n\n        var errors = [];\n\n        if (options.get(\"server\") && options.get(\"proxy\")) {\n            errors.push(messages[\"server+proxy\"]);\n        }\n\n        return errors;\n    },\n    /**\n     * @param {Map} options\n     * @param {Function} [cb]\n     */\n    verifyConfig: function (options, cb) {\n        var errors = utils.getConfigErrors(options);\n        if (errors.length) {\n            utils.fail(true, errors.join(\"\\n\"), cb);\n            return false;\n        }\n        return true;\n    },\n    /**\n     * @param err\n     */\n    defaultCallback: function (err) {\n        if (err && err.message) {\n            console.error(err.message);\n        }\n    },\n    eachSeries: function (arr, iterator, callback) {\n        callback = callback || function () {};\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                } else {\n                    ++completed;\n                    if (completed >= arr.length) {\n                        callback();\n                    } else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    },\n    /**\n     * @param {Immutable.List|Array|String} incoming\n     * @returns {Array}\n     */\n    arrayify: function (incoming) {\n        if (List.isList(incoming)) {\n            return incoming.toArray();\n        }\n        return [].concat(incoming).filter(Boolean);\n    }\n};\n\nmodule.exports              = utils;\nmodule.exports.portscanner  = portScanner;\nmodule.exports.UAParser     = UAParser;\nmodule.exports.connect      = require(\"connect\");\nmodule.exports.devIp        = devIp;\nmodule.exports.serveStatic  = require(\"serve-static\");\nmodule.exports.easyExtender = require(\"easy-extender\");\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/async-tasks.js":"var async           = require(\"./async\");\n\nmodule.exports = [\n    {\n        step: \"Finding an empty port\",\n        fn: async.getEmptyPort\n    },\n    {\n        step: \"Getting an extra port for Proxy\",\n        fn: async.getExtraPortForProxy\n    },\n    {\n        step: \"Checking online status\",\n        fn: async.getOnlineStatus\n    },\n    {\n        step: \"Resolve user plugins from options\",\n        fn: async.resolveInlineUserPlugins\n    },\n    {\n        step: \"Set Urls and other options that rely on port/online status\",\n        fn: async.setOptions\n    },\n    {\n        step: \"Setting Internal Events\",\n        fn: async.setInternalEvents\n    },\n    {\n        step: \"Setting file watchers\",\n        fn: async.setFileWatchers\n    },\n    {\n        step: \"Merging middlewares from core + plugins\",\n        fn: async.mergeMiddlewares\n    },\n    {\n        step: \"Starting the Server\",\n        fn: async.startServer\n    },\n    {\n        step: \"Starting the HTTPS Tunnel\",\n        fn: async.startTunnel\n    },\n    {\n        step: \"Starting the web-socket server\",\n        fn: async.startSockets\n    },\n    {\n        step: \"Starting the UI\",\n        fn: async.startUi\n    },\n    {\n        step: \"Merge UI settings\",\n        fn: async.mergeUiSettings\n    },\n    {\n        step: \"Init user plugins\",\n        fn: async.initUserPlugins\n    }\n];\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/async.js":"\"use strict\";\n\nvar _            = require(\"../lodash.custom\");\nvar Immutable    = require(\"immutable\");\n\nvar utils        = require(\"./utils\");\nvar pluginUtils  = require(\"./plugins\");\nvar connectUtils = require(\"./connect-utils\");\n\nmodule.exports = {\n    /**\n     * BrowserSync needs at least 1 free port.\n     * It will check the one provided in config\n     * and keep incrementing until an available one is found.\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    getEmptyPort: function (bs, done) {\n        utils.getPorts(bs.options, function (err, port) {\n            if (err) {\n                return utils.fail(true, err, bs.cb);\n            }\n            bs.debug(\"Found a free port: {magenta:%s\", port);\n            done(null, {\n                options: {\n                    port: port\n                }\n            });\n        });\n    },\n    /**\n     * If the running mode is proxy, we'll use a separate port\n     * for the Browsersync web-socket server. This is to eliminate any issues\n     * with trying to proxy web sockets through to the users server.\n     * @param bs\n     * @param done\n     */\n    getExtraPortForProxy: function (bs, done) {\n        /**\n         * An extra port is not needed in snippet/server mode\n         */\n        if (bs.options.get(\"mode\") !== \"proxy\") {\n            return done();\n        }\n\n        /**\n         * Web socket support is disabled by default\n         */\n        if (!bs.options.getIn([\"proxy\", \"ws\"])) {\n            return done();\n        }\n\n        /**\n         * Use 1 higher than server port by default...\n         */\n        var socketPort = bs.options.get(\"port\") + 1;\n\n        /**\n         * Or use the user-defined socket.port option instead\n         */\n        if (bs.options.hasIn([\"socket\", \"port\"])) {\n            socketPort = bs.options.getIn([\"socket\", \"port\"]);\n        }\n\n        utils.getPort(socketPort, null, function (err, port) {\n            if (err) {\n                return utils.fail(true, err, bs.cb);\n            }\n            done(null, {\n                optionsIn: [\n                    {\n                        path: [\"socket\", \"port\"],\n                        value: port\n                    }\n                ]\n            });\n        });\n    },\n    /**\n     * Some features require an internet connection.\n     * If the user did not provide either `true` or `false`\n     * for the online option, we will attempt to resolve www.google.com\n     * as a way of determining network connectivity\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    getOnlineStatus: function (bs, done) {\n        if (_.isUndefined(bs.options.get(\"online\")) && _.isUndefined(process.env.TESTING)) {\n            require(\"dns\").resolve(\"www.google.com\", function (err) {\n                var online = false;\n                if (err) {\n                    bs.debug(\"Could not resolve www.google.com, setting {magenta:online: false}\");\n                } else {\n                    bs.debug(\"Resolved www.google.com, setting {magenta:online: true}\");\n                    online = true;\n                }\n                done(null, {\n                    options: {\n                        online: online\n                    }\n                });\n            });\n        } else {\n            done();\n        }\n    },\n    /**\n     * Try to load plugins that were given in options\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    resolveInlineUserPlugins: function (bs, done) {\n\n        var plugins = bs.options\n            .get(\"plugins\")\n            .map(pluginUtils.resolvePlugin)\n            .map(pluginUtils.requirePlugin);\n\n        plugins\n            .forEach(function (plugin) {\n                if (plugin.get(\"errors\").size) {\n                    return logPluginError(plugin);\n                }\n                var jsPlugin = plugin.toJS();\n                jsPlugin.options = jsPlugin.options || {};\n                jsPlugin.options.moduleName = jsPlugin.moduleName;\n                bs.registerPlugin(jsPlugin.module, jsPlugin.options);\n            });\n\n        function logPluginError (plugin) {\n            utils.fail(true, plugin.getIn([\"errors\", 0]), bs.cb);\n        }\n\n        done();\n    },\n    /**\n     *\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    setOptions: function (bs, done) {\n        done(null, {\n            options: {\n                urls:        utils.getUrlOptions(bs.options),\n                snippet:     connectUtils.scriptTags(bs.options),\n                scriptPaths: Immutable.fromJS(connectUtils.clientScript(bs.options, true)),\n                files:       bs.pluginManager.hook(\n                    \"files:watch\",\n                    bs.options.get(\"files\"),\n                    bs.pluginManager.pluginOptions\n                )\n            }\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    setInternalEvents: function (bs, done) {\n        require(\"./internal-events\")(bs);\n        done();\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    setFileWatchers: function (bs, done) {\n        done(null, {\n            instance: {\n                watchers: bs.pluginManager.get(\"file:watcher\")(bs)\n            }\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    mergeMiddlewares: function (bs, done) {\n\n        done(null, {\n            options: {\n                middleware: bs.pluginManager.hook(\n                    \"server:middleware\",\n                    bs.options.get(\"middleware\")\n                )\n            }\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    startServer: function (bs, done) {\n\n        var server = bs.pluginManager.get(\"server\")(bs);\n\n        done(null, {\n            instance: {\n                server: server.server,\n                app: server.app\n            }\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    startTunnel: function (bs, done) {\n        if (bs.options.get(\"tunnel\") && bs.options.get(\"online\")) {\n            var localTunnel = require(\"./tunnel\");\n            localTunnel(bs, function (err, tunnel) {\n                if (err) {\n                    return done(err);\n                } else {\n                    return done(null, {\n                        optionsIn: [\n                            {\n                                path:  [\"urls\", \"tunnel\"],\n                                value: tunnel.url\n                            }\n                        ],\n                        instance: {\n                            tunnel: tunnel\n                        }\n                    });\n                }\n            });\n        } else {\n            done();\n        }\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    startSockets: function (bs, done) {\n\n        var clientEvents = bs.pluginManager.hook(\n            \"client:events\",\n            bs.options.get(\"clientEvents\").toJS()\n        );\n\n        // Start the socket, needs an existing server.\n        var io = bs.pluginManager.get(\"socket\")(\n            bs.server,\n            clientEvents,\n            bs\n        );\n\n        done(null, {\n            instance: {\n                io: io\n            },\n            options: {\n                clientEvents: Immutable.fromJS(clientEvents)\n            }\n        });\n    },\n    /**\n     *\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    startUi: function (bs, done) {\n\n        var PLUGIN_NAME = \"UI\";\n        var userPlugins   = bs.getUserPlugins();\n        var ui            = bs.pluginManager.get(PLUGIN_NAME);\n        var uiOpts        = bs.options.get(\"ui\");\n\n        if (!uiOpts || uiOpts.get(\"enabled\") === false) {\n            return done();\n        }\n\n        // if user provided a UI, use it instead\n        if (userPlugins.some(function (item) {\n            return item.name === PLUGIN_NAME;\n        })) {\n            uiOpts = bs.options.get(\"ui\").mergeDeep(Immutable.fromJS(bs.pluginManager.pluginOptions[PLUGIN_NAME]));\n        }\n\n        return ui(uiOpts.toJS(), bs, function (err, ui) {\n            if (err) {\n                return done(err);\n            }\n            done(null, {\n                instance: {\n                    ui: ui\n                }\n            });\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    mergeUiSettings: function (bs, done) {\n\n        if (!bs.ui) {\n            return done();\n        }\n\n        done(null, {\n            options: {\n                urls: bs.options.get(\"urls\").merge(bs.ui.options.get(\"urls\"))\n            }\n        });\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param {Function} done\n     */\n    initUserPlugins: function (bs, done) {\n\n        bs.pluginManager.initUserPlugins(bs);\n\n        done(null, {\n            options: {\n                userPlugins: bs.getUserPlugins()\n            }\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/plugins.js":"var Immutable  = require(\"immutable\");\nvar Map        = Immutable.Map;\nvar isMap      = Immutable.Map.isMap;\nvar List       = Immutable.List;\nvar qs         = require(\"qs\");\nvar path       = require(\"path\");\nvar fs         = require(\"fs\");\n\nvar Plugin = Immutable.Record({\n    moduleName: \"\",\n    name:       \"\",\n    active:     true,\n    module:     undefined,\n    options:    Map({}),\n    via:        \"inline\",\n    dir:        process.cwd(),\n    init:       undefined,\n    errors:     List([])\n});\n\n/**\n * Accept a string/object\n * and resolve it into the plugin format above\n * @param item\n * @returns {*}\n */\nfunction resolvePlugin(item) {\n\n    /**\n     * Handle when string was given, such as plugins: ['bs-html-injector']\n     */\n    if (typeof item === \"string\") {\n        return getFromString(item);\n    }\n\n    if (!isMap(item)) {\n        return new Plugin().mergeDeep({errors: [new Error(\"Plugin not supported in this format\")]});\n    }\n\n    if (item.has(\"module\")) {\n\n        var nameOrObj = item.get(\"module\");\n        var options = item.get(\"options\");\n\n        /**\n         * The 'module' key can be a string, this allows\n         * inline plugin references, but with options\n         * eg:\n         *\n         * bs.init({\n         *     plugins: [\n         *         {\n         *             module: './myjs-file.js'\n         *             options: {\n         *                 files: \"*.html\"\n         *             }\n         *         }\n         *     ]\n         * });\n         */\n        if (typeof nameOrObj === \"string\") {\n            return getFromString(nameOrObj)\n                .mergeDeep({\n                    options: options\n                });\n        }\n\n        /**\n         * If the plugin was given completely inline (because it needs options)\n         * eg:\n         *\n         * bs.init({\n         *     plugins: [\n         *         {\n         *             module: {\n         *                 plugin: function() {\n         *                     console.log('My plugin code')\n         *                 }\n         *             },\n         *             options: {\n         *                 files: \"*.html\"\n         *             }\n         *         }\n         *     ]\n         * })\n         */\n        if (Immutable.Map.isMap(nameOrObj)) {\n            return new Plugin({\n                module: nameOrObj,\n                options: options\n            });\n        }\n    }\n\n    /**\n     * If a module was given directly. For example, ater calling require.\n     *\n     * eg:\n     *    var myplugin = require('./some-js');\n     *    bs.init({plugins: [myplugin]});\n     */\n    if (item.has(\"plugin\")) {\n        return new Plugin({\n            module: item\n        })\n    }\n\n    /**\n     * If we reach here, the plugin option was used incorrectly\n     */\n    return new Plugin().mergeDeep({errors: [new Error(\"Plugin was not configured correctly\")]})\n}\n\nmodule.exports.resolvePlugin = resolvePlugin;\n\n/**\n * Load a plugin from disk\n * @param item\n * @returns {*}\n */\nfunction requirePlugin (item) {\n\n    /**\n     * if the \"module\" property already exists and\n     * is not a string, then we bail and don't bother looking\n     * for the file\n     */\n    if (item.get(\"module\") && typeof item.get(\"module\") !== \"string\") {\n        return item;\n    }\n\n    try {\n        /**\n         * Try a raw node require() call - this will be how\n         * regular \"npm installed\" plugins wil work\n         */\n        var maybe = path.resolve(process.cwd(), \"node_modules\", item.get(\"name\"));\n        return item.set(\"module\", require(maybe));\n    } catch (e) {\n        /**\n         * If require threw an MODULE_NOT_FOUND error, try again\n         * by resolving from cwd. This is needed since cli\n         * users will not add ./ to the front of a path (which\n         * node requires to resolve from cwd)\n         */\n        if (e.code === \"MODULE_NOT_FOUND\") {\n            var maybe = path.resolve(process.cwd(), item.get(\"name\"));\n            if (fs.existsSync(maybe)) {\n                return item.set(\"module\", require(maybe));\n            } else {\n                /**\n                 * Finally return a plugin that contains the error\n                 * this will be picked up later and discarded\n                 */\n                return item.update(\"errors\", function (errors) {\n                    return errors.concat(e);\n                });\n            }\n        }\n        throw e;\n    }\n}\nmodule.exports.requirePlugin = requirePlugin;\n\nfunction getFromString(string) {\n\n    /**\n     * We allow query strings for plugins, so always split on ?\n     */\n    var split = string.split(\"?\");\n\n    var outGoing = new Plugin({\n        moduleName: split[0],\n        name: split[0]\n    });\n\n    if (split.length > 1) {\n        return outGoing.update(\"options\", function (opts) {\n            return opts.mergeDeep(qs.parse(split[1]));\n        });\n    }\n\n    return outGoing;\n}\n\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/logger.js":"\"use strict\";\n\nvar messages = require(\"./connect-utils\");\nvar utils    = require(\"./utils\");\nvar _        = require(\"../lodash.custom\");\n\nvar template = \"[{blue:%s}] \";\n\nvar logger   = require(\"eazy-logger\").Logger({\n    prefix: template.replace(\"%s\", \"BS\"),\n    useLevelPrefixes: false\n});\n\nmodule.exports.logger = logger;\n\n/**\n * @param name\n * @returns {*}\n */\nmodule.exports.getLogger = function (name) {\n    return logger.clone(function (config) {\n        config.prefix = config.prefix + template.replace(\"%s\", name);\n        return config;\n    });\n};\n\n/**\n * Logging Callbacks\n */\nmodule.exports.callbacks = {\n    /**\n     * Log when file-watching has started\n     * @param {BrowserSync} bs\n     * @param data\n     */\n    \"file:watching\": function (bs, data) {\n        if (Object.keys(data).length) {\n            logger.info(\"Watching files...\");\n        }\n    },\n    /**\n     * Log when a file changes\n     * @param {BrowserSync} bs\n     * @param data\n     */\n    \"file:reload\": function (bs, data) {\n        if (canLogFileChange(bs, data)) {\n\n            if (data.path[0] === \"*\") {\n                return logger.info(\"{cyan:Reloading files that match: {magenta:%s\", data.path);\n            }\n\n            logger.info(\"{cyan:File event [\" + data.event + \"] : {magenta:%s\", data.path);\n        }\n    },\n    /**\n     *\n     */\n    \"service:exit\": function () {\n        logger.debug(\"Exiting...\");\n    },\n    /**\n     *\n     */\n    \"browser:reload\": function (bs) {\n        if (canLogFileChange(bs)) {\n            logger.info(\"{cyan:Reloading Browsers...\");\n        }\n    },\n    /**\n     *\n     */\n    \"browser:error\": function () {\n        logger.error(\"Couldn't open browser (if you are using BrowserSync in a headless environment, you might want to set the {cyan:open} option to {cyan:false})\");\n    },\n    /**\n     * @param {BrowserSync} bs\n     * @param data\n     */\n    \"stream:changed\": function (bs, data) {\n        if (canLogFileChange(bs)) {\n            var changed = data.changed;\n\n            logger.info(\"{cyan:%s %s changed} ({magenta:%s})\",\n                changed.length,\n                changed.length > 1 ? \"files\" : \"file\",\n                changed.join(\", \")\n            );\n        }\n    },\n    /**\n     * Client connected logging\n     * @param {BrowserSync} bs\n     * @param data\n     */\n    \"client:connected\": function (bs, data) {\n\n        var uaString = utils.getUaString(data.ua);\n        var msg = \"{cyan:Browser Connected: {magenta:%s, version: %s}\";\n        var method = \"info\";\n\n        if (!bs.options.get(\"logConnections\")) {\n            method = \"debug\";\n        }\n\n        logger.log(method, msg,\n            uaString.name,\n            uaString.version\n        );\n    },\n    /**\n     * Main logging when the service is running\n     * @param {BrowserSync} bs\n     * @param data\n     */\n    \"service:running\": function (bs, data) {\n\n        var type    = data.type;\n\n        if (type === \"server\") {\n\n            var baseDir = bs.options.getIn([\"server\", \"baseDir\"]);\n\n            logUrls(bs.options.get(\"urls\").toJS());\n\n            if (baseDir) {\n                if (utils.isList(baseDir)) {\n                    baseDir.forEach(serveFiles);\n                } else {\n                    serveFiles(baseDir);\n                }\n            }\n        }\n\n        if (type === \"proxy\") {\n\n            logger.info(\"Proxying: {cyan:%s}\", bs.options.getIn([\"proxy\", \"target\"]));\n            logUrls(bs.options.get(\"urls\").toJS());\n        }\n\n        if (type === \"snippet\") {\n\n            if (bs.options.get(\"logSnippet\")) {\n\n                logger.info(\n                    \"{bold:Copy the following snippet into your website, \" +\n                    \"just before the closing {cyan:</body>} tag\"\n                );\n\n                logger.unprefixed(\"info\",\n                    messages.scriptTags(bs.options)\n                );\n            }\n\n            logUrls(bs.options.get(\"urls\").filter(function (value, key) {\n                return key.slice(0, 2) === \"ui\";\n            }).toJS());\n        }\n\n        function serveFiles (base) {\n            logger.info(\"Serving files from: {magenta:%s}\", base);\n        }\n    }\n};\n\n/**\n * Plugin interface for BrowserSync\n * @param {EventEmitter} emitter\n * @param {BrowserSync} bs\n * @returns {Object}\n */\nmodule.exports.plugin = function (emitter, bs) {\n\n    var logPrefix = bs.options.get(\"logPrefix\");\n    var logLevel  = bs.options.get(\"logLevel\");\n\n    // Should set logger level here!\n    logger.setLevel(logLevel);\n\n    if (logPrefix) {\n        if (_.isFunction(logPrefix)) {\n            logger.setPrefix(logPrefix);\n        } else {\n            logger.setPrefix(template.replace(\"%s\", logPrefix));\n        }\n    }\n\n    _.each(exports.callbacks, function (func, event) {\n        emitter.on(event, func.bind(this, bs));\n    });\n\n    return logger;\n};\n\n/**\n *\n * @param urls\n */\nfunction logUrls (urls) {\n\n    var keys = Object.keys(urls);\n    var longestName = 0;\n    var longesturl  = 0;\n    var offset      = 2;\n\n    if (!keys.length) {\n        return;\n    }\n\n    var names = keys.map(function (key) {\n        if (key.length > longestName) {\n            longestName = key.length;\n        }\n        if (urls[key].length > longesturl) {\n            longesturl = urls[key].length;\n        }\n        return key;\n    });\n\n    var underline  = getChars(longestName + offset + longesturl + 1, \"-\");\n    var underlined = false;\n\n    logger.info(\"{bold:Access URLs:\");\n    logger.unprefixed(\"info\", \"{grey: %s\", underline);\n\n    keys.forEach(function (key, i) {\n        var keyname = getKeyName(key);\n        logger.unprefixed(\"info\", \" %s: {magenta:%s}\",\n            getPadding(key.length, longestName + offset) + keyname,\n            urls[key]\n        );\n        if (!underlined && names[i + 1] && names[i + 1].indexOf(\"ui\") > -1) {\n            underlined = true;\n            logger.unprefixed(\"info\", \"{grey: %s}\", underline);\n        }\n    });\n\n    logger.unprefixed(\"info\", \"{grey: %s}\", underline);\n}\n\n/**\n * @param {Number} len\n * @param {Number} max\n * @returns {string}\n */\nfunction getPadding (len, max) {\n    return new Array(max - (len + 1)).join(\" \");\n}\n\n/**\n * @param {Number} len\n * @param {String} char\n * @returns {string}\n */\nfunction getChars (len, char) {\n    return new Array(len).join(char);\n}\n\n/**\n * Transform url-key names into something more presentable\n * @param key\n * @returns {string}\n */\nfunction getKeyName(key) {\n    if (key.indexOf(\"ui\") > -1) {\n        if (key === \"ui\") {\n            return \"UI\";\n        }\n        if (key === \"ui-external\") {\n            return \"UI External\";\n        }\n    }\n    return key.substr(0, 1).toUpperCase() + key.substring(1);\n}\n\n/**\n * Determine if file changes should be logged\n * @param bs\n * @param data\n * @returns {boolean}\n */\nfunction canLogFileChange(bs, data) {\n    if (data && data.log === false) {\n        return false;\n    }\n\n    return bs.options.get(\"logFileChanges\");\n}\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/sockets.js":"\"use strict\";\n\nvar socket  = require(\"socket.io\");\nvar utils   = require(\"./server/utils\");\nvar Steward = require(\"emitter-steward\");\n\n/**\n * Plugin interface\n * @returns {*|function(this:exports)}\n */\nmodule.exports.plugin = function (server, clientEvents, bs) {\n    return exports.init(server, clientEvents, bs);\n};\n\n/**\n * @param {http.Server} server\n * @param clientEvents\n * @param {BrowserSync} bs\n */\nmodule.exports.init = function (server, clientEvents, bs) {\n\n    var emitter      = bs.events;\n\n    var socketConfig = bs.options\n        .get(\"socket\")\n        .toJS();\n\n    if (bs.options.get(\"mode\") === \"proxy\" && bs.options.getIn([\"proxy\", \"ws\"])) {\n        server = utils.getServer(null, bs.options).server;\n        server.listen(bs.options.getIn([\"socket\", \"port\"]));\n        bs.registerCleanupTask(function () {\n            server.close();\n        });\n    }\n\n    var socketIoConfig  = socketConfig.socketIoOptions;\n    socketIoConfig.path = socketConfig.path;\n\n    var io = socket(server, socketIoConfig);\n\n    // Override default namespace.\n    io.sockets = io.of(socketConfig.namespace);\n\n    io.set(\"heartbeat interval\", socketConfig.clients.heartbeatTimeout);\n\n    var steward  = new Steward(emitter);\n    bs.registerCleanupTask(steward.destroy.bind(steward));\n\n    /**\n     * Listen for new connections\n     */\n    io.sockets.on(\"connection\", handleConnection);\n\n    /**\n     * Handle each new connection\n     * @param {Object} client\n     */\n    function handleConnection (client) {\n\n        // set ghostmode callbacks\n        if (bs.options.get(\"ghostMode\")) {\n\n            addGhostMode(client);\n        }\n\n        client.emit(\"connection\", bs.options.toJS()); //todo - trim the amount of options sent to clients\n\n        emitter.emit(\"client:connected\", {\n            ua: client.handshake.headers[\"user-agent\"]\n        });\n    }\n\n    /**\n     * @param {string} event\n     * @param {Socket.client} client\n     * @param {Object} data\n     */\n    function handleClientEvent(event, client, data) {\n\n        if (steward.valid(client.id)) {\n\n            client.broadcast.emit(event, data);\n        }\n    }\n\n    /**\n     * @param client\n     */\n    function addGhostMode (client) {\n\n        clientEvents.forEach(addEvent);\n\n        function addEvent(event) {\n\n            client.on(event, handleClientEvent.bind(null, event, client));\n        }\n    }\n\n    return io;\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/server/utils.js":"\"use strict\";\n\nvar fs           = require(\"fs\");\nvar path         = require(\"path\");\nvar join         = require(\"path\").join;\nvar connect      = require(\"connect\");\nvar Immutable    = require(\"immutable\");\nvar http         = require(\"http\");\nvar https        = require(\"https\");\nvar Map          = require(\"immutable\").Map;\nvar fromJS       = require(\"immutable\").fromJS;\nvar List         = require(\"immutable\").List;\nvar snippet      = require(\"./../snippet\").utils;\nvar _            = require(\"./../../lodash.custom\");\nvar serveStatic  = require(\"serve-static\");\nvar logger       = require(\"../logger\");\nvar snippetUtils = require(\"../snippet\").utils;\nvar lrSnippet    = require(\"resp-modifier\");\nvar utils        = require(\"../utils\");\n\nfunction getCa (options) {\n    var caOption = options.getIn([\"https\", \"ca\"]);\n    // if not provided, use Browsersync self-signed\n    if (typeof caOption === \"undefined\") {\n        return fs.readFileSync(join(__dirname, \"certs\", \"server.csr\"));\n    }\n    // if a string was given, read that file from disk\n    if (typeof caOption === \"string\") {\n        return fs.readFileSync(caOption);\n    }\n    // if an array was given, read all\n    if (List.isList(caOption)) {\n        return caOption.toArray().map(function (x) {\n            return fs.readFileSync(x);\n        });\n    }\n}\n\nfunction getKey(options) {\n    return fs.readFileSync(options.getIn([\"https\", \"key\"])  || join(__dirname, \"certs\", \"server.key\"));\n}\n\nfunction getCert(options) {\n    return fs.readFileSync(options.getIn([\"https\", \"cert\"]) || join(__dirname, \"certs\", \"server.crt\"));\n}\n\nfunction getHttpsServerDefaults (options) {\n    return fromJS({\n        key: getKey(options),\n        cert: getCert(options),\n        ca: getCa(options),\n        passphrase: \"\"\n    });\n}\n\nfunction getPFXDefaults (options) {\n    return fromJS({\n        pfx: fs.readFileSync(options.getIn([\"https\", \"pfx\"]))\n    });\n}\n\nvar serverUtils = {\n    /**\n     * @param options\n     * @returns {{key, cert}}\n     */\n    getHttpsOptions: function (options) {\n        var userOption = options.get(\"https\");\n        if (Map.isMap(userOption)) {\n            if (userOption.has(\"pfx\")) {\n                return userOption.mergeDeep(getPFXDefaults(options));\n            }\n            return userOption.mergeDeep(getHttpsServerDefaults(options));\n        }\n        return getHttpsServerDefaults(options);\n    },\n    /**\n     * Get either http or https server\n     * or use the httpModule provided in options if present\n     */\n    getServer: function (app, options) {\n        return {\n            server: (function () {\n\n                var httpModule = serverUtils.getHttpModule(options);\n\n                if (options.get(\"scheme\") === \"https\") {\n                    var opts = serverUtils.getHttpsOptions(options);\n                    return httpModule.createServer(opts.toJS(), app);\n                }\n\n                return httpModule.createServer(app);\n            })(),\n            app: app\n        };\n    },\n    getHttpModule: function (options) {\n        /**\n         * Users may provide a string to be used by nodes\n         * require lookup.\n         */\n        var httpModule = options.get(\"httpModule\");\n\n        if (typeof httpModule === \"string\") {\n            /**\n             * Note, this could throw, but let that happen as\n             * the error message good enough.\n             */\n            var maybe = path.resolve(process.cwd(), \"node_modules\", httpModule);\n            return require(maybe);\n        }\n\n        if (options.get(\"scheme\") === \"https\") {\n            return https;\n        }\n\n        return http;\n    },\n    getMiddlewares: function (bs) {\n\n        var clientJs = bs.pluginManager.hook(\"client:js\", {\n            port: bs.options.get(\"port\"),\n            options: bs.options\n        });\n\n        var scripts = bs.pluginManager.get(\"client:script\")(\n            bs.options.toJS(),\n            clientJs,\n            \"middleware\"\n        );\n\n        var defaultMiddlewares = [\n            {\n                id: \"Browsersync HTTP Protocol\",\n                route: require(\"../config\").httpProtocol.path,\n                handle: require(\"../http-protocol\").middleware(bs)\n            },\n            {\n                id: \"Browsersync IE8 Support\",\n                route: \"\",\n                handle: snippet.isOldIe(bs.options.get(\"excludedFileTypes\").toJS())\n            },\n            {\n                id: \"Browsersync Response Modifier\",\n                route: \"\",\n                handle: serverUtils.getSnippetMiddleware(bs)\n            },\n            {\n                id: \"Browsersync Client - versioned\",\n                route: bs.options.getIn([\"scriptPaths\", \"versioned\"]),\n                handle: scripts\n            },\n            {\n                id: \"Browsersync Client\",\n                route: bs.options.getIn([\"scriptPaths\", \"path\"]),\n                handle: scripts\n            }\n        ];\n\n        /**\n         * Add cors middleware to the front of the stack\n         * if a user provided a 'cors' flag\n         */\n        if (bs.options.get(\"cors\")) {\n            defaultMiddlewares.unshift({\n                id: \"Browsersync CORS support\",\n                route: \"\",\n                handle: serverUtils.getCorsMiddlewware()\n            })\n        }\n\n        /**\n         * Add serve static middleware\n         */\n        if (bs.options.get(\"serveStatic\")) {\n\n            var ssMiddlewares = serverUtils.getServeStaticMiddlewares(bs.options.get(\"serveStatic\"), bs.options.get(\"serveStaticOptions\", Immutable.Map({})).toJS());\n            var withErrors    = ssMiddlewares.filter(function(x) { return x.get(\"errors\").size > 0 });\n            var withoutErrors = ssMiddlewares.filter(function(x) { return x.get(\"errors\").size === 0 });\n\n            if (withErrors.size) {\n                withErrors.forEach(function (item) {\n                    logger.logger.error(\"{red:Warning!} %s\", item.getIn([\"errors\", 0, \"data\", \"message\"]));\n                });\n            }\n\n            if (withoutErrors.size) {\n                withoutErrors.forEach(function (item) {\n                    defaultMiddlewares.push.apply(defaultMiddlewares, item.get(\"items\").toJS());\n                });\n            }\n        }\n\n        /**\n         * Add user-provided middlewares\n         */\n        var userMiddlewares   = bs.options.get(\"middleware\").map(normaliseMiddleware).toArray();\n        var beforeMiddlewares = userMiddlewares.filter(function (x) { return x.override; });\n        var afterMiddlewares  = userMiddlewares.filter(function (x) { return !x.override; });\n\n        return [].concat(beforeMiddlewares, defaultMiddlewares, afterMiddlewares);\n\n        function normaliseMiddleware(item) {\n            /**\n             * Object given in options, which\n             * ended up being a Map\n             */\n            if (Map.isMap(item)) {\n                return item.toJS();\n            }\n            /**\n             * Single function\n             */\n            if (typeof item === \"function\") {\n                return {\n                    route: \"\",\n                    handle: item\n                }\n            }\n            /**\n             * Plain obj\n             */\n            if ((item.route !== undefined) && item.handle) {\n                return item;\n            }\n        }\n    },\n    getBaseApp: function (bs) {\n\n        var app         = connect();\n        var middlewares = serverUtils.getMiddlewares(bs);\n\n        /**\n         * Add all internal middlewares\n         */\n        middlewares.forEach(function (item) {\n            app.stack.push(item);\n        });\n\n        return app;\n    },\n    getSnippetMiddleware: function (bs) {\n\n        var rules = [];\n        var blacklist = List([])\n            .concat(bs.options.getIn([\"snippetOptions\", \"ignorePaths\"]))\n            .concat(bs.options.getIn([\"snippetOptions\", \"blacklist\"]))\n            .filter(Boolean);\n\n        var whitelist = List([])\n            .concat(bs.options.getIn([\"snippetOptions\", \"whitelist\"]));\n\n        // Snippet\n        rules.push(snippetUtils.getRegex(bs.options.get(\"snippet\"), bs.options.get(\"snippetOptions\")));\n\n        // User\n        bs.options.get(\"rewriteRules\").forEach(function (rule) {\n            if (Map.isMap(rule)) {\n                rules.push(rule.toJS());\n            }\n            if (_.isPlainObject(rule)) {\n                rules.push(rule);\n            }\n        });\n\n        // Proxy\n        if (bs.options.get(\"proxy\")) {\n            var proxyRule = require(\"./proxy-utils\").rewriteLinks(bs.options.getIn([\"proxy\", \"url\"]).toJS());\n            rules.push(proxyRule);\n        }\n\n        var lr = lrSnippet.create({\n            rules:     rules,\n            blacklist: blacklist.toArray(),\n            whitelist: whitelist.toArray()\n        });\n\n        return lr.middleware;\n    },\n    getCorsMiddlewware: function () {\n\n        return function (req, res, next) {\n            // Website you wish to allow to connect\n            res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n\n            // Request methods you wish to allow\n            res.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS, PUT, PATCH, DELETE\");\n\n            // Request headers you wish to allow\n            res.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With,content-type\");\n\n            // Set to true if you need the website to include cookies in the requests sent\n            // to the API (e.g. in case you use sessions)\n            res.setHeader(\"Access-Control-Allow-Credentials\", true);\n            next();\n        }\n    },\n    /**\n     * @param ssOption\n     * @param serveStaticOptions\n     * @returns {*}\n     */\n    getServeStaticMiddlewares: function (ssOption, serveStaticOptions) {\n\n        return ssOption.map(function (dir, i) {\n\n            /**\n             * When a user gives a plain string only, eg:\n             *   serveStatic: ['./temp']\n             *     ->\n             *       This means a middleware will be created with\n             *         route: ''\n             *         handle: serveStatic('./temp', options)\n             */\n            if (_.isString(dir)) {\n                return getFromString(dir)\n            }\n\n            /**\n             * If a user gave an object eg:\n             *   serveStatic: [{route: \"\", dir: [\"test\", \"./tmp\"]}]\n             *     ->\n             *       This means we need to create a middle for each route + dir combo\n             */\n            if (Immutable.Map.isMap(dir)) {\n                return getFromMap(dir, i);\n            }\n\n            /**\n             * At this point, an item in the serveStatic array was not a string\n             * or an object so we return an error that can be logged\n             */\n            return fromJS({\n                items: [],\n                errors: [{\n                    type: \"Invalid Type\",\n                    data: {\n                        message: \"Only strings and Objects (with route+dir) are supported for the ServeStatic option\"\n                    }\n                }]\n            })\n        });\n\n        /**\n         * @param {string} x\n         * @returns {string}\n         */\n        function getRoute (x) {\n            if (x === \"\") return \"\";\n            return x[0] === \"/\" ? x : \"/\" + x;\n        }\n\n        /**\n         * @param dir\n         * @returns {Map}\n         */\n        function getFromString(dir) {\n            return fromJS({\n                items: [\n                    {\n                        route: \"\",\n                        handle: serveStatic(dir, serveStaticOptions)\n                    }\n                ],\n                errors: []\n            })\n        }\n\n        /**\n         * @param dir\n         * @returns {Map}\n         */\n        function getFromMap(dir) {\n\n            var ssOptions = (function () {\n                if (dir.get(\"options\")) {\n                    return dir.get(\"options\").toJS();\n                }\n                return {}\n            })();\n\n            var route = Immutable.List([]).concat(dir.get(\"route\")).filter(_.isString);\n            var _dir  = Immutable.List([]).concat(dir.get(\"dir\")).filter(_.isString);\n\n            if (_dir.size === 0) {\n\n                return fromJS({\n                    items: [],\n                    errors: [{\n                        type: \"Invalid Object\",\n                        data: {\n                            message: \"Serve Static requires a 'dir' property when using an Object\"\n                        }\n                    }]\n                })\n            }\n\n            var ssItems = (function () {\n\n                /**\n                 * iterate over every 'route' item\n                 * @type {Immutable.List<any>|Immutable.List<*>|Immutable.List<any>|*}\n                 */\n                var routeItems = (function () {\n\n                    /**\n                     * If no 'route' was given, assume we want to match all\n                     * paths\n                     */\n                    if (route.size === 0) {\n                        return _dir.map(function (dirString) {\n                            return Map({\n                                route: \"\",\n                                dir: dirString\n                            });\n                        });\n                    }\n\n                    return route.reduce(function (acc, routeString) {\n                        /**\n                         * For each 'route' item, also iterate through 'dirs'\n                         * @type {Immutable.Iterable<K, M>}\n                         */\n                        var perDir = _dir.map(function (dirString) {\n                            return Map({\n                                route: getRoute(routeString),\n                                dir: dirString\n                            })\n                        });\n                        return acc.concat(perDir);\n\n                    }, List([]));\n                })();\n\n                /**\n                 * Now create a serverStatic Middleware for each item\n                 */\n                return routeItems.map(function (routeItem) {\n                    return routeItem.merge({\n                        handle: serveStatic(routeItem.get(\"dir\"), ssOptions)\n                    });\n                });\n            })();\n\n            return fromJS({\n                items: ssItems,\n                errors: []\n            });\n        }\n    }\n};\n\nmodule.exports = serverUtils;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/file-watcher.js":"\"use strict\";\n\nvar _ = require(\"../lodash.custom\");\nvar utils = require(\"./utils\");\nvar Rx = require(\"rx\");\n\n/**\n * Plugin interface\n * @returns {*|function(this:exports)}\n */\nmodule.exports.plugin = function (bs) {\n\n    var options = bs.options;\n    var emitter = bs.emitter;\n\n    var defaultWatchOptions = options.get(\"watchOptions\").toJS();\n\n    return options.get(\"files\").reduce(function (map, glob, namespace) {\n\n        /**\n         * Default CB when not given\n         * @param event\n         * @param path\n         */\n        var fn = function (event, path) {\n            emitter.emit(\"file:changed\", {\n                event: event,\n                path: path,\n                namespace: namespace\n            });\n        };\n\n        var jsItem = glob.toJS();\n\n        if (jsItem.globs.length) {\n            var watcher = watch(jsItem.globs, defaultWatchOptions, fn);\n            map[namespace] = {\n                watchers: [watcher]\n            };\n        }\n\n        if (jsItem.objs.length) {\n            jsItem.objs.forEach(function (item) {\n                if (!_.isFunction(item.fn)) {\n                    item.fn = fn;\n                }\n                var watcher = watch(item.match, item.options || defaultWatchOptions, item.fn.bind(bs.publicInstance));\n                if (!map[namespace]) {\n                    map[namespace] = {\n                        watchers: [watcher]\n                    };\n                } else {\n                    map[namespace].watchers.push(watcher);\n                }\n            });\n        }\n\n        return map;\n\n    }, {});\n};\n\n/**\n * @param patterns\n * @param opts\n * @param cb\n * @returns {*}\n */\nfunction watch (patterns, opts, cb) {\n\n    if (typeof opts === \"function\") {\n        cb = opts;\n        opts = {};\n    }\n\n    var watcher = require(\"chokidar\")\n        .watch(patterns, opts);\n\n    if (_.isFunction(cb)) {\n        watcher.on(\"all\", cb);\n    }\n\n    return watcher;\n}\n\nmodule.exports.watch = watch;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/server/index.js":"\"use strict\";\n\nvar enableDestroy = require(\"server-destroy\");\nvar _ = require(\"../../lodash.custom\");\n\n/**\n * Browsersync server\n * Three available modes: Snippet, Server or Proxy\n */\nmodule.exports.plugin = function (bs) {\n\n    var debug   = bs.debug;\n    var proxy   = bs.options.get(\"proxy\");\n    var type    = bs.options.get(\"mode\");\n\n    var bsServer = createServer(bs);\n\n    if (type === \"server\" || type === \"snippet\") {\n        debug(\"Static Server running ({magenta:%s}) ...\", bs.options.get(\"scheme\"));\n    }\n\n    if (proxy) {\n        debug(\"Proxy running, proxing: {magenta:%s}\", proxy.get(\"target\"));\n    }\n\n    if (bsServer) {\n\n        /**\n         * Allow server to be destroyed gracefully\n         */\n        enableDestroy(bsServer.server);\n\n        /**\n         * Listen on the available port\n         */\n        bsServer.server.listen(bs.options.get(\"port\"));\n\n        /**\n         * Hack to deal with https://github.com/socketio/socket.io/issues/1602#issuecomment-224270022\n         */\n        bs.registerCleanupTask(function () {\n            if (bs.io && bs.io.sockets) {\n                setCloseReceived(bs.io.sockets);\n            }\n            if (bs.ui && bs.ui.socket) {\n                setCloseReceived(bs.ui.socket);\n            }\n        });\n\n        /**\n         * Destroy the server on cleanup\n         */\n        bs.registerCleanupTask(function () {\n            bsServer.server.destroy();\n        });\n    }\n\n    function setCloseReceived(io) {\n        Object.keys(io.sockets).forEach(function (key) {\n            _.set(io.sockets[key], \"conn.transport.socket._closeReceived\", true);\n        });\n    }\n\n    debug(\"Running mode: %s\", type.toUpperCase());\n\n    return {\n        server: bsServer.server,\n        app:    bsServer.app\n    };\n};\n\n/**\n * Launch the server for serving the client JS plus static files\n * @param {BrowserSync} bs\n * @returns {{staticServer: (http.Server), proxyServer: (http.Server)}}\n */\nfunction createServer (bs) {\n\n    var proxy   = bs.options.get(\"proxy\");\n    var server  = bs.options.get(\"server\");\n\n    if (!proxy && !server) {\n        return require(\"./snippet-server\")(bs);\n    }\n\n    if (proxy) {\n        return require(\"./proxy-server\")(bs);\n    }\n\n    if (server) {\n        return require(\"./static-server\")(bs);\n    }\n}\n\nmodule.exports.createServer = createServer;\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/tunnel.js":"\"use strict\";\n\nvar _ = require(\"../lodash.custom\");\nvar utils = require(\"util\");\n\n/**\n * @param {BrowserSync} bs\n * @param {Function} cb\n */\nmodule.exports = function (bs, cb) {\n\n    var opts         = {};\n    var options      = bs.options;\n    var port         = options.get(\"port\");\n\n    if (_.isString(options.get(\"tunnel\"))) {\n        opts.subdomain = options.get(\"tunnel\");\n    }\n\n    bs.debug(\"Requesting a tunnel connection on port: {magenta:%s}\", port);\n    bs.debug(\"Requesting a tunnel connection with options: {magenta:%s}\", utils.inspect(opts));\n\n    require(\"localtunnel\")(port, opts, function (err, tunnel) {\n        if (err) {\n            return cb(err);\n        }\n\n        tunnel.on(\"error\", function (err) {\n            bs.logger.info(\"Localtunnel issue: \" + err.message);\n            bs.logger.info(\"Oops! The localtunnel appears to have disconnected. Reconnecting...\");\n        });\n\n        return cb(null, tunnel);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-browser-sync/browser-sync/lib/public/public-utils.js":"\"use strict\";\n\nvar _ = require(\"../../lodash.custom\");\n\nmodule.exports = {\n    /**\n     * Emit the internal `file:change` event\n     * @param {EventEmitter} emitter\n     * @param {string} path\n     * @param {boolean} [log]\n     */\n    emitChangeEvent: function emitChangeEvent (emitter, path, log) {\n        emitter.emit(\"file:changed\", {\n            path:      path,\n            log:       log,\n            namespace: \"core\",\n            event:     \"change\"\n        });\n    },\n    /**\n     * Emit the internal `browser:reload` event\n     * @param {EventEmitter} emitter\n     */\n    emitBrowserReload: function emitChangeEvent (emitter) {\n        emitter.emit(\"_browser:reload\");\n    },\n    /**\n     * Emit the internal `stream:changed` event\n     * @param {EventEmitter} emitter\n     * @param {Array} changed\n     */\n    emitStreamChangedEvent: function (emitter, changed) {\n        emitter.emit(\"stream:changed\", {changed: changed});\n    },\n    /**\n     * This code handles the switch between .reload & .stream\n     * since 2.6.0\n     * @param name\n     * @param args\n     * @returns {boolean}\n     */\n    isStreamArg: function (name, args) {\n\n        if (name === \"stream\") {\n            return true;\n        }\n\n        if (name !== \"reload\") {\n            return false;\n        }\n\n        var firstArg = args[0];\n\n        /**\n         * If here, it's reload with args\n         */\n        if (_.isObject(firstArg)) {\n            if (!Array.isArray(firstArg) && Object.keys(firstArg).length) {\n                return firstArg.stream === true;\n            }\n        }\n\n        return false;\n    }\n};\n"}